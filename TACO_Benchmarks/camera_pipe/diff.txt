0a1
> 
4d4
< #include "../autoscheduler/SimpleAutoSchedule.h"
27c27
<     Func out;
---
>     Func out("ivx");
33c33
<     Func out;
---
>     Func out("ivy");
48,54d47
<     bool use_simple_autoscheduler = false;
< 
<     Demosaic() {
<         use_simple_autoscheduler =
<             Halide::Internal::get_env_variable("HL_USE_SIMPLE_AUTOSCHEDULER") == "1";
<     }
< 
164,165c157,159
<         if (auto_schedule || use_simple_autoscheduler) {
<             // Nothing
---
>         if (auto_schedule) {
>  //       output.bound(c,0,4);
>             // blank
243,248d236
<     bool use_simple_autoscheduler = false;
< 
<     CameraPipe() {
<         use_simple_autoscheduler =
<             Halide::Internal::get_env_variable("HL_USE_SIMPLE_AUTOSCHEDULER") == "1";
<     }
292c280
<     if (!auto_schedule && !use_simple_autoscheduler) {
---
>     if (!auto_schedule) {
314c302
< 
---
>     corrected.bound(c,0,3);
355c343
<     if (!auto_schedule && !use_simple_autoscheduler) {
---
>     if (!auto_schedule) {
386c374
< 
---
>     
394c382
<     if (!auto_schedule && !use_simple_autoscheduler) {
---
>     if (!auto_schedule) {
412c400
< 
---
>     unsharp_y.bound(c,0,3);
449,454d436
<     Expr out_width = processed.width();
<     Expr out_height = processed.height();
<     processed.bound(c, 0, 3)
<         .bound(x, 0, (out_width / 2) * 2)
<         .bound(y, 0, (out_height / 2) * 2);
< 
457,460c439,447
< 
<         input.dim(0).set_bounds(0, 2592);
<         input.dim(1).set_bounds(0, 1968);
< 
---
>                 Expr out_width = processed.width();
>             Expr out_height = processed.height();
>             processed.bound(c, 0, 3)
>                 .bound(x, 0, (out_width / 2) * 2)
>                 .bound(y, 0, (out_height / 2) * 2);
>     
>         input.dim(0).set_bounds_estimate(0, 2592);
>         input.dim(1).set_bounds_estimate(0, 1968);
>     
465,472c452,453
< 
<         sharpen_strength.set_estimate(1.0f);
<         blackLevel.set_estimate(25);
<         whiteLevel.set_estimate(1023);
<         gamma.set_estimate(2);
<         contrast.set_estimate(50);
<         color_temp.set_estimate(3200);
< 
---
>         curved.bound(c,0,3);
>         //deinterleaved.bound(c,0,3);
474,504c455,457
<             .estimate(x, 0, 2592)
<             .estimate(y, 0, 1968);
< 
<     } else if (use_simple_autoscheduler) {
<         Halide::SimpleAutoscheduleOptions options;
<         options.gpu = get_target().has_gpu_feature();
<         options.gpu_tile_channel = 1;
<         Func output_func = processed;
<         Halide::simple_autoschedule(output_func,
<                     {{"sharpen_strength", 1.0f},
<                      {"blackLevel", 25},
<                      {"whiteLevel", 1023},
<                      {"gamma", 2.f},
<                      {"contrast", 50.f},
<                      {"color_temp", 3200.f},
<                      {"input.min.0", 0},
<                      {"input.extent.0", 2592},
<                      {"input.min.1", 0},
<                      {"input.extent.1", 1968},
<                      {"matrix3200.min.0", 0},
<                      {"matrix3200.extent.0", 4},
<                      {"matrix3200.min.1", 0},
<                      {"matrix3200.extent.1", 3},
<                      {"matrix7000.min.0", 0},
<                      {"matrix7000.extent.0", 4},
<                      {"matrix7000.min.1", 0},
<                      {"matrix7000.extent.1", 3}},
<                     {{0, 2592-32},
<                      {0, 1968-48},
<                      {0, 3}},
<                     options);
---
>             .estimate(c, 0, 3)
>             .estimate(x, 0, 2560)
>             .estimate(y, 0, 1920);
511c464
<             // accommodate bounds on the output Func.
---
>             // accomodate bounds on the output Func.
525c478
<             .gpu_tile(x, y, xi, yi, 28, 12); // N.B. Using 32 instead of 28 is only 5% slower
---
>             .gpu_tile(x, y, xi, yi, 28, 12);
547a501
> 
613d566
<     }
615,651c568,610
<     /* Optional tags to specify layout for HalideTraceViz */
<     {
<         Halide::Trace::FuncConfig cfg;
<         cfg.max = 1024;
<         cfg.pos = { 10, 348 };
<         cfg.labels = {{"input"}};
<         input.add_trace_tag(cfg.to_trace_tag());
< 
<         cfg.pos = { 305, 360 };
<         cfg.labels = {{"denoised"}};
<         denoised.add_trace_tag(cfg.to_trace_tag());
< 
<         cfg.pos = { 580, 120 };
<         const int y_offset = 220;
<         cfg.strides = {{1, 0}, {0, 1}, {0, y_offset}};
<         cfg.labels = {
<             { "gr", { 0, 0 * y_offset } },
<             { "r",  { 0, 1 * y_offset }},
<             { "b",  { 0, 2 * y_offset }},
<             { "gb", { 0, 3 * y_offset }},
<         };
<         deinterleaved.add_trace_tag(cfg.to_trace_tag());
< 
<         cfg.color_dim = 2;
<         cfg.strides = {{1, 0}, {0, 1}, {0, 0}};
<         cfg.pos = { 1140, 360 };
<         cfg.labels = {{"demosaiced"}};
<         processed.add_trace_tag(cfg.to_trace_tag());
< 
<         cfg.pos = { 1400, 360 };
<         cfg.labels = {{"color-corrected"}};
<         corrected.add_trace_tag(cfg.to_trace_tag());
< 
<         cfg.max = 256;
<         cfg.pos = { 1660, 360 };
<         cfg.labels = {{"gamma-corrected"}};
<         curved.add_trace_tag(cfg.to_trace_tag());
---
>         // We can generate slightly better code if we know the splits divide the extent.
>         processed
>             .bound(c, 0, 3)
>             .bound(x, 0, ((out_width)/(2*vec))*(2*vec))
>             .bound(y, 0, (out_height/strip_size)*strip_size);
> 
>         /* Optional tags to specify layout for HalideTraceViz */
>         {
>             Halide::Trace::FuncConfig cfg;
>             cfg.max = 1024;
>             cfg.pos = { 10, 348 };
>             cfg.labels = {{"input"}};
>             input.add_trace_tag(cfg.to_trace_tag());
> 
>             cfg.pos = { 305, 360 };
>             cfg.labels = {{"denoised"}};
>             denoised.add_trace_tag(cfg.to_trace_tag());
> 
>             cfg.pos = { 580, 120 };
>             const int y_offset = 220;
>             cfg.strides = {{1, 0}, {0, 1}, {0, y_offset}};
>             cfg.labels = {
>                 { "gr", { 0, 0 * y_offset } },
>                 { "r",  { 0, 1 * y_offset }},
>                 { "b",  { 0, 2 * y_offset }},
>                 { "gb", { 0, 3 * y_offset }},
>             };
>             deinterleaved.add_trace_tag(cfg.to_trace_tag());
> 
>             cfg.color_dim = 2;
>             cfg.strides = {{1, 0}, {0, 1}, {0, 0}};
>             cfg.pos = { 1140, 360 };
>             cfg.labels = {{"demosaiced"}};
>             processed.add_trace_tag(cfg.to_trace_tag());
> 
>             cfg.pos = { 1400, 360 };
>             cfg.labels = {{"color-corrected"}};
>             corrected.add_trace_tag(cfg.to_trace_tag());
> 
>             cfg.max = 256;
>             cfg.pos = { 1660, 360 };
>             cfg.labels = {{"gamma-corrected"}};
>             curved.add_trace_tag(cfg.to_trace_tag());
652a612
>         }
654c614
< }
---
> };
