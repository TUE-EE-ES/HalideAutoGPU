Generator lens_blur has base_path ./bin/lens_blur_auto_schedule
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
Creating initial loop nests...
Injecting realization of { final }
Injecting realization of { output }
Injecting realization of { sample_weight }
Injecting realization of { maximum$1 }
Injecting realization of { maximum }
Injecting realization of { argmin }
Injecting realization of { filtered_cost }
Inlining cost_pyramid_pull[0]
Injecting realization of { upx$6 }
Injecting realization of { cost_pyramid_pull[1] }
Injecting realization of { upx$5 }
Injecting realization of { cost_pyramid_pull[2] }
Injecting realization of { upx$4 }
Injecting realization of { cost_pyramid_pull[3] }
Injecting realization of { upx$3 }
Injecting realization of { cost_pyramid_pull[4] }
Injecting realization of { upx$2 }
Injecting realization of { cost_pyramid_pull[5] }
Injecting realization of { upx }
Injecting realization of { downy$6 }
Injecting realization of { downx$6 }
Injecting realization of { downy$5 }
Injecting realization of { downx$5 }
Injecting realization of { downy$4 }
Injecting realization of { downx$4 }
Injecting realization of { downy$3 }
Injecting realization of { downx$3 }
Injecting realization of { downy$2 }
Injecting realization of { downx$2 }
Inlining repeat_edge$3
Injecting realization of { downy$1 }
Injecting realization of { downx$1 }
Injecting realization of { downy }
Injecting realization of { downx }
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
Inlining cost_pyramid_push[0]
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
Injecting realization of { cost_confidence }
Injecting realization of { sum$1 }
Injecting realization of { sum }
Inlining cost
Injecting realization of { diff }
Injecting realization of { repeat_edge$1 }
Injecting realization of { repeat_edge }
Skipping injecting memoization...
Injecting tracing...
Adding checks for parameters
Computing bounds of each function's value
Adding checks for images
Performing computation bounds inference...
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
User error triggered at /home/ssioutas/Halide_RTX/src/Inline.cpp:81
Warning at ../../distrib/tools/GenGen.cpp:4:
It is meaningless to bound dimension c of function cost_pyramid_push[0] to be within [0, 2] because the function is scheduled inline.
Removing extern loops...
Performing sliding window optimization...
Simplifying correlated differences...
Warning: expression is non-monotonic in loop variable upx$2.s0.y.y_o: (let t103827 = min(((upx$2.s0.y.y_o*8) + upx$2.s0.y.loop_min), (upx$2.s0.y.loop_max + -7)) in ((((((upx$2.s0.y.y_i.loop_extent + upx$2.s0.y.y_i.loop_min) + t103827) + 5)/4) - (((t103827 + upx$2.s0.y.y_i.loop_min) + -6)/4)) + 1))
Warning: expression is non-monotonic in loop variable upx$2.s0.x.x_o: (let t103839 = min(((upx$2.s0.x.x_o*8) + upx$2.s0.x.loop_min), (upx$2.s0.x.loop_max + -7)) in ((((((upx$2.s0.x.x_i.loop_extent + upx$2.s0.x.x_i.loop_min) + t103839) + 1)/4) - (((t103839 + upx$2.s0.x.x_i.loop_min) + -2)/4)) + 3))
Warning: expression is non-monotonic in loop variable upx$2.s0.x.x_o: (let t103845 = min(((upx$2.s0.x.x_o*8) + upx$2.s0.x.loop_min), (upx$2.s0.x.loop_max + -7)) in ((((((upx$2.s0.x.x_i.loop_extent + upx$2.s0.x.x_i.loop_min) + t103845) + -1)/2) - ((t103845 + upx$2.s0.x.x_i.loop_min)/2)) + 3))
Warning: expression is non-monotonic in loop variable cost_pyramid_pull[2].s0.y.y_o: (let t103863 = min(((cost_pyramid_pull[2].s0.y.y_o*16) + cost_pyramid_pull[2].s0.y.loop_min), (cost_pyramid_pull[2].s0.y.loop_max + -15)) in ((((((cost_pyramid_pull[2].s0.y.y_i.loop_extent + cost_pyramid_pull[2].s0.y.y_i.loop_min) + t103863) + 1)/4) - (((cost_pyramid_pull[2].s0.y.y_i.loop_min + t103863) + -2)/4)) + 3))
Warning: expression is non-monotonic in loop variable cost_pyramid_pull[2].s0.y.y_o: (let t103873 = min(((cost_pyramid_pull[2].s0.y.y_o*16) + cost_pyramid_pull[2].s0.y.loop_min), (cost_pyramid_pull[2].s0.y.loop_max + -15)) in ((((((cost_pyramid_pull[2].s0.y.y_i.loop_extent + cost_pyramid_pull[2].s0.y.y_i.loop_min) + t103873) + 1)/4) - (((cost_pyramid_pull[2].s0.y.y_i.loop_min + t103873) + -2)/4)) + 3))
Warning: expression is non-monotonic in loop variable cost_pyramid_pull[2].s0.y.y_o: (let t103879 = min(((cost_pyramid_pull[2].s0.y.y_o*16) + cost_pyramid_pull[2].s0.y.loop_min), (cost_pyramid_pull[2].s0.y.loop_max + -15)) in ((((((cost_pyramid_pull[2].s0.y.y_i.loop_extent + cost_pyramid_pull[2].s0.y.y_i.loop_min) + t103879) + -1)/2) - ((cost_pyramid_pull[2].s0.y.y_i.loop_min + t103879)/2)) + 3))
Warning: expression is non-monotonic in loop variable cost_pyramid_pull[2].s0.y.y_o: (let t103885 = min(((cost_pyramid_pull[2].s0.y.y_o*16) + cost_pyramid_pull[2].s0.y.loop_min), (cost_pyramid_pull[2].s0.y.loop_max + -15)) in ((((((cost_pyramid_pull[2].s0.y.y_i.loop_extent + cost_pyramid_pull[2].s0.y.y_i.loop_min) + t103885) + -1)/2) - ((cost_pyramid_pull[2].s0.y.y_i.loop_min + t103885)/2)) + 3))
Warning: expression is non-monotonic in loop variable cost_pyramid_pull[2].s0.x.x_o: (let t103895 = min(((cost_pyramid_pull[2].s0.x.x_o*16) + cost_pyramid_pull[2].s0.x.loop_min), (cost_pyramid_pull[2].s0.x.loop_max + -15)) in ((((((cost_pyramid_pull[2].s0.x.x_i.loop_extent + cost_pyramid_pull[2].s0.x.x_i.loop_min) + t103895) + 1)/4) - (((cost_pyramid_pull[2].s0.x.x_i.loop_min + t103895) + -2)/4)) + 3))
Warning: expression is non-monotonic in loop variable cost_pyramid_pull[2].s0.x.x_o: (let t103901 = min(((cost_pyramid_pull[2].s0.x.x_o*16) + cost_pyramid_pull[2].s0.x.loop_min), (cost_pyramid_pull[2].s0.x.loop_max + -15)) in ((((((cost_pyramid_pull[2].s0.x.x_i.loop_extent + cost_pyramid_pull[2].s0.x.x_i.loop_min) + t103901) + -1)/2) - ((cost_pyramid_pull[2].s0.x.x_i.loop_min + t103901)/2)) + 3))
Warning: expression is non-monotonic in loop variable cost_pyramid_pull[2].s0.x.x_o: (let t103907 = min(((cost_pyramid_pull[2].s0.x.x_o*16) + cost_pyramid_pull[2].s0.x.loop_min), (cost_pyramid_pull[2].s0.x.loop_max + -15)) in ((((((cost_pyramid_pull[2].s0.x.x_i.loop_extent + cost_pyramid_pull[2].s0.x.x_i.loop_min) + t103907) + -1)/2) - ((cost_pyramid_pull[2].s0.x.x_i.loop_min + t103907)/2)) + 3))
Warning: expression is non-monotonic in loop variable filtered_cost.s0.y.y_o: (let t103925 = min(((filtered_cost.s0.y.y_o*16) + filtered_cost.s0.y.loop_min), (filtered_cost.s0.y.loop_max + -15)) in ((((((filtered_cost.s0.y.y_i.loop_extent + filtered_cost.s0.y.y_i.loop_min) + t103925) + 1)/4) - (((filtered_cost.s0.y.y_i.loop_min + t103925) + -2)/4)) + 3))
Warning: expression is non-monotonic in loop variable filtered_cost.s0.y.y_o: (let t103931 = min(((filtered_cost.s0.y.y_o*16) + filtered_cost.s0.y.loop_min), (filtered_cost.s0.y.loop_max + -15)) in ((((((filtered_cost.s0.y.y_i.loop_extent + filtered_cost.s0.y.y_i.loop_min) + t103931) + -1)/2) - ((filtered_cost.s0.y.y_i.loop_min + t103931)/2)) + 3))
Warning: expression is non-monotonic in loop variable filtered_cost.s0.y.y_o: (let t103937 = min(((filtered_cost.s0.y.y_o*16) + filtered_cost.s0.y.loop_min), (filtered_cost.s0.y.loop_max + -15)) in ((((((filtered_cost.s0.y.y_i.loop_extent + filtered_cost.s0.y.y_i.loop_min) + t103937) + -1)/2) - ((filtered_cost.s0.y.y_i.loop_min + t103937)/2)) + 3))
Warning: expression is non-monotonic in loop variable filtered_cost.s0.x.x_o: (let t103943 = min(((filtered_cost.s0.x.x_o*16) + filtered_cost.s0.x.loop_min), (filtered_cost.s0.x.loop_max + -15)) in ((((((filtered_cost.s0.x.x_i.loop_extent + filtered_cost.s0.x.x_i.loop_min) + t103943) + -1)/2) - ((filtered_cost.s0.x.x_i.loop_min + t103943)/2)) + 3))
Warning: expression is non-monotonic in loop variable filtered_cost.s0.x.x_o: (let t103949 = min(((filtered_cost.s0.x.x_o*16) + filtered_cost.s0.x.loop_min), (filtered_cost.s0.x.loop_max + -15)) in ((((((filtered_cost.s0.x.x_i.loop_extent + filtered_cost.s0.x.x_i.loop_min) + t103949) + -1)/2) - ((filtered_cost.s0.x.x_i.loop_min + t103949)/2)) + 3))
Performing allocation bounds inference...
Removing code that depends on undef values...
Uniquifying variable names...
Simplifying...
Performing storage folding optimization...
Injecting debug_to_file calls...
Injecting prefetches...
Dynamically skipping stages...
Forking asynchronous producers...
Destructuring tuple-valued realizations...
Canonicalizing GPU var names...
Performing storage flattening...
Unpacking buffer arguments...
Skipping rewriting memoized allocations...
Selecting a GPU API for GPU loops...
Injecting host <-> dev buffer copies...
Selecting a GPU API for extern stages...
Simplifying...
Reduce prefetch dimension...
Lowering after reduce prefetch dimension:
assert((reinterpret(uint64, right_im.buffer) != (uint64)0), halide_error_buffer_argument_is_null("right_im"))
assert((reinterpret(uint64, left_im.buffer) != (uint64)0), halide_error_buffer_argument_is_null("left_im"))
assert((reinterpret(uint64, final.buffer) != (uint64)0), halide_error_buffer_argument_is_null("final"))
let final = _halide_buffer_get_host(final.buffer)
let final.type = _halide_buffer_get_type(final.buffer)
let final.dimensions = _halide_buffer_get_dimensions(final.buffer)
let final.min.0 = _halide_buffer_get_min(final.buffer, 0)
let final.extent.0 = _halide_buffer_get_extent(final.buffer, 0)
let final.stride.0 = _halide_buffer_get_stride(final.buffer, 0)
let final.min.1 = _halide_buffer_get_min(final.buffer, 1)
let final.extent.1 = _halide_buffer_get_extent(final.buffer, 1)
let final.stride.1 = _halide_buffer_get_stride(final.buffer, 1)
let final.min.2 = _halide_buffer_get_min(final.buffer, 2)
let final.extent.2 = _halide_buffer_get_extent(final.buffer, 2)
let final.stride.2 = _halide_buffer_get_stride(final.buffer, 2)
let left_im = _halide_buffer_get_host(left_im.buffer)
let left_im.type = _halide_buffer_get_type(left_im.buffer)
let left_im.dimensions = _halide_buffer_get_dimensions(left_im.buffer)
let left_im.min.0 = _halide_buffer_get_min(left_im.buffer, 0)
let left_im.extent.0 = _halide_buffer_get_extent(left_im.buffer, 0)
let left_im.stride.0 = _halide_buffer_get_stride(left_im.buffer, 0)
let left_im.min.1 = _halide_buffer_get_min(left_im.buffer, 1)
let left_im.extent.1 = _halide_buffer_get_extent(left_im.buffer, 1)
let left_im.stride.1 = _halide_buffer_get_stride(left_im.buffer, 1)
let left_im.min.2 = _halide_buffer_get_min(left_im.buffer, 2)
let left_im.extent.2 = _halide_buffer_get_extent(left_im.buffer, 2)
let left_im.stride.2 = _halide_buffer_get_stride(left_im.buffer, 2)
let right_im = _halide_buffer_get_host(right_im.buffer)
let right_im.type = _halide_buffer_get_type(right_im.buffer)
let right_im.dimensions = _halide_buffer_get_dimensions(right_im.buffer)
let right_im.min.0 = _halide_buffer_get_min(right_im.buffer, 0)
let right_im.extent.0 = _halide_buffer_get_extent(right_im.buffer, 0)
let right_im.stride.0 = _halide_buffer_get_stride(right_im.buffer, 0)
let right_im.min.1 = _halide_buffer_get_min(right_im.buffer, 1)
let right_im.extent.1 = _halide_buffer_get_extent(right_im.buffer, 1)
let right_im.stride.1 = _halide_buffer_get_stride(right_im.buffer, 1)
let right_im.min.2 = _halide_buffer_get_min(right_im.buffer, 2)
let right_im.extent.2 = _halide_buffer_get_extent(right_im.buffer, 2)
let right_im.stride.2 = _halide_buffer_get_stride(right_im.buffer, 2)
let maximum$1.s1.r$2$x.max = int32((blur_radius_scale*float32(max((slices - focus_depth), focus_depth))))
let maximum$1.s1.r$2$x.min = (0 - maximum$1.s1.r$2$x.max)
let maximum.s1.r$2$x.max = maximum$1.s1.r$2$x.max
let maximum.s1.r$2$x.min = maximum$1.s1.r$2$x.min
let argmin.s1.y.max.s = (max(max(max((0 - maximum$1.s1.r$2$x.max), maximum$1.s1.r$2$x.max), maximum.s1.r$2$x.max), 0) + (final.extent.1 + final.min.1))
let argmin.s1.y.min = min((final.min.1 - max(maximum$1.s1.r$2$x.max, 0)), (final.min.1 + maximum$1.s1.r$2$x.min))
let argmin.s1.x.max.s = (max(max(max((0 - maximum$1.s1.r$2$x.max), maximum$1.s1.r$2$x.max), maximum.s1.r$2$x.max), 0) + (final.extent.0 + final.min.0))
let argmin.s1.x.min = min((final.min.0 - max(maximum$1.s1.r$2$x.max, 0)), (final.min.0 + maximum$1.s1.r$2$x.min))
let downy$6.s0.y.max.s = min((argmin.s1.y.max.s + 381), left_im.extent.1)
let downy$6.s0.y.min.s = min((left_im.extent.1 + 126), argmin.s1.y.min)
let downy$6.s0.x.max.s = min((argmin.s1.x.max.s + 381), left_im.extent.0)
let downy$6.s0.x.min.s = min((argmin.s1.x.min + -126), left_im.extent.0)
let downy$5.s0.y.max = max(min((max((downy$6.s0.y.max.s/128), 1)*2), ((left_im.extent.1/64) + -1)), (max((min((argmin.s1.y.max.s + 189), left_im.extent.1)/64), 1) + -1))
let downy$5.s0.y.min.s = min(min((left_im.extent.1/64), (max(((downy$6.s0.y.min.s + -254)/128), 0)*2)), (min((argmin.s1.y.min + -62), left_im.extent.1)/64))
let downy$5.s0.x.max.s = max(min((max((downy$6.s0.x.max.s/128), 1)*2), ((left_im.extent.0/64) + 1)), (max(max(min((left_im.extent.0/64), ((max((downy$6.s0.x.max.s/128), 1)*2) + 1)), (min((argmin.s1.x.max.s + 189), left_im.extent.0)/64)), 1) + 1))
let downy$5.s0.x.min.s = min(max(min((max((downy$6.s0.x.min.s/128), 1)*2), ((left_im.extent.0/64) + 1)), 2), (max(min(min((left_im.extent.0/64), ((max((downy$6.s0.x.min.s/128), 1)*2) + -2)), (min((argmin.s1.x.min + -62), left_im.extent.0)/64)), 1) + 1))
let downy$4.s0.y.max.s = min(max(((argmin.s1.y.max.s + 61)/32), ((downy$5.s0.y.max*2) + 2)), ((left_im.extent.1/32) + -1))
let downy$4.s0.y.min.s = min(min(((argmin.s1.y.min + -62)/32), ((max(downy$5.s0.y.min.s, 1)*2) + -3)), ((left_im.extent.1/32) + -1))
let downy$4.s0.x.max.s = max(min((downy$5.s0.x.max.s*2), ((left_im.extent.0/32) + 3)), (max(max(min((left_im.extent.0/32), ((downy$5.s0.x.max.s*2) + -1)), (min((argmin.s1.x.max.s + 93), left_im.extent.0)/32)), 1) + 3))
let downy$4.s0.x.min = min(max(((min((left_im.extent.0 + 30), argmin.s1.x.min) + -62)/32), 0), (min(max(min((downy$5.s0.x.min.s*2), ((left_im.extent.0/32) + 3)), 4), (max(min((left_im.extent.0/32), ((downy$5.s0.x.min.s*2) + -4)), 1) + 3)) + -4))
let downy$3.s0.y.max.s = min(max(((argmin.s1.y.max.s + 29)/16), ((max(downy$4.s0.y.max.s, 0)*2) + 2)), ((left_im.extent.1/16) + -1))
let downy$3.s0.y.min.s = min(((argmin.s1.y.min + -30)/16), (min((left_im.extent.1/16), (max(downy$4.s0.y.min.s, 0)*2)) + -1))
let downy$3.s0.x.max.s = max(min((downy$4.s0.x.max.s*2), ((left_im.extent.0/16) + 7)), (max(max(min((left_im.extent.0/16), ((downy$4.s0.x.max.s*2) + -5)), (min((argmin.s1.x.max.s + 45), left_im.extent.0)/16)), 1) + 7))
let downy$3.s0.x.min = min(max(((min((left_im.extent.0 + 14), argmin.s1.x.min) + -30)/16), 0), min(max(min((downy$4.s0.x.min*2), ((left_im.extent.0/16) + -1)), 0), (max(min((left_im.extent.0/16), (downy$4.s0.x.min*2)), 1) + -1)))
let downy$2.s0.y.max.s = min(max(((argmin.s1.y.max.s + 13)/8), ((max(downy$3.s0.y.max.s, 0)*2) + 2)), ((left_im.extent.1/8) + -1))
let downy$2.s0.y.min.s = min(((argmin.s1.y.min + -14)/8), (min((left_im.extent.1/8), (max(downy$3.s0.y.min.s, 0)*2)) + -1))
let downy$2.s0.x.max.s = max(min((downy$3.s0.x.max.s*2), ((left_im.extent.0/8) + 15)), (max(max(min((left_im.extent.0/8), ((downy$3.s0.x.max.s*2) + -13)), (min((argmin.s1.x.max.s + 21), left_im.extent.0)/8)), 1) + 15))
let downy$2.s0.x.min = min(max(((min((left_im.extent.0 + 6), argmin.s1.x.min) + -14)/8), 0), min(max(min((downy$3.s0.x.min*2), ((left_im.extent.0/8) + -1)), 0), (max(min((left_im.extent.0/8), (downy$3.s0.x.min*2)), 1) + -1)))
let downy$1.s0.y.max.s = min(max(((argmin.s1.y.max.s + 5)/4), ((max(downy$2.s0.y.max.s, 0)*2) + 2)), ((left_im.extent.1/4) + -1))
let downy$1.s0.y.min.s = min(((argmin.s1.y.min + -6)/4), (min((left_im.extent.1/4), (max(downy$2.s0.y.min.s, 0)*2)) + -1))
let downy$1.s0.x.max.s = max(min((downy$2.s0.x.max.s*2), ((left_im.extent.0/4) + 31)), (max(max(min((left_im.extent.0/4), ((downy$2.s0.x.max.s*2) + -29)), (min((argmin.s1.x.max.s + 9), left_im.extent.0)/4)), 1) + 31))
let downy$1.s0.x.min = min(max(((min((left_im.extent.0 + 2), argmin.s1.x.min) + -6)/4), 0), min(max(min((downy$2.s0.x.min*2), ((left_im.extent.0/4) + -1)), 0), (max(min((left_im.extent.0/4), (downy$2.s0.x.min*2)), 1) + -1)))
let downy.s0.y.max.s = min(max(((argmin.s1.y.max.s + 1)/2), ((max(downy$1.s0.y.max.s, 0)*2) + 2)), ((left_im.extent.1/2) + -1))
let downy.s0.y.min.s = min(min((argmin.s1.y.min/2), (max(downy$1.s0.y.min.s, 0)*2)), (left_im.extent.1/2))
let downy.s0.x.max.s = max(min((downy$1.s0.x.max.s*2), ((left_im.extent.0/2) + 63)), (max(max(min((left_im.extent.0/2), ((downy$1.s0.x.max.s*2) + -61)), (min((argmin.s1.x.max.s + 3), left_im.extent.0)/2)), 1) + 63))
let downy.s0.x.min = min(max(min((downy$1.s0.x.min*2), ((left_im.extent.0/2) + -1)), 0), (max(min(min((left_im.extent.0/2), (downy$1.s0.x.min*2)), (min(argmin.s1.x.min, left_im.extent.0)/2)), 1) + -1))
let cost_confidence.s0.y.max.s = max(((max(downy.s0.y.max.s, 0)*2) + 3), argmin.s1.y.max.s)
let cost_confidence.s0.y.min = min(((max(downy.s0.y.min.s, 1)*2) + -3), argmin.s1.y.min)
let cost_confidence.s0.x.max.s = max((downy.s0.x.max.s*2), (argmin.s1.x.max.s + 125))
let cost_confidence.s0.x.min = min(((downy.s0.x.min*2) + -1), argmin.s1.x.min)
let diff.s0.y.max.s = max(cost_confidence.s0.y.max.s, cost_confidence.s0.y.max.s)
let diff.s0.y.min = min(cost_confidence.s0.y.min, cost_confidence.s0.y.min)
let diff.s0.x.max.s = max(cost_confidence.s0.x.max.s, cost_confidence.s0.x.max.s)
let diff.s0.x.min = min(cost_confidence.s0.x.min, cost_confidence.s0.x.min)
let repeat_edge.s0._1.max.s = max(max((final.extent.1 + final.min.1), diff.s0.y.max.s), (max((0 - maximum$1.s1.r$2$x.max), maximum$1.s1.r$2$x.max) + (final.extent.1 + final.min.1)))
let repeat_edge.s0._1.min = min(min(diff.s0.y.min, final.min.1), (final.min.1 - maximum$1.s1.r$2$x.max))
let repeat_edge.s0._0.max.s = max(((max(max((0 - maximum$1.s1.r$2$x.max), maximum$1.s1.r$2$x.max), 0) + (final.extent.0 + final.min.0)) + 125), diff.s0.x.max.s)
let repeat_edge.s0._0.min = min(min(diff.s0.x.min, final.min.0), (final.min.0 - maximum$1.s1.r$2$x.max))
let final.extent.0.required.s = (min((((final.extent.0 + -1)/10)*10), (final.extent.0 + -10)) - min(final.extent.0, 10))
let final.extent.1.required.s = (min((((final.extent.1 + -1)/8)*8), (final.extent.1 + -8)) - min(final.extent.1, 8))
let final.stride.2.required = ((final.extent.0.required.s + 20)*(final.extent.1.required.s + 16))
let left_im.extent.0.required.s = (max((min(min(((((((repeat_edge.s0._0.max.s - repeat_edge.s0._0.min) + -126)/32)*32) + repeat_edge.s0._0.min) + 157), repeat_edge.s0._0.max.s), ((left_im.extent.0 + left_im.min.0) + 125)) + -126), left_im.min.0) - max(min(min((repeat_edge.s0._0.max.s + -157), repeat_edge.s0._0.min), ((left_im.extent.0 + left_im.min.0) + -1)), left_im.min.0))
let left_im.min.0.required = max(min(min((repeat_edge.s0._0.max.s + -157), repeat_edge.s0._0.min), ((left_im.extent.0 + left_im.min.0) + -1)), left_im.min.0)
let left_im.extent.1.required = (max(min(min(((((((repeat_edge.s0._1.max.s - repeat_edge.s0._1.min) + -1)/8)*8) + repeat_edge.s0._1.min) + 8), repeat_edge.s0._1.max.s), (left_im.extent.1 + left_im.min.1)), (left_im.min.1 + 1)) - max(min(min((repeat_edge.s0._1.max.s + -8), repeat_edge.s0._1.min), ((left_im.extent.1 + left_im.min.1) + -1)), left_im.min.1))
let left_im.min.1.required = max(min(min((repeat_edge.s0._1.max.s + -8), repeat_edge.s0._1.min), ((left_im.extent.1 + left_im.min.1) + -1)), left_im.min.1)
let left_im.extent.2.required = (max(min((left_im.extent.2 + left_im.min.2), 3), (left_im.min.2 + 1)) - max((min((left_im.extent.2 + left_im.min.2), 1) + -1), left_im.min.2))
let left_im.min.2.required = max((min((left_im.extent.2 + left_im.min.2), 1) + -1), left_im.min.2)
let right_im.extent.0.required.s = (max((min(min(((((((((slices*2) + diff.s0.x.max.s) - diff.s0.x.min) + -127)/32)*32) + diff.s0.x.min) + 158), ((slices*2) + diff.s0.x.max.s)), ((right_im.extent.0 + right_im.min.0) + 126)) + -127), right_im.min.0) - max(min(min((((slices*2) + diff.s0.x.max.s) + -158), diff.s0.x.min), ((right_im.extent.0 + right_im.min.0) + -1)), right_im.min.0))
let right_im.min.0.required = max(min(min((((slices*2) + diff.s0.x.max.s) + -158), diff.s0.x.min), ((right_im.extent.0 + right_im.min.0) + -1)), right_im.min.0)
let right_im.extent.1.required = (max(min(min(((((((diff.s0.y.max.s - diff.s0.y.min) + -1)/8)*8) + diff.s0.y.min) + 8), diff.s0.y.max.s), (right_im.extent.1 + right_im.min.1)), (right_im.min.1 + 1)) - max(min(min((diff.s0.y.max.s + -8), diff.s0.y.min), ((right_im.extent.1 + right_im.min.1) + -1)), right_im.min.1))
let right_im.min.1.required = max(min(min((diff.s0.y.max.s + -8), diff.s0.y.min), ((right_im.extent.1 + right_im.min.1) + -1)), right_im.min.1)
let right_im.extent.2.required = (max(min((right_im.extent.2 + right_im.min.2), 3), (right_im.min.2 + 1)) - max((min((right_im.extent.2 + right_im.min.2), 1) + -1), right_im.min.2))
let right_im.min.2.required = max((min((right_im.extent.2 + right_im.min.2), 1) + -1), right_im.min.2)
if (_halide_buffer_is_bounds_query(final.buffer)) {
  _halide_buffer_init(final.buffer, _halide_buffer_get_shape(final.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 3, make_struct((halide_dimension_t *), ((min(final.extent.0, 10) + final.min.0) + -10), (final.extent.0.required.s + 20), 1, 0, ((min(final.extent.1, 8) + final.min.1) + -8), (final.extent.1.required.s + 16), (final.extent.0.required.s + 20), 0, 0, 3, final.stride.2.required, 0), (uint64)0)
}
if (_halide_buffer_is_bounds_query(left_im.buffer)) {
  _halide_buffer_init(left_im.buffer, _halide_buffer_get_shape(left_im.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 1, 8, 3, make_struct((halide_dimension_t *), left_im.min.0.required, (left_im.extent.0.required.s + 1), 1, 0, left_im.min.1.required, left_im.extent.1.required, (left_im.extent.0.required.s + 1), 0, left_im.min.2.required, left_im.extent.2.required, ((left_im.extent.0.required.s + 1)*left_im.extent.1.required), 0), (uint64)0)
}
if (_halide_buffer_is_bounds_query(right_im.buffer)) {
  _halide_buffer_init(right_im.buffer, _halide_buffer_get_shape(right_im.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 1, 8, 3, make_struct((halide_dimension_t *), right_im.min.0.required, (right_im.extent.0.required.s + 1), 1, 0, right_im.min.1.required, right_im.extent.1.required, (right_im.extent.0.required.s + 1), 0, right_im.min.2.required, right_im.extent.2.required, ((right_im.extent.0.required.s + 1)*right_im.extent.1.required), 0), (uint64)0)
}
if (!(_halide_buffer_is_bounds_query(right_im.buffer) || (_halide_buffer_is_bounds_query(final.buffer) || _halide_buffer_is_bounds_query(left_im.buffer)))) {
  assert((final.type == (uint32)73730), halide_error_bad_type("Output buffer final", final.type, (uint32)73730))
  assert((final.dimensions == 3), halide_error_bad_dimensions("Output buffer final", final.dimensions, 3))
  assert((left_im.type == (uint32)67585), halide_error_bad_type("Input buffer left_im", left_im.type, (uint32)67585))
  assert((left_im.dimensions == 3), halide_error_bad_dimensions("Input buffer left_im", left_im.dimensions, 3))
  assert((right_im.type == (uint32)67585), halide_error_bad_type("Input buffer right_im", right_im.type, (uint32)67585))
  assert((right_im.dimensions == 3), halide_error_bad_dimensions("Input buffer right_im", right_im.dimensions, 3))
  assert(((10 <= final.extent.0) && ((((min(final.extent.0, 10) + final.min.0) + final.extent.0.required.s) + 10) <= (final.extent.0 + final.min.0))), halide_error_access_out_of_bounds("Output buffer final", 0, ((min(final.extent.0, 10) + final.min.0) + -10), (((min(final.extent.0, 10) + final.min.0) + final.extent.0.required.s) + 9), final.min.0, ((final.extent.0 + final.min.0) + -1)))
  assert(((8 <= final.extent.1) && ((((min(final.extent.1, 8) + final.min.1) + final.extent.1.required.s) + 8) <= (final.extent.1 + final.min.1))), halide_error_access_out_of_bounds("Output buffer final", 1, ((min(final.extent.1, 8) + final.min.1) + -8), (((min(final.extent.1, 8) + final.min.1) + final.extent.1.required.s) + 7), final.min.1, ((final.extent.1 + final.min.1) + -1)))
  assert(((final.min.2 <= 0) && (3 <= (final.extent.2 + final.min.2))), halide_error_access_out_of_bounds("Output buffer final", 2, 0, 2, final.min.2, ((final.extent.2 + final.min.2) + -1)))
  assert((0 <= final.extent.2), halide_error_buffer_extents_negative("Output buffer final", 2, final.extent.2))
  assert(((left_im.min.0 <= left_im.min.0.required) && (((left_im.extent.0.required.s + left_im.min.0.required) + 1) <= (left_im.extent.0 + left_im.min.0))), halide_error_access_out_of_bounds("Input buffer left_im", 0, left_im.min.0.required, (left_im.extent.0.required.s + left_im.min.0.required), left_im.min.0, ((left_im.extent.0 + left_im.min.0) + -1)))
  assert((0 <= left_im.extent.0), halide_error_buffer_extents_negative("Input buffer left_im", 0, left_im.extent.0))
  assert(((left_im.min.1 <= left_im.min.1.required) && ((left_im.extent.1.required + left_im.min.1.required) <= (left_im.extent.1 + left_im.min.1))), halide_error_access_out_of_bounds("Input buffer left_im", 1, left_im.min.1.required, ((left_im.extent.1.required + left_im.min.1.required) + -1), left_im.min.1, ((left_im.extent.1 + left_im.min.1) + -1)))
  assert((0 <= left_im.extent.1), halide_error_buffer_extents_negative("Input buffer left_im", 1, left_im.extent.1))
  assert(((left_im.min.2 <= left_im.min.2.required) && ((left_im.extent.2.required + left_im.min.2.required) <= (left_im.extent.2 + left_im.min.2))), halide_error_access_out_of_bounds("Input buffer left_im", 2, left_im.min.2.required, ((left_im.extent.2.required + left_im.min.2.required) + -1), left_im.min.2, ((left_im.extent.2 + left_im.min.2) + -1)))
  assert((0 <= left_im.extent.2), halide_error_buffer_extents_negative("Input buffer left_im", 2, left_im.extent.2))
  assert(((right_im.min.0 <= right_im.min.0.required) && (((right_im.extent.0.required.s + right_im.min.0.required) + 1) <= (right_im.extent.0 + right_im.min.0))), halide_error_access_out_of_bounds("Input buffer right_im", 0, right_im.min.0.required, (right_im.extent.0.required.s + right_im.min.0.required), right_im.min.0, ((right_im.extent.0 + right_im.min.0) + -1)))
  assert((0 <= right_im.extent.0), halide_error_buffer_extents_negative("Input buffer right_im", 0, right_im.extent.0))
  assert(((right_im.min.1 <= right_im.min.1.required) && ((right_im.extent.1.required + right_im.min.1.required) <= (right_im.extent.1 + right_im.min.1))), halide_error_access_out_of_bounds("Input buffer right_im", 1, right_im.min.1.required, ((right_im.extent.1.required + right_im.min.1.required) + -1), right_im.min.1, ((right_im.extent.1 + right_im.min.1) + -1)))
  assert((0 <= right_im.extent.1), halide_error_buffer_extents_negative("Input buffer right_im", 1, right_im.extent.1))
  assert(((right_im.min.2 <= right_im.min.2.required) && ((right_im.extent.2.required + right_im.min.2.required) <= (right_im.extent.2 + right_im.min.2))), halide_error_access_out_of_bounds("Input buffer right_im", 2, right_im.min.2.required, ((right_im.extent.2.required + right_im.min.2.required) + -1), right_im.min.2, ((right_im.extent.2 + right_im.min.2) + -1)))
  assert((0 <= right_im.extent.2), halide_error_buffer_extents_negative("Input buffer right_im", 2, right_im.extent.2))
  assert((final.stride.0 == 1), halide_error_constraint_violated("final.stride.0", final.stride.0, "1", 1))
  assert((left_im.stride.0 == 1), halide_error_constraint_violated("left_im.stride.0", left_im.stride.0, "1", 1))
  assert((right_im.stride.0 == 1), halide_error_constraint_violated("right_im.stride.0", right_im.stride.0, "1", 1))
  assert((abs(int64(final.extent.0)) <= (uint64)9223372036854775807), halide_error_buffer_allocation_too_large("final", abs(int64(final.extent.0)), (uint64)9223372036854775807))
  assert((abs((int64(final.extent.1)*int64(final.stride.1))) <= (uint64)9223372036854775807), halide_error_buffer_allocation_too_large("final", abs((int64(final.extent.1)*int64(final.stride.1))), (uint64)9223372036854775807))
  assert((abs((int64(final.extent.2)*int64(final.stride.2))) <= (uint64)9223372036854775807), halide_error_buffer_allocation_too_large("final", abs((int64(final.extent.2)*int64(final.stride.2))), (uint64)9223372036854775807))
  assert((abs(int64(left_im.extent.0)) <= (uint64)9223372036854775807), halide_error_buffer_allocation_too_large("left_im", abs(int64(left_im.extent.0)), (uint64)9223372036854775807))
  assert((abs((int64(left_im.extent.1)*int64(left_im.stride.1))) <= (uint64)9223372036854775807), halide_error_buffer_allocation_too_large("left_im", abs((int64(left_im.extent.1)*int64(left_im.stride.1))), (uint64)9223372036854775807))
  assert((abs((int64(left_im.extent.2)*int64(left_im.stride.2))) <= (uint64)9223372036854775807), halide_error_buffer_allocation_too_large("left_im", abs((int64(left_im.extent.2)*int64(left_im.stride.2))), (uint64)9223372036854775807))
  assert((abs(int64(right_im.extent.0)) <= (uint64)9223372036854775807), halide_error_buffer_allocation_too_large("right_im", abs(int64(right_im.extent.0)), (uint64)9223372036854775807))
  assert((abs((int64(right_im.extent.1)*int64(right_im.stride.1))) <= (uint64)9223372036854775807), halide_error_buffer_allocation_too_large("right_im", abs((int64(right_im.extent.1)*int64(right_im.stride.1))), (uint64)9223372036854775807))
  assert((abs((int64(right_im.extent.2)*int64(right_im.stride.2))) <= (uint64)9223372036854775807), halide_error_buffer_allocation_too_large("right_im", abs((int64(right_im.extent.2)*int64(right_im.stride.2))), (uint64)9223372036854775807))
  assert((slices <= 64), halide_error_param_too_large_i64("slices", int64(slices), (int64)64))
  assert((1 <= slices), halide_error_param_too_small_i64("slices", int64(slices), (int64)1))
  assert((focus_depth <= 32), halide_error_param_too_large_i64("focus_depth", int64(focus_depth), (int64)32))
  assert((1 <= focus_depth), halide_error_param_too_small_i64("focus_depth", int64(focus_depth), (int64)1))
  assert((blur_radius_scale <= 1.000000f), halide_error_param_too_large_f64("blur_radius_scale", float64(max(blur_radius_scale, 0.000000f)), 1.000000))
  assert((0.000000f <= blur_radius_scale), halide_error_param_too_small_f64("blur_radius_scale", float64(blur_radius_scale), 0.000000))
  let repeat_edge._1.min_realized = min((let t104001 = (final.min.1 - int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(max((slices - focus_depth), focus_depth))))) in min(min(min(min((min((final.extent.1 + final.min.1), diff.s0.y.max.s) + -8), final.min.1), diff.s0.y.min), ((final.extent.1 + final.min.1) + -8)), t104001)), min((repeat_edge.s0._1.max.s + -8), repeat_edge.s0._1.min))
  let repeat_edge._1.extent_realized.s = (max((let t104000.s = (max((0 - int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(max((slices - focus_depth), focus_depth))))), int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(max((slices - focus_depth), focus_depth))))) + (final.extent.1 + final.min.1)) in (max(max(min(((((((diff.s0.y.max.s - diff.s0.y.min) + -1)/8)*8) + diff.s0.y.min) + 8), diff.s0.y.max.s), (final.extent.1 + final.min.1)), t104000.s) + -1)), (min(((((((repeat_edge.s0._1.max.s - repeat_edge.s0._1.min) + -1)/8)*8) + repeat_edge.s0._1.min) + 8), repeat_edge.s0._1.max.s) + -1)) - repeat_edge._1.min_realized)
  let repeat_edge._0.min_realized = min((let t104003 = (final.min.0 - int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(max((slices - focus_depth), focus_depth))))) in min(min(min((diff.s0.x.max.s + -157), final.min.0), diff.s0.x.min), t104003)), min((repeat_edge.s0._0.max.s + -157), repeat_edge.s0._0.min))
  let repeat_edge._0.extent_realized.s = (max((let t104002.s = (max((0 - int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(max((slices - focus_depth), focus_depth))))), int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(max((slices - focus_depth), focus_depth))))) + (final.extent.0 + final.min.0)) in (max(min(((((((diff.s0.x.max.s - diff.s0.x.min) + -126)/32)*32) + diff.s0.x.min) + 157), diff.s0.x.max.s), (max((final.extent.0 + final.min.0), t104002.s) + 125)) + -126)), (min(((((((repeat_edge.s0._0.max.s - repeat_edge.s0._0.min) + -126)/32)*32) + repeat_edge.s0._0.min) + 157), repeat_edge.s0._0.max.s) + -126)) - repeat_edge._0.min_realized)
  let repeat_edge.stride.2 = ((repeat_edge._0.extent_realized.s + 1)*(repeat_edge._1.extent_realized.s + 1))
  allocate repeat_edge[uint8 * (repeat_edge._0.extent_realized.s + 1) * (repeat_edge._1.extent_realized.s + 1) * 3] if (uint1)0
  let repeat_edge.buffer = (let t104143 = make_struct((halide_dimension_t *), repeat_edge._0.min_realized, (repeat_edge._0.extent_realized.s + 1), 1, 0, repeat_edge._1.min_realized, (repeat_edge._1.extent_realized.s + 1), (repeat_edge._0.extent_realized.s + 1), 0, 0, 3, repeat_edge.stride.2, 0) in _halide_buffer_init(alloca(size_of_halide_buffer_t()), t104143, reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 1, 8, 3, t104143, (uint64)0))
  register_destructor("halide_device_free_as_destructor", repeat_edge.buffer)
  produce repeat_edge {
    let halide_device_malloc_result$15 = halide_device_malloc(repeat_edge.buffer, halide_cuda_device_interface())
    assert((halide_device_malloc_result$15 == 0), halide_device_malloc_result$15)
    let halide_copy_to_device_result$1 = halide_copy_to_device(left_im.buffer, halide_cuda_device_interface())
    assert((halide_copy_to_device_result$1 == 0), halide_copy_to_device_result$1)
    gpu_block<CUDA> (repeat_edge.s0._1._1_o.__block_id_y, 0, (((repeat_edge.s0._1.max.s - repeat_edge.s0._1.min) + 7)/8)) {
      let repeat_edge.s0._1._1_i.base = min(likely_if_innermost(((repeat_edge.s0._1._1_o.__block_id_y*8) + repeat_edge.s0._1.min)), (repeat_edge.s0._1.max.s + -8))
      gpu_block<CUDA> (repeat_edge.s0._0._0_o.__block_id_x, 0, (((repeat_edge.s0._0.max.s - repeat_edge.s0._0.min) + -94)/32)) {
        let repeat_edge.s0._0._0_i.base = min(likely_if_innermost(((repeat_edge.s0._0._0_o.__block_id_x*32) + repeat_edge.s0._0.min)), (repeat_edge.s0._0.max.s + -157))
        gpu_thread<CUDA> (repeat_edge.s0._1._1_i.__thread_id_y, 0, 8) {
          gpu_thread<CUDA> (repeat_edge.s0._0._0_i.__thread_id_x, 0, 32) {
            for (repeat_edge.s0._2, 0, 3) {
              repeat_edge[((int64(repeat_edge.s0._2)*int64(repeat_edge.stride.2)) + ((int64(((repeat_edge.s0._1._1_i.__thread_id_y + repeat_edge.s0._1._1_i.base) - repeat_edge._1.min_realized))*int64((repeat_edge._0.extent_realized.s + 1))) + int64(((repeat_edge.s0._0._0_i.__thread_id_x + repeat_edge.s0._0._0_i.base) - repeat_edge._0.min_realized))))] = (let repeat_edge.s0.lambda_0._2 = max(min(likely(repeat_edge.s0._2), ((left_im.extent.2 + left_im.min.2) + -1)), left_im.min.2) in (let repeat_edge.s0.lambda_0._1 = max(min(likely((repeat_edge.s0._1._1_i.__thread_id_y + repeat_edge.s0._1._1_i.base)), ((left_im.extent.1 + left_im.min.1) + -1)), left_im.min.1) in (let repeat_edge.s0.lambda_0._0 = max(min(likely((repeat_edge.s0._0._0_i.__thread_id_x + repeat_edge.s0._0._0_i.base)), ((left_im.extent.0 + left_im.min.0) + -1)), left_im.min.0) in left_im[(((int64(repeat_edge.s0.lambda_0._2)*int64(left_im.stride.2)) + ((int64(repeat_edge.s0.lambda_0._1)*int64(left_im.stride.1)) + int64(repeat_edge.s0.lambda_0._0))) - ((int64(left_im.min.2)*int64(left_im.stride.2)) + ((int64(left_im.min.1)*int64(left_im.stride.1)) + int64(left_im.min.0))))])))
            }
          }
        }
      }
    }
    _halide_buffer_set_device_dirty(repeat_edge.buffer, (uint1)1)
  }
  let repeat_edge$1._1.min_realized = min((diff.s0.y.max.s + -8), diff.s0.y.min)
  let repeat_edge$1._1.extent_realized = (min(((((((diff.s0.y.max.s - diff.s0.y.min) + -1)/8)*8) + diff.s0.y.min) + 8), diff.s0.y.max.s) - repeat_edge$1._1.min_realized)
  let repeat_edge$1._0.min_realized = min(min((((slices*2) + diff.s0.x.max.s) + -158), diff.s0.x.min), ((min((diff.s0.x.max.s + -157), diff.s0.x.min) + (min(slices, 4)*2)) + -8))
  let repeat_edge$1._0.extent_realized.s = (max(min(((((((((slices*2) + diff.s0.x.max.s) - diff.s0.x.min) + -127)/32)*32) + diff.s0.x.min) + 158), ((slices*2) + diff.s0.x.max.s)), (min(((((((diff.s0.x.max.s - diff.s0.x.min) + -126)/32)*32) + diff.s0.x.min) + 157), diff.s0.x.max.s) + (slices*2))) - repeat_edge$1._0.min_realized)
  allocate repeat_edge$1[uint8 * (repeat_edge$1._0.extent_realized.s + -126) * repeat_edge$1._1.extent_realized * 3] if (uint1)0
  let repeat_edge$1.buffer = (let t104142 = make_struct((halide_dimension_t *), repeat_edge$1._0.min_realized, (repeat_edge$1._0.extent_realized.s + -126), 1, 0, repeat_edge$1._1.min_realized, repeat_edge$1._1.extent_realized, (repeat_edge$1._0.extent_realized.s + -126), 0, 0, 3, ((repeat_edge$1._0.extent_realized.s + -126)*repeat_edge$1._1.extent_realized), 0) in _halide_buffer_init(alloca(size_of_halide_buffer_t()), t104142, reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 1, 8, 3, t104142, (uint64)0))
  register_destructor("halide_device_free_as_destructor", repeat_edge$1.buffer)
  produce repeat_edge$1 {
    let halide_device_malloc_result$14 = halide_device_malloc(repeat_edge$1.buffer, halide_cuda_device_interface())
    assert((halide_device_malloc_result$14 == 0), halide_device_malloc_result$14)
    let halide_copy_to_device_result$2 = halide_copy_to_device(right_im.buffer, halide_cuda_device_interface())
    assert((halide_copy_to_device_result$2 == 0), halide_copy_to_device_result$2)
    gpu_block<CUDA> (repeat_edge$1.s0._1._1_o.__block_id_y, 0, (((diff.s0.y.max.s - diff.s0.y.min) + 7)/8)) {
      let repeat_edge$1.s0._1._1_i.base = min(likely_if_innermost(((repeat_edge$1.s0._1._1_o.__block_id_y*8) + diff.s0.y.min)), (diff.s0.y.max.s + -8))
      gpu_block<CUDA> (repeat_edge$1.s0._0._0_o.__block_id_x, 0, (((((slices*2) + diff.s0.x.max.s) - diff.s0.x.min) + -95)/32)) {
        let repeat_edge$1.s0._0._0_i.base = min(likely_if_innermost(((repeat_edge$1.s0._0._0_o.__block_id_x*32) + diff.s0.x.min)), (((slices*2) + diff.s0.x.max.s) + -158))
        gpu_thread<CUDA> (repeat_edge$1.s0._1._1_i.__thread_id_y, 0, 8) {
          gpu_thread<CUDA> (repeat_edge$1.s0._0._0_i.__thread_id_x, 0, 32) {
            for (repeat_edge$1.s0._2, 0, 3) {
              repeat_edge$1[((int64(repeat_edge$1.s0._2)*int64(((repeat_edge$1._0.extent_realized.s + -126)*repeat_edge$1._1.extent_realized))) + ((int64(((repeat_edge$1.s0._1._1_i.__thread_id_y + repeat_edge$1.s0._1._1_i.base) - repeat_edge$1._1.min_realized))*int64((repeat_edge$1._0.extent_realized.s + -126))) + int64(((repeat_edge$1.s0._0._0_i.__thread_id_x + repeat_edge$1.s0._0._0_i.base) - repeat_edge$1._0.min_realized))))] = (let repeat_edge$1.s0.lambda_1._2 = max(min(likely(repeat_edge$1.s0._2), ((right_im.extent.2 + right_im.min.2) + -1)), right_im.min.2) in (let repeat_edge$1.s0.lambda_1._1 = max(min(likely((repeat_edge$1.s0._1._1_i.__thread_id_y + repeat_edge$1.s0._1._1_i.base)), ((right_im.extent.1 + right_im.min.1) + -1)), right_im.min.1) in (let repeat_edge$1.s0.lambda_1._0 = max(min(likely((repeat_edge$1.s0._0._0_i.__thread_id_x + repeat_edge$1.s0._0._0_i.base)), ((right_im.extent.0 + right_im.min.0) + -1)), right_im.min.0) in right_im[(((int64(repeat_edge$1.s0.lambda_1._2)*int64(right_im.stride.2)) + ((int64(repeat_edge$1.s0.lambda_1._1)*int64(right_im.stride.1)) + int64(repeat_edge$1.s0.lambda_1._0))) - ((int64(right_im.min.2)*int64(right_im.stride.2)) + ((int64(right_im.min.1)*int64(right_im.stride.1)) + int64(right_im.min.0))))])))
            }
          }
        }
      }
    }
    _halide_buffer_set_device_dirty(repeat_edge$1.buffer, (uint1)1)
  }
  let diff.z.min_realized.s = min((min(slices, 2) + 2), slices)
  let diff.y.min_realized = min(min(min(min(min(min((cost_confidence.s0.y.max.s + -8), cost_confidence.s0.y.min), ((min(max(downy.s0.y.max.s, 0), (max(downy.s0.y.min.s, 1) + 12))*2) + -27)), (argmin.s1.y.max.s + -16)), argmin.s1.y.min), (diff.s0.y.max.s + -8)), diff.s0.y.min)
  let diff.y.extent_realized = (max(max(max(min(((((((cost_confidence.s0.y.max.s - cost_confidence.s0.y.min) + -1)/8)*8) + cost_confidence.s0.y.min) + 8), cost_confidence.s0.y.max.s), ((min(max(downy.s0.y.max.s, 0), ((max(downy.s0.y.min.s, 1) + ((((max(downy.s0.y.max.s, 0) - max(downy.s0.y.min.s, 1)) + 1)/14)*14)) + 12))*2) + 3)), min(((((((argmin.s1.y.max.s - argmin.s1.y.min) + -1)/16)*16) + argmin.s1.y.min) + 16), argmin.s1.y.max.s)), min(((((((diff.s0.y.max.s - diff.s0.y.min) + -1)/8)*8) + diff.s0.y.min) + 8), diff.s0.y.max.s)) - diff.y.min_realized)
  let diff.x.min_realized = min(min(min(min(min(min(min(min((cost_confidence.s0.x.max.s + -157), cost_confidence.s0.x.min), ((min((downy.s0.x.max.s + -79), downy.s0.x.min)*2) + -1)), (min((downy.s0.x.max.s + -79), downy.s0.x.min)*2)), ((min((downy.s0.x.max.s + -79), downy.s0.x.min)*2) + 1)), (argmin.s1.x.max.s + -16)), argmin.s1.x.min), (diff.s0.x.max.s + -157)), diff.s0.x.min)
  let diff.x.extent_realized.s = (max(max(max((min((((((downy.s0.x.max.s - downy.s0.x.min)/16)*16) + downy.s0.x.min) + 15), downy.s0.x.max.s)*2), (max(min(((((((cost_confidence.s0.x.max.s - cost_confidence.s0.x.min) + -126)/32)*32) + cost_confidence.s0.x.min) + 157), cost_confidence.s0.x.max.s), (min((((((downy.s0.x.max.s - downy.s0.x.min)/16)*16) + downy.s0.x.min) + 15), downy.s0.x.max.s)*2)) + 3)), (min(((((((argmin.s1.x.max.s - argmin.s1.x.min) + -1)/16)*16) + argmin.s1.x.min) + 16), argmin.s1.x.max.s) + 128)), (min(((((((diff.s0.x.max.s - diff.s0.x.min) + -126)/32)*32) + diff.s0.x.min) + 157), diff.s0.x.max.s) + 3)) - diff.x.min_realized)
  let diff.stride.3 = (max(slices, 4)*((diff.x.extent_realized.s + -128)*diff.y.extent_realized))
  allocate diff[uint8 * (diff.x.extent_realized.s + -128) * diff.y.extent_realized * max(slices, 4) * 3] if (uint1)0
  let diff.buffer = (let t104141 = make_struct((halide_dimension_t *), diff.x.min_realized, (diff.x.extent_realized.s + -128), 1, 0, diff.y.min_realized, diff.y.extent_realized, (diff.x.extent_realized.s + -128), 0, (diff.z.min_realized.s + -4), max(slices, 4), ((diff.x.extent_realized.s + -128)*diff.y.extent_realized), 0, 0, 3, diff.stride.3, 0) in _halide_buffer_init(alloca(size_of_halide_buffer_t()), t104141, reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 1, 8, 4, t104141, (uint64)0))
  register_destructor("halide_device_free_as_destructor", diff.buffer)
  produce diff {
    consume repeat_edge$1 {
      consume repeat_edge {
        let halide_device_malloc_result$13 = halide_device_malloc(diff.buffer, halide_cuda_device_interface())
        assert((halide_device_malloc_result$13 == 0), halide_device_malloc_result$13)
        gpu_block<CUDA> (diff.s0.z.z_o.__block_id_z, 0, ((slices + 3)/4)) {
          let diff.s0.z.z_i.base = min(likely_if_innermost((diff.s0.z.z_o.__block_id_z*4)), (slices + -4))
          gpu_block<CUDA> (diff.s0.y.y_o.__block_id_y, 0, (((diff.s0.y.max.s - diff.s0.y.min) + 7)/8)) {
            let diff.s0.y.y_i.base = min(likely_if_innermost(((diff.s0.y.y_o.__block_id_y*8) + diff.s0.y.min)), (diff.s0.y.max.s + -8))
            gpu_block<CUDA> (diff.s0.x.x_o.__block_id_x, 0, (((diff.s0.x.max.s - diff.s0.x.min) + -94)/32)) {
              let diff.s0.x.x_i.base = min(likely_if_innermost(((diff.s0.x.x_o.__block_id_x*32) + diff.s0.x.min)), (diff.s0.x.max.s + -157))
              gpu_thread<CUDA> (diff.s0.z.z_i.__thread_id_z, 0, 4) {
                gpu_thread<CUDA> (diff.s0.y.y_i.__thread_id_y, 0, 8) {
                  gpu_thread<CUDA> (diff.s0.x.x_i.__thread_id_x, 0, 32) {
                    for (diff.s0.c, 0, 3) {
                      diff[((int64(diff.s0.c)*int64(diff.stride.3)) + ((int64((((diff.s0.z.z_i.__thread_id_z + diff.s0.z.z_i.base) - diff.z.min_realized.s) + 4))*int64(((diff.x.extent_realized.s + -128)*diff.y.extent_realized))) + ((int64(((diff.s0.y.y_i.__thread_id_y + diff.s0.y.y_i.base) - diff.y.min_realized))*int64((diff.x.extent_realized.s + -128))) + int64(((diff.s0.x.x_i.__thread_id_x + diff.s0.x.x_i.base) - diff.x.min_realized)))))] = (let diff.s0.t0 = repeat_edge[((int64(diff.s0.c)*int64(repeat_edge.stride.2)) + ((int64(((diff.s0.y.y_i.__thread_id_y + diff.s0.y.y_i.base) - repeat_edge._1.min_realized))*int64((repeat_edge._0.extent_realized.s + 1))) + int64(((diff.s0.x.x_i.__thread_id_x + diff.s0.x.x_i.base) - repeat_edge._0.min_realized))))] in (let diff.s0.t1 = (((diff.s0.z.z_i.__thread_id_z + diff.s0.z.z_i.base)*2) + (diff.s0.x.x_i.__thread_id_x + diff.s0.x.x_i.base)) in min(absd(diff.s0.t0, repeat_edge$1[((int64(diff.s0.c)*int64(((repeat_edge$1._0.extent_realized.s + -126)*repeat_edge$1._1.extent_realized))) + ((int64(((diff.s0.y.y_i.__thread_id_y + diff.s0.y.y_i.base) - repeat_edge$1._1.min_realized))*int64((repeat_edge$1._0.extent_realized.s + -126))) + int64((diff.s0.t1 - repeat_edge$1._0.min_realized))))]), absd(diff.s0.t0, repeat_edge$1[(((int64(diff.s0.c)*int64(((repeat_edge$1._0.extent_realized.s + -126)*repeat_edge$1._1.extent_realized))) + ((int64(((diff.s0.y.y_i.__thread_id_y + diff.s0.y.y_i.base) - repeat_edge$1._1.min_realized))*int64((repeat_edge$1._0.extent_realized.s + -126))) + int64((diff.s0.t1 - repeat_edge$1._0.min_realized)))) + (int64)1)]))))
                    }
                  }
                }
              }
            }
          }
        }
        let halide_device_free_result$14 = halide_device_free(repeat_edge$1.buffer)
        assert((halide_device_free_result$14 == 0), halide_device_free_result$14)
        _halide_buffer_set_device_dirty(diff.buffer, (uint1)1)
      }
    }
  }
  let cost_confidence.y.min_realized = min(min(min(min((argmin.s1.y.max.s + -16), argmin.s1.y.min), ((min(max(downy.s0.y.max.s, 0), (max(downy.s0.y.min.s, 1) + 12))*2) + -27)), (cost_confidence.s0.y.max.s + -8)), cost_confidence.s0.y.min)
  let cost_confidence.y.extent_realized = (max(max(min(((((((argmin.s1.y.max.s - argmin.s1.y.min) + -1)/16)*16) + argmin.s1.y.min) + 16), argmin.s1.y.max.s), ((min(max(downy.s0.y.max.s, 0), ((max(downy.s0.y.min.s, 1) + ((((max(downy.s0.y.max.s, 0) - max(downy.s0.y.min.s, 1)) + 1)/14)*14)) + 12))*2) + 3)), min(((((((cost_confidence.s0.y.max.s - cost_confidence.s0.y.min) + -1)/8)*8) + cost_confidence.s0.y.min) + 8), cost_confidence.s0.y.max.s)) - cost_confidence.y.min_realized)
  let cost_confidence.x.min_realized = min(min(min(min((argmin.s1.x.max.s + -16), argmin.s1.x.min), ((min((downy.s0.x.max.s + -79), downy.s0.x.min)*2) + -1)), (cost_confidence.s0.x.max.s + -157)), cost_confidence.s0.x.min)
  let cost_confidence.x.extent_realized.s = (max(max((min((((((downy.s0.x.max.s - downy.s0.x.min)/16)*16) + downy.s0.x.min) + 15), downy.s0.x.max.s)*2), (min(((((((argmin.s1.x.max.s - argmin.s1.x.min) + -1)/16)*16) + argmin.s1.x.min) + 16), argmin.s1.x.max.s) + 125)), min(((((((cost_confidence.s0.x.max.s - cost_confidence.s0.x.min) + -126)/32)*32) + cost_confidence.s0.x.min) + 157), cost_confidence.s0.x.max.s)) - cost_confidence.x.min_realized)
  allocate cost_confidence[float32 * (cost_confidence.x.extent_realized.s + -125) * cost_confidence.y.extent_realized] if (uint1)0
  let cost_confidence.buffer = (let t104140 = make_struct((halide_dimension_t *), cost_confidence.x.min_realized, (cost_confidence.x.extent_realized.s + -125), 1, 0, cost_confidence.y.min_realized, cost_confidence.y.extent_realized, (cost_confidence.x.extent_realized.s + -125), 0) in _halide_buffer_init(alloca(size_of_halide_buffer_t()), t104140, reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 2, t104140, (uint64)0))
  register_destructor("halide_device_free_as_destructor", cost_confidence.buffer)
  produce cost_confidence {
    consume diff {
      let halide_device_malloc_result$12 = halide_device_malloc(cost_confidence.buffer, halide_cuda_device_interface())
      assert((halide_device_malloc_result$12 == 0), halide_device_malloc_result$12)
      gpu_block<CUDA> (cost_confidence.s0.y.y_o.__block_id_y, 0, (((cost_confidence.s0.y.max.s - cost_confidence.s0.y.min) + 7)/8)) {
        let cost_confidence.s0.y.y_i.base = min(likely_if_innermost(((cost_confidence.s0.y.y_o.__block_id_y*8) + cost_confidence.s0.y.min)), (cost_confidence.s0.y.max.s + -8))
        gpu_block<CUDA> (cost_confidence.s0.x.x_o.__block_id_x, 0, (((cost_confidence.s0.x.max.s - cost_confidence.s0.x.min) + -94)/32)) {
          let cost_confidence.s0.x.x_i.base = min(likely_if_innermost(((cost_confidence.s0.x.x_o.__block_id_x*32) + cost_confidence.s0.x.min)), (cost_confidence.s0.x.max.s + -157))
          allocate sum[float32 * 32 * 8]
          produce sum {
            gpu_thread<CUDA> (sum.s0.y.__thread_id_y, 0, 8) {
              gpu_thread<CUDA> (sum.s0.x.__thread_id_x, 0, 32) {
                sum[((int64(sum.s0.y.__thread_id_y)*(int64)32) + int64(sum.s0.x.__thread_id_x))] = 0.000000f
              }
            }
            gpu_thread<CUDA> (sum.s1.y.__thread_id_y, 0, 8) {
              gpu_thread<CUDA> (sum.s1.x.__thread_id_x, 0, 32) {
                for (sum.s1.r$x, 0, slices) {
                  sum[((int64(sum.s1.y.__thread_id_y)*(int64)32) + int64(sum.s1.x.__thread_id_x))] = (let sum.s1.t103610.s = diff[((int64(((sum.s1.r$x - diff.z.min_realized.s) + 4))*int64(((diff.x.extent_realized.s + -128)*diff.y.extent_realized))) + ((int64(((cost_confidence.s0.y.y_i.base + sum.s1.y.__thread_id_y) - diff.y.min_realized))*int64((diff.x.extent_realized.s + -128))) + int64(((cost_confidence.s0.x.x_i.base + sum.s1.x.__thread_id_x) - diff.x.min_realized))))] in (let sum.s1.t103611.s = diff[(((int64(((sum.s1.r$x - diff.z.min_realized.s) + 4))*int64(((diff.x.extent_realized.s + -128)*diff.y.extent_realized))) + ((int64(((cost_confidence.s0.y.y_i.base + sum.s1.y.__thread_id_y) - diff.y.min_realized))*int64((diff.x.extent_realized.s + -128))) + int64(((cost_confidence.s0.x.x_i.base + sum.s1.x.__thread_id_x) - diff.x.min_realized)))) + int64(diff.stride.3))] in (let sum.s1.t103612.s = diff[((int64(diff.stride.3)*(int64)2) + ((int64(((sum.s1.r$x - diff.z.min_realized.s) + 4))*int64(((diff.x.extent_realized.s + -128)*diff.y.extent_realized))) + ((int64(((cost_confidence.s0.y.y_i.base + sum.s1.y.__thread_id_y) - diff.y.min_realized))*int64((diff.x.extent_realized.s + -128))) + int64(((cost_confidence.s0.x.x_i.base + sum.s1.x.__thread_id_x) - diff.x.min_realized)))))] in (let sum.s1.t103613 = ((float32(sum.s1.t103612.s)*float32(sum.s1.t103612.s)) + ((float32(sum.s1.t103610.s)*float32(sum.s1.t103610.s)) + (float32(sum.s1.t103611.s)*float32(sum.s1.t103611.s)))) in (sum[((int64(sum.s1.y.__thread_id_y)*(int64)32) + int64(sum.s1.x.__thread_id_x))] + (sum.s1.t103613*sum.s1.t103613))))))
                }
              }
            }
          }
          allocate sum$1[float32 * 32 * 8]
          produce sum$1 {
            gpu_thread<CUDA> (sum$1.s0.y.__thread_id_y, 0, 8) {
              gpu_thread<CUDA> (sum$1.s0.x.__thread_id_x, 0, 32) {
                sum$1[((int64(sum$1.s0.y.__thread_id_y)*(int64)32) + int64(sum$1.s0.x.__thread_id_x))] = 0.000000f
              }
            }
            gpu_thread<CUDA> (sum$1.s1.y.__thread_id_y, 0, 8) {
              gpu_thread<CUDA> (sum$1.s1.x.__thread_id_x, 0, 32) {
                for (sum$1.s1.r$x, 0, slices) {
                  sum$1[((int64(sum$1.s1.y.__thread_id_y)*(int64)32) + int64(sum$1.s1.x.__thread_id_x))] = (let sum$1.s1.t103605.s = diff[((int64(((sum$1.s1.r$x - diff.z.min_realized.s) + 4))*int64(((diff.x.extent_realized.s + -128)*diff.y.extent_realized))) + ((int64(((cost_confidence.s0.y.y_i.base + sum$1.s1.y.__thread_id_y) - diff.y.min_realized))*int64((diff.x.extent_realized.s + -128))) + int64(((cost_confidence.s0.x.x_i.base + sum$1.s1.x.__thread_id_x) - diff.x.min_realized))))] in (let sum$1.s1.t103606.s = diff[(((int64(((sum$1.s1.r$x - diff.z.min_realized.s) + 4))*int64(((diff.x.extent_realized.s + -128)*diff.y.extent_realized))) + ((int64(((cost_confidence.s0.y.y_i.base + sum$1.s1.y.__thread_id_y) - diff.y.min_realized))*int64((diff.x.extent_realized.s + -128))) + int64(((cost_confidence.s0.x.x_i.base + sum$1.s1.x.__thread_id_x) - diff.x.min_realized)))) + int64(diff.stride.3))] in (let sum$1.s1.t103607.s = diff[((int64(diff.stride.3)*(int64)2) + ((int64(((sum$1.s1.r$x - diff.z.min_realized.s) + 4))*int64(((diff.x.extent_realized.s + -128)*diff.y.extent_realized))) + ((int64(((cost_confidence.s0.y.y_i.base + sum$1.s1.y.__thread_id_y) - diff.y.min_realized))*int64((diff.x.extent_realized.s + -128))) + int64(((cost_confidence.s0.x.x_i.base + sum$1.s1.x.__thread_id_x) - diff.x.min_realized)))))] in (sum$1[((int64(sum$1.s1.y.__thread_id_y)*(int64)32) + int64(sum$1.s1.x.__thread_id_x))] + (((float32(sum$1.s1.t103607.s)*float32(sum$1.s1.t103607.s)) + ((float32(sum$1.s1.t103605.s)*float32(sum$1.s1.t103605.s)) + (float32(sum$1.s1.t103606.s)*float32(sum$1.s1.t103606.s))))/float32(slices))))))
                }
              }
            }
          }
          consume sum$1 {
            consume sum {
              gpu_thread<CUDA> (cost_confidence.s0.y.y_i.__thread_id_y, 0, 8) {
                gpu_thread<CUDA> (cost_confidence.s0.x.x_i.__thread_id_x, 0, 32) {
                  cost_confidence[((int64(((cost_confidence.s0.y.y_i.__thread_id_y + cost_confidence.s0.y.y_i.base) - cost_confidence.y.min_realized))*int64((cost_confidence.x.extent_realized.s + -125))) + int64(((cost_confidence.s0.x.x_i.__thread_id_x + cost_confidence.s0.x.x_i.base) - cost_confidence.x.min_realized)))] = (let cost_confidence.s0.t11 = sum$1[((int64(cost_confidence.s0.y.y_i.__thread_id_y)*(int64)32) + int64(cost_confidence.s0.x.x_i.__thread_id_x))] in ((sum[((int64(cost_confidence.s0.y.y_i.__thread_id_y)*(int64)32) + int64(cost_confidence.s0.x.x_i.__thread_id_x))]/float32(slices)) - (cost_confidence.s0.t11*cost_confidence.s0.t11)))
                }
              }
            }
          }
        }
      }
      _halide_buffer_set_device_dirty(cost_confidence.buffer, (uint1)1)
    }
  }
  let downy.y.min_realized.s = min(max(downy.s0.y.max.s, 0), (max(min(min(min((left_im.extent.1/2), (min(max(downy$1.s0.y.min.s, 0), (max(downy$1.s0.y.max.s, 0) + -13))*2)), (min(min((argmin.s1.y.max.s + -16), argmin.s1.y.min), left_im.extent.1)/2)), downy.s0.y.min.s), 1) + 12))
  let downy.y.extent_realized.s = (max(min(max(downy.s0.y.max.s, 0), ((max(downy.s0.y.min.s, 1) + ((((max(downy.s0.y.max.s, 0) - max(downy.s0.y.min.s, 1)) + 1)/14)*14)) + 12)), (max(max(min((left_im.extent.1/2), ((min(max(downy$1.s0.y.max.s, 0), ((max(downy$1.s0.y.min.s, 0) + (((max(downy$1.s0.y.max.s, 0) - max(downy$1.s0.y.min.s, 0))/14)*14)) + 13))*2) + 3)), (min((min(((((((argmin.s1.y.max.s - argmin.s1.y.min) + -1)/16)*16) + argmin.s1.y.min) + 16), argmin.s1.y.max.s) + 3), left_im.extent.1)/2)), 1) + -1)) - downy.y.min_realized.s)
  let downy.x.min_realized = min(min(min(max(min((min((downy$1.s0.x.max.s + -39), downy$1.s0.x.min)*2), ((left_im.extent.0/2) + -1)), 0), (max(min(min((left_im.extent.0/2), (min((downy$1.s0.x.max.s + -39), downy$1.s0.x.min)*2)), (min(min((argmin.s1.x.max.s + -16), argmin.s1.x.min), left_im.extent.0)/2)), 1) + -1)), (downy.s0.x.max.s + -79)), downy.s0.x.min)
  let downy.x.extent_realized.s = (max(max(min((min((((((downy$1.s0.x.max.s - downy$1.s0.x.min)/8)*8) + downy$1.s0.x.min) + 7), downy$1.s0.x.max.s)*2), ((left_im.extent.0/2) + 63)), (max(max(min((left_im.extent.0/2), ((min((((((downy$1.s0.x.max.s - downy$1.s0.x.min)/8)*8) + downy$1.s0.x.min) + 7), downy$1.s0.x.max.s)*2) + -61)), (min((min(((((((argmin.s1.x.max.s - argmin.s1.x.min) + -1)/16)*16) + argmin.s1.x.min) + 16), argmin.s1.x.max.s) + 3), left_im.extent.0)/2)), 1) + 63)), min((((((downy.s0.x.max.s - downy.s0.x.min)/16)*16) + downy.s0.x.min) + 15), downy.s0.x.max.s)) - downy.x.min_realized)
  let downy.stride.2 = ((downy.x.extent_realized.s + -63)*(downy.y.extent_realized.s + 14))
  allocate downy[float32 * (downy.x.extent_realized.s + -63) * (downy.y.extent_realized.s + 14) * max(slices, 2) * 2] if (uint1)0
  let downy.buffer = (let t104139 = make_struct((halide_dimension_t *), downy.x.min_realized, (downy.x.extent_realized.s + -63), 1, 0, (downy.y.min_realized.s + -13), (downy.y.extent_realized.s + 14), (downy.x.extent_realized.s + -63), 0, (min(slices, 2) + -2), max(slices, 2), downy.stride.2, 0, 0, 2, (max(slices, 2)*downy.stride.2), 0) in _halide_buffer_init(alloca(size_of_halide_buffer_t()), t104139, reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 4, t104139, (uint64)0))
  register_destructor("halide_device_free_as_destructor", downy.buffer)
  let downy.s0.y.y_o.loop_extent.s = (max(downy.s0.y.max.s, 0) - max(downy.s0.y.min.s, 1))
  produce downy {
    consume cost_confidence {
      consume diff {
        let halide_device_malloc_result$11 = halide_device_malloc(downy.buffer, halide_cuda_device_interface())
        assert((halide_device_malloc_result$11 == 0), halide_device_malloc_result$11)
        gpu_block<CUDA> (downy.s0._0._0_o.__block_id_z, 0, ((slices + 1)/2)) {
          let downy.s0._0._0_i.base = min(likely_if_innermost((downy.s0._0._0_o.__block_id_z*2)), (slices + -2))
          gpu_block<CUDA> (downy.s0.y.y_o.__block_id_y, 0, ((downy.s0.y.y_o.loop_extent.s + 15)/14)) {
            let downy.s0.y.y_i.base = min(likely_if_innermost(((max(downy.s0.y.min.s, 1) + (downy.s0.y.y_o.__block_id_y*14)) + -1)), (max(downy.s0.y.max.s, 0) + -13))
            gpu_block<CUDA> (downy.s0.x.x_o.__block_id_x, 0, (((downy.s0.x.max.s - downy.s0.x.min)/16) + -3)) {
              let downy.s0.x.x_i.base = min(likely_if_innermost(((downy.s0.x.x_o.__block_id_x*16) + downy.s0.x.min)), (downy.s0.x.max.s + -79))
              allocate downx[float32 * 16 * 30 * 2 * 2]
              produce downx {
                gpu_thread<CUDA> (downx.s0._0.__thread_id_z, 0, 2) {
                  gpu_thread<CUDA> (downx.s0.y.__thread_id_y, 0, 30) {
                    gpu_thread<CUDA> (downx.s0.x.__thread_id_x, 0, 16) {
                      for (downx.s0._1, 0, 2) {
                        downx[((int64(downx.s0._1)*(int64)960) + ((int64(downx.s0._0.__thread_id_z)*(int64)480) + ((int64(downx.s0.y.__thread_id_y)*(int64)16) + int64(downx.s0.x.__thread_id_x))))] = (let downx.s0.t103621 = cost_confidence[(((int64(((((downy.s0.y.y_i.base*2) + downx.s0.y.__thread_id_y) - cost_confidence.y.min_realized) + -1))*int64((cost_confidence.x.extent_realized.s + -125))) + int64((((downx.s0.x.__thread_id_x + downy.s0.x.x_i.base)*2) - cost_confidence.x.min_realized))) + (int64)-1)] in (let downx.s0.t103622 = (downx.s0._1 == 0) in (let downx.s0.t103623 = cost_confidence[((int64(((((downy.s0.y.y_i.base*2) + downx.s0.y.__thread_id_y) - cost_confidence.y.min_realized) + -1))*int64((cost_confidence.x.extent_realized.s + -125))) + int64((((downx.s0.x.__thread_id_x + downy.s0.x.x_i.base)*2) - cost_confidence.x.min_realized)))] in (let downx.s0.t103624 = cost_confidence[(((int64(((((downy.s0.y.y_i.base*2) + downx.s0.y.__thread_id_y) - cost_confidence.y.min_realized) + -1))*int64((cost_confidence.x.extent_realized.s + -125))) + int64((((downx.s0.x.__thread_id_x + downy.s0.x.x_i.base)*2) - cost_confidence.x.min_realized))) + (int64)1)] in (let downx.s0.t103625 = cost_confidence[(((int64(((((downy.s0.y.y_i.base*2) + downx.s0.y.__thread_id_y) - cost_confidence.y.min_realized) + -1))*int64((cost_confidence.x.extent_realized.s + -125))) + int64((((downx.s0.x.__thread_id_x + downy.s0.x.x_i.base)*2) - cost_confidence.x.min_realized))) + (int64)2)] in (let downx.s0.t103626.s = diff[(((int64((((downx.s0._0.__thread_id_z + downy.s0._0._0_i.base) - diff.z.min_realized.s) + 4))*int64(((diff.x.extent_realized.s + -128)*diff.y.extent_realized))) + ((int64(((((downy.s0.y.y_i.base*2) + downx.s0.y.__thread_id_y) - diff.y.min_realized) + -1))*int64((diff.x.extent_realized.s + -128))) + int64((((downx.s0.x.__thread_id_x + downy.s0.x.x_i.base)*2) - diff.x.min_realized)))) + (int64)-1)] in (let downx.s0.t103627.s = diff[((((int64((((downx.s0._0.__thread_id_z + downy.s0._0._0_i.base) - diff.z.min_realized.s) + 4))*int64(((diff.x.extent_realized.s + -128)*diff.y.extent_realized))) + ((int64(((((downy.s0.y.y_i.base*2) + downx.s0.y.__thread_id_y) - diff.y.min_realized) + -1))*int64((diff.x.extent_realized.s + -128))) + int64((((downx.s0.x.__thread_id_x + downy.s0.x.x_i.base)*2) - diff.x.min_realized)))) + int64(diff.stride.3)) + (int64)-1)] in (let downx.s0.t103628.s = diff[(((int64(diff.stride.3)*(int64)2) + ((int64((((downx.s0._0.__thread_id_z + downy.s0._0._0_i.base) - diff.z.min_realized.s) + 4))*int64(((diff.x.extent_realized.s + -128)*diff.y.extent_realized))) + ((int64(((((downy.s0.y.y_i.base*2) + downx.s0.y.__thread_id_y) - diff.y.min_realized) + -1))*int64((diff.x.extent_realized.s + -128))) + int64((((downx.s0.x.__thread_id_x + downy.s0.x.x_i.base)*2) - diff.x.min_realized))))) + (int64)-1)] in (let downx.s0.t103629.s = diff[((int64((((downx.s0._0.__thread_id_z + downy.s0._0._0_i.base) - diff.z.min_realized.s) + 4))*int64(((diff.x.extent_realized.s + -128)*diff.y.extent_realized))) + ((int64(((((downy.s0.y.y_i.base*2) + downx.s0.y.__thread_id_y) - diff.y.min_realized) + -1))*int64((diff.x.extent_realized.s + -128))) + int64((((downx.s0.x.__thread_id_x + downy.s0.x.x_i.base)*2) - diff.x.min_realized))))] in (let downx.s0.t103630.s = diff[(((int64((((downx.s0._0.__thread_id_z + downy.s0._0._0_i.base) - diff.z.min_realized.s) + 4))*int64(((diff.x.extent_realized.s + -128)*diff.y.extent_realized))) + ((int64(((((downy.s0.y.y_i.base*2) + downx.s0.y.__thread_id_y) - diff.y.min_realized) + -1))*int64((diff.x.extent_realized.s + -128))) + int64((((downx.s0.x.__thread_id_x + downy.s0.x.x_i.base)*2) - diff.x.min_realized)))) + int64(diff.stride.3))] in (let downx.s0.t103631.s = diff[((int64(diff.stride.3)*(int64)2) + ((int64((((downx.s0._0.__thread_id_z + downy.s0._0._0_i.base) - diff.z.min_realized.s) + 4))*int64(((diff.x.extent_realized.s + -128)*diff.y.extent_realized))) + ((int64(((((downy.s0.y.y_i.base*2) + downx.s0.y.__thread_id_y) - diff.y.min_realized) + -1))*int64((diff.x.extent_realized.s + -128))) + int64((((downx.s0.x.__thread_id_x + downy.s0.x.x_i.base)*2) - diff.x.min_realized)))))] in (let downx.s0.t103632.s = diff[(((int64((((downx.s0._0.__thread_id_z + downy.s0._0._0_i.base) - diff.z.min_realized.s) + 4))*int64(((diff.x.extent_realized.s + -128)*diff.y.extent_realized))) + ((int64(((((downy.s0.y.y_i.base*2) + downx.s0.y.__thread_id_y) - diff.y.min_realized) + -1))*int64((diff.x.extent_realized.s + -128))) + int64((((downx.s0.x.__thread_id_x + downy.s0.x.x_i.base)*2) - diff.x.min_realized)))) + (int64)1)] in (let downx.s0.t103633.s = diff[((((int64((((downx.s0._0.__thread_id_z + downy.s0._0._0_i.base) - diff.z.min_realized.s) + 4))*int64(((diff.x.extent_realized.s + -128)*diff.y.extent_realized))) + ((int64(((((downy.s0.y.y_i.base*2) + downx.s0.y.__thread_id_y) - diff.y.min_realized) + -1))*int64((diff.x.extent_realized.s + -128))) + int64((((downx.s0.x.__thread_id_x + downy.s0.x.x_i.base)*2) - diff.x.min_realized)))) + int64(diff.stride.3)) + (int64)1)] in (let downx.s0.t103634.s = diff[(((int64(diff.stride.3)*(int64)2) + ((int64((((downx.s0._0.__thread_id_z + downy.s0._0._0_i.base) - diff.z.min_realized.s) + 4))*int64(((diff.x.extent_realized.s + -128)*diff.y.extent_realized))) + ((int64(((((downy.s0.y.y_i.base*2) + downx.s0.y.__thread_id_y) - diff.y.min_realized) + -1))*int64((diff.x.extent_realized.s + -128))) + int64((((downx.s0.x.__thread_id_x + downy.s0.x.x_i.base)*2) - diff.x.min_realized))))) + (int64)1)] in (let downx.s0.t103635.s = diff[(((int64((((downx.s0._0.__thread_id_z + downy.s0._0._0_i.base) - diff.z.min_realized.s) + 4))*int64(((diff.x.extent_realized.s + -128)*diff.y.extent_realized))) + ((int64(((((downy.s0.y.y_i.base*2) + downx.s0.y.__thread_id_y) - diff.y.min_realized) + -1))*int64((diff.x.extent_realized.s + -128))) + int64((((downx.s0.x.__thread_id_x + downy.s0.x.x_i.base)*2) - diff.x.min_realized)))) + (int64)2)] in (let downx.s0.t103636.s = diff[((((int64((((downx.s0._0.__thread_id_z + downy.s0._0._0_i.base) - diff.z.min_realized.s) + 4))*int64(((diff.x.extent_realized.s + -128)*diff.y.extent_realized))) + ((int64(((((downy.s0.y.y_i.base*2) + downx.s0.y.__thread_id_y) - diff.y.min_realized) + -1))*int64((diff.x.extent_realized.s + -128))) + int64((((downx.s0.x.__thread_id_x + downy.s0.x.x_i.base)*2) - diff.x.min_realized)))) + int64(diff.stride.3)) + (int64)2)] in (let downx.s0.t103637.s = diff[(((int64(diff.stride.3)*(int64)2) + ((int64((((downx.s0._0.__thread_id_z + downy.s0._0._0_i.base) - diff.z.min_realized.s) + 4))*int64(((diff.x.extent_realized.s + -128)*diff.y.extent_realized))) + ((int64(((((downy.s0.y.y_i.base*2) + downx.s0.y.__thread_id_y) - diff.y.min_realized) + -1))*int64((diff.x.extent_realized.s + -128))) + int64((((downx.s0.x.__thread_id_x + downy.s0.x.x_i.base)*2) - diff.x.min_realized))))) + (int64)2)] in ((select(downx.s0.t103622, ((((float32(downx.s0.t103637.s)*float32(downx.s0.t103637.s)) + ((float32(downx.s0.t103635.s)*float32(downx.s0.t103635.s)) + (float32(downx.s0.t103636.s)*float32(downx.s0.t103636.s))))*downx.s0.t103625) + (((float32(downx.s0.t103628.s)*float32(downx.s0.t103628.s)) + ((float32(downx.s0.t103626.s)*float32(downx.s0.t103626.s)) + (float32(downx.s0.t103627.s)*float32(downx.s0.t103627.s))))*downx.s0.t103621)), (downx.s0.t103621 + downx.s0.t103625)) + (select(downx.s0.t103622, ((((float32(downx.s0.t103631.s)*float32(downx.s0.t103631.s)) + ((float32(downx.s0.t103629.s)*float32(downx.s0.t103629.s)) + (float32(downx.s0.t103630.s)*float32(downx.s0.t103630.s))))*downx.s0.t103623) + (((float32(downx.s0.t103634.s)*float32(downx.s0.t103634.s)) + ((float32(downx.s0.t103632.s)*float32(downx.s0.t103632.s)) + (float32(downx.s0.t103633.s)*float32(downx.s0.t103633.s))))*downx.s0.t103624)), (downx.s0.t103623 + downx.s0.t103624))*3.000000f))*0.125000f))))))))))))))))))
                      }
                    }
                  }
                }
              }
              consume downx {
                gpu_thread<CUDA> (downy.s0._0._0_i.__thread_id_z, 0, 2) {
                  gpu_thread<CUDA> (downy.s0.y.y_i.__thread_id_y, 0, 14) {
                    gpu_thread<CUDA> (downy.s0.x.x_i.__thread_id_x, 0, 16) {
                      for (downy.s0._1, 0, 2) {
                        downy[((int64(downy.s0._1)*int64((max(slices, 2)*downy.stride.2))) + ((int64((((downy.s0._0._0_i.__thread_id_z + downy.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy.stride.2)) + ((int64((((downy.s0.y.y_i.__thread_id_y + downy.s0.y.y_i.base) - downy.y.min_realized.s) + 13))*int64((downy.x.extent_realized.s + -63))) + int64(((downy.s0.x.x_i.__thread_id_x + downy.s0.x.x_i.base) - downy.x.min_realized)))))] = ((downx[(((int64(downy.s0._1)*(int64)960) + ((int64(downy.s0._0._0_i.__thread_id_z)*(int64)480) + ((int64(((downy.s0.y.y_i.__thread_id_y*2) + 1))*(int64)16) + int64(downy.s0.x.x_i.__thread_id_x)))) + (int64)32)] + (downx[(((int64(downy.s0._1)*(int64)960) + ((int64(downy.s0._0._0_i.__thread_id_z)*(int64)480) + ((int64(((downy.s0.y.y_i.__thread_id_y*2) + 1))*(int64)16) + int64(downy.s0.x.x_i.__thread_id_x)))) + (int64)-16)] + ((downx[((int64(downy.s0._1)*(int64)960) + ((int64(downy.s0._0._0_i.__thread_id_z)*(int64)480) + ((int64(((downy.s0.y.y_i.__thread_id_y*2) + 1))*(int64)16) + int64(downy.s0.x.x_i.__thread_id_x))))] + downx[(((int64(downy.s0._1)*(int64)960) + ((int64(downy.s0._0._0_i.__thread_id_z)*(int64)480) + ((int64(((downy.s0.y.y_i.__thread_id_y*2) + 1))*(int64)16) + int64(downy.s0.x.x_i.__thread_id_x)))) + (int64)16)])*3.000000f)))*0.125000f)
                      }
                    }
                  }
                }
              }
            }
          }
        }
        _halide_buffer_set_device_dirty(downy.buffer, (uint1)1)
      }
    }
  }
  let downy$1.y.min_realized = min(max(downy$1.s0.y.min.s, 0), min(min(max(((min(min((argmin.s1.y.min + 49), argmin.s1.y.max.s), (left_im.extent.1 + 51)) + -55)/4), 0), (max(min((left_im.extent.1/4), (min(max(downy$2.s0.y.min.s, 0), (max(downy$2.s0.y.max.s, 0) + -13))*2)), 1) + -1)), (max(downy$1.s0.y.max.s, 0) + -13)))
  let downy$1.y.extent_realized.s = (max(max(min(min(((argmin.s1.y.max.s + 5)/4), (((argmin.s1.y.min + 54)/4) + (((((argmin.s1.y.max.s + 5)/4) - ((argmin.s1.y.min + -6)/4))/16)*16))), ((left_im.extent.1/4) + -1)), (max(min((left_im.extent.1/4), ((min(max(downy$2.s0.y.max.s, 0), ((max(downy$2.s0.y.min.s, 0) + (((max(downy$2.s0.y.max.s, 0) - max(downy$2.s0.y.min.s, 0))/14)*14)) + 13))*2) + 3)), 1) + -1)), min(max(downy$1.s0.y.max.s, 0), ((max(downy$1.s0.y.min.s, 0) + (((max(downy$1.s0.y.max.s, 0) - max(downy$1.s0.y.min.s, 0))/14)*14)) + 13))) - downy$1.y.min_realized)
  let downy$1.x.min_realized = min(min(min(max(((min(min((argmin.s1.x.min + 49), argmin.s1.x.max.s), (left_im.extent.0 + 51)) + -55)/4), 0), min(max(min((min((downy$2.s0.x.max.s + -23), downy$2.s0.x.min)*2), ((left_im.extent.0/4) + -1)), 0), (max(min((left_im.extent.0/4), (min((downy$2.s0.x.max.s + -23), downy$2.s0.x.min)*2)), 1) + -1))), (downy$1.s0.x.max.s + -39)), downy$1.s0.x.min)
  let downy$1.x.extent_realized.s = (max(min(min(((argmin.s1.x.max.s + 5)/4), (((argmin.s1.x.min + 54)/4) + (((((argmin.s1.x.max.s + 5)/4) - ((argmin.s1.x.min + -6)/4))/16)*16))), ((left_im.extent.0/4) + -1)), (max(max(min((min((((((downy$2.s0.x.max.s - downy$2.s0.x.min)/8)*8) + downy$2.s0.x.min) + 7), downy$2.s0.x.max.s)*2), ((left_im.extent.0/4) + 31)), (max(min((left_im.extent.0/4), ((min((((((downy$2.s0.x.max.s - downy$2.s0.x.min)/8)*8) + downy$2.s0.x.min) + 7), downy$2.s0.x.max.s)*2) + -29)), 1) + 31)), min((((((downy$1.s0.x.max.s - downy$1.s0.x.min)/8)*8) + downy$1.s0.x.min) + 7), downy$1.s0.x.max.s)) + -32)) - downy$1.x.min_realized)
  let downy$1.stride.2 = ((downy$1.x.extent_realized.s + 1)*(downy$1.y.extent_realized.s + 1))
  allocate downy$1[float32 * (downy$1.x.extent_realized.s + 1) * (downy$1.y.extent_realized.s + 1) * max(slices, 2) * 2] if (uint1)0
  let downy$1.buffer = (let t104138 = make_struct((halide_dimension_t *), downy$1.x.min_realized, (downy$1.x.extent_realized.s + 1), 1, 0, downy$1.y.min_realized, (downy$1.y.extent_realized.s + 1), (downy$1.x.extent_realized.s + 1), 0, (min(slices, 2) + -2), max(slices, 2), downy$1.stride.2, 0, 0, 2, (max(slices, 2)*downy$1.stride.2), 0) in _halide_buffer_init(alloca(size_of_halide_buffer_t()), t104138, reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 4, t104138, (uint64)0))
  register_destructor("halide_device_free_as_destructor", downy$1.buffer)
  let downy$1.s0.y.y_o.loop_extent.s = (max(downy$1.s0.y.max.s, 0) - max(downy$1.s0.y.min.s, 0))
  produce downy$1 {
    consume downy {
      let halide_device_malloc_result$10 = halide_device_malloc(downy$1.buffer, halide_cuda_device_interface())
      assert((halide_device_malloc_result$10 == 0), halide_device_malloc_result$10)
      gpu_block<CUDA> (downy$1.s0._0._0_o.__block_id_z, 0, ((slices + 1)/2)) {
        let downy$1.s0._0._0_i.base = min(likely_if_innermost((downy$1.s0._0._0_o.__block_id_z*2)), (slices + -2))
        gpu_block<CUDA> (downy$1.s0.y.y_o.__block_id_y, 0, ((downy$1.s0.y.y_o.loop_extent.s/14) + 1)) {
          let downy$1.s0.y.y_i.base = min(likely_if_innermost((max(downy$1.s0.y.min.s, 0) + (downy$1.s0.y.y_o.__block_id_y*14))), (max(downy$1.s0.y.max.s, 0) + -13))
          gpu_block<CUDA> (downy$1.s0.x.x_o.__block_id_x, 0, (((downy$1.s0.x.max.s - downy$1.s0.x.min)/8) + -3)) {
            let downy$1.s0.x.x_i.base = min(likely_if_innermost(((downy$1.s0.x.x_o.__block_id_x*8) + downy$1.s0.x.min)), (downy$1.s0.x.max.s + -39))
            allocate downx$1[float32 * 8 * 30 * 2 * 2]
            produce downx$1 {
              gpu_thread<CUDA> (downx$1.s0._0.__thread_id_z, 0, 2) {
                gpu_thread<CUDA> (downx$1.s0.y.__thread_id_y, 0, 30) {
                  gpu_thread<CUDA> (downx$1.s0.x.__thread_id_x, 0, 8) {
                    for (downx$1.s0._1, 0, 2) {
                      downx$1[((int64(downx$1.s0._1)*(int64)480) + ((int64(downx$1.s0._0.__thread_id_z)*(int64)240) + ((int64(downx$1.s0.y.__thread_id_y)*(int64)8) + int64(downx$1.s0.x.__thread_id_x))))] = (let downx$1.s0.t103638.s = min(likely((((downy$1.s0.y.y_i.base*2) + downx$1.s0.y.__thread_id_y) + -1)), ((left_im.extent.1/2) + -1)) in ((downy[((int64(downx$1.s0._1)*int64((max(slices, 2)*downy.stride.2))) + ((int64((((downx$1.s0._0.__thread_id_z + downy$1.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy.stride.2)) + ((int64(((max(downx$1.s0.t103638.s, 0) - downy.y.min_realized.s) + 13))*int64((downy.x.extent_realized.s + -63))) + int64((max(min(likely((((downx$1.s0.x.__thread_id_x + downy$1.s0.x.x_i.base)*2) + 2)), ((left_im.extent.0/2) + -1)), 0) - downy.x.min_realized)))))] + (downy[((int64(downx$1.s0._1)*int64((max(slices, 2)*downy.stride.2))) + ((int64((((downx$1.s0._0.__thread_id_z + downy$1.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy.stride.2)) + ((int64(((max(downx$1.s0.t103638.s, 0) - downy.y.min_realized.s) + 13))*int64((downy.x.extent_realized.s + -63))) + int64((max(min(likely((((downx$1.s0.x.__thread_id_x + downy$1.s0.x.x_i.base)*2) + -1)), ((left_im.extent.0/2) + -1)), 0) - downy.x.min_realized)))))] + ((downy[((int64(downx$1.s0._1)*int64((max(slices, 2)*downy.stride.2))) + ((int64((((downx$1.s0._0.__thread_id_z + downy$1.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy.stride.2)) + ((int64(((max(downx$1.s0.t103638.s, 0) - downy.y.min_realized.s) + 13))*int64((downy.x.extent_realized.s + -63))) + int64((max(min(likely(((downx$1.s0.x.__thread_id_x + downy$1.s0.x.x_i.base)*2)), ((left_im.extent.0/2) + -1)), 0) - downy.x.min_realized)))))] + downy[((int64(downx$1.s0._1)*int64((max(slices, 2)*downy.stride.2))) + ((int64((((downx$1.s0._0.__thread_id_z + downy$1.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy.stride.2)) + ((int64(((max(downx$1.s0.t103638.s, 0) - downy.y.min_realized.s) + 13))*int64((downy.x.extent_realized.s + -63))) + int64((max(min(likely((((downx$1.s0.x.__thread_id_x + downy$1.s0.x.x_i.base)*2) + 1)), ((left_im.extent.0/2) + -1)), 0) - downy.x.min_realized)))))])*3.000000f)))*0.125000f))
                    }
                  }
                }
              }
            }
            consume downx$1 {
              gpu_thread<CUDA> (downy$1.s0._0._0_i.__thread_id_z, 0, 2) {
                gpu_thread<CUDA> (downy$1.s0.y.y_i.__thread_id_y, 0, 14) {
                  gpu_thread<CUDA> (downy$1.s0.x.x_i.__thread_id_x, 0, 8) {
                    for (downy$1.s0._1, 0, 2) {
                      downy$1[((int64(downy$1.s0._1)*int64((max(slices, 2)*downy$1.stride.2))) + ((int64((((downy$1.s0._0._0_i.__thread_id_z + downy$1.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy$1.stride.2)) + ((int64(((downy$1.s0.y.y_i.__thread_id_y + downy$1.s0.y.y_i.base) - downy$1.y.min_realized))*int64((downy$1.x.extent_realized.s + 1))) + int64(((downy$1.s0.x.x_i.__thread_id_x + downy$1.s0.x.x_i.base) - downy$1.x.min_realized)))))] = ((downx$1[(((int64(downy$1.s0._1)*(int64)480) + ((int64(downy$1.s0._0._0_i.__thread_id_z)*(int64)240) + ((int64(((downy$1.s0.y.y_i.__thread_id_y*2) + 1))*(int64)8) + int64(downy$1.s0.x.x_i.__thread_id_x)))) + (int64)16)] + (downx$1[(((int64(downy$1.s0._1)*(int64)480) + ((int64(downy$1.s0._0._0_i.__thread_id_z)*(int64)240) + ((int64(((downy$1.s0.y.y_i.__thread_id_y*2) + 1))*(int64)8) + int64(downy$1.s0.x.x_i.__thread_id_x)))) + (int64)-8)] + ((downx$1[((int64(downy$1.s0._1)*(int64)480) + ((int64(downy$1.s0._0._0_i.__thread_id_z)*(int64)240) + ((int64(((downy$1.s0.y.y_i.__thread_id_y*2) + 1))*(int64)8) + int64(downy$1.s0.x.x_i.__thread_id_x))))] + downx$1[(((int64(downy$1.s0._1)*(int64)480) + ((int64(downy$1.s0._0._0_i.__thread_id_z)*(int64)240) + ((int64(((downy$1.s0.y.y_i.__thread_id_y*2) + 1))*(int64)8) + int64(downy$1.s0.x.x_i.__thread_id_x)))) + (int64)8)])*3.000000f)))*0.125000f)
                    }
                  }
                }
              }
            }
          }
        }
      }
      _halide_buffer_set_device_dirty(downy$1.buffer, (uint1)1)
    }
  }
  let downy$2.y.min_realized = min(min(max(downy$2.s0.y.min.s, 0), (max(downy$2.s0.y.max.s, 0) + -13)), (max(min(min(((min((argmin.s1.y.min + 49), argmin.s1.y.max.s) + -55)/8), (min(max(downy$3.s0.y.min.s, 0), (max(downy$3.s0.y.max.s, 0) + -13))*2)), (left_im.extent.1/8)), 1) + -1))
  let downy$2.y.extent_realized.s = (max(min(max(downy$2.s0.y.max.s, 0), ((max(downy$2.s0.y.min.s, 0) + (((max(downy$2.s0.y.max.s, 0) - max(downy$2.s0.y.min.s, 0))/14)*14)) + 13)), (max(min((left_im.extent.1/8), (max((min(((argmin.s1.y.max.s + 5)/4), (((argmin.s1.y.min + 54)/4) + (((((argmin.s1.y.max.s + 5)/4) - ((argmin.s1.y.min + -6)/4))/16)*16)))/2), ((min(max(downy$3.s0.y.max.s, 0), ((max(downy$3.s0.y.min.s, 0) + (((max(downy$3.s0.y.max.s, 0) - max(downy$3.s0.y.min.s, 0))/14)*14)) + 13))*2) + 1)) + 2)), 1) + -1)) - downy$2.y.min_realized)
  let downy$2.x.min_realized = min(min(min(max(min((min((downy$3.s0.x.max.s + -15), downy$3.s0.x.min)*2), ((left_im.extent.0/8) + -1)), 0), (max(min(min(((min((argmin.s1.x.min + 49), argmin.s1.x.max.s) + -55)/8), (min((downy$3.s0.x.max.s + -15), downy$3.s0.x.min)*2)), (left_im.extent.0/8)), 1) + -1)), (downy$2.s0.x.max.s + -23)), downy$2.s0.x.min)
  let downy$2.x.extent_realized.s = (max(max(min((min((((((downy$3.s0.x.max.s - downy$3.s0.x.min)/8)*8) + downy$3.s0.x.min) + 7), downy$3.s0.x.max.s)*2), ((left_im.extent.0/8) + 15)), (max(min((left_im.extent.0/8), (max((min(((argmin.s1.x.max.s + 5)/4), (((argmin.s1.x.min + 54)/4) + (((((argmin.s1.x.max.s + 5)/4) - ((argmin.s1.x.min + -6)/4))/16)*16)))/2), ((min((((((downy$3.s0.x.max.s - downy$3.s0.x.min)/8)*8) + downy$3.s0.x.min) + 7), downy$3.s0.x.max.s)*2) + -15)) + 2)), 1) + 15)), min((((((downy$2.s0.x.max.s - downy$2.s0.x.min)/8)*8) + downy$2.s0.x.min) + 7), downy$2.s0.x.max.s)) - downy$2.x.min_realized)
  let downy$2.stride.2 = ((downy$2.x.extent_realized.s + -15)*(downy$2.y.extent_realized.s + 1))
  allocate downy$2[float32 * (downy$2.x.extent_realized.s + -15) * (downy$2.y.extent_realized.s + 1) * max(slices, 2) * 2] if (uint1)0
  let downy$2.buffer = (let t104137 = make_struct((halide_dimension_t *), downy$2.x.min_realized, (downy$2.x.extent_realized.s + -15), 1, 0, downy$2.y.min_realized, (downy$2.y.extent_realized.s + 1), (downy$2.x.extent_realized.s + -15), 0, (min(slices, 2) + -2), max(slices, 2), downy$2.stride.2, 0, 0, 2, (max(slices, 2)*downy$2.stride.2), 0) in _halide_buffer_init(alloca(size_of_halide_buffer_t()), t104137, reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 4, t104137, (uint64)0))
  register_destructor("halide_device_free_as_destructor", downy$2.buffer)
  let downy$2.s0.y.y_o.loop_extent.s = (max(downy$2.s0.y.max.s, 0) - max(downy$2.s0.y.min.s, 0))
  produce downy$2 {
    consume downy$1 {
      let halide_device_malloc_result$9 = halide_device_malloc(downy$2.buffer, halide_cuda_device_interface())
      assert((halide_device_malloc_result$9 == 0), halide_device_malloc_result$9)
      gpu_block<CUDA> (downy$2.s0._0._0_o.__block_id_z, 0, ((slices + 1)/2)) {
        let downy$2.s0._0._0_i.base = min(likely_if_innermost((downy$2.s0._0._0_o.__block_id_z*2)), (slices + -2))
        gpu_block<CUDA> (downy$2.s0.y.y_o.__block_id_y, 0, ((downy$2.s0.y.y_o.loop_extent.s/14) + 1)) {
          let downy$2.s0.y.y_i.base = min(likely_if_innermost((max(downy$2.s0.y.min.s, 0) + (downy$2.s0.y.y_o.__block_id_y*14))), (max(downy$2.s0.y.max.s, 0) + -13))
          gpu_block<CUDA> (downy$2.s0.x.x_o.__block_id_x, 0, (((downy$2.s0.x.max.s - downy$2.s0.x.min)/8) + -1)) {
            let downy$2.s0.x.x_i.base = min(likely_if_innermost(((downy$2.s0.x.x_o.__block_id_x*8) + downy$2.s0.x.min)), (downy$2.s0.x.max.s + -23))
            allocate downx$2[float32 * 8 * 30 * 2 * 2]
            produce downx$2 {
              gpu_thread<CUDA> (downx$2.s0._0.__thread_id_z, 0, 2) {
                gpu_thread<CUDA> (downx$2.s0.y.__thread_id_y, 0, 30) {
                  gpu_thread<CUDA> (downx$2.s0.x.__thread_id_x, 0, 8) {
                    for (downx$2.s0._1, 0, 2) {
                      downx$2[((int64(downx$2.s0._1)*(int64)480) + ((int64(downx$2.s0._0.__thread_id_z)*(int64)240) + ((int64(downx$2.s0.y.__thread_id_y)*(int64)8) + int64(downx$2.s0.x.__thread_id_x))))] = (let downx$2.s0.t103639.s = min(likely((((downy$2.s0.y.y_i.base*2) + downx$2.s0.y.__thread_id_y) + -1)), ((left_im.extent.1/4) + -1)) in ((downy$1[((int64(downx$2.s0._1)*int64((max(slices, 2)*downy$1.stride.2))) + ((int64((((downx$2.s0._0.__thread_id_z + downy$2.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy$1.stride.2)) + ((int64((max(downx$2.s0.t103639.s, 0) - downy$1.y.min_realized))*int64((downy$1.x.extent_realized.s + 1))) + int64((max(min(likely((((downx$2.s0.x.__thread_id_x + downy$2.s0.x.x_i.base)*2) + 2)), ((left_im.extent.0/4) + -1)), 0) - downy$1.x.min_realized)))))] + (downy$1[((int64(downx$2.s0._1)*int64((max(slices, 2)*downy$1.stride.2))) + ((int64((((downx$2.s0._0.__thread_id_z + downy$2.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy$1.stride.2)) + ((int64((max(downx$2.s0.t103639.s, 0) - downy$1.y.min_realized))*int64((downy$1.x.extent_realized.s + 1))) + int64((max(min(likely((((downx$2.s0.x.__thread_id_x + downy$2.s0.x.x_i.base)*2) + -1)), ((left_im.extent.0/4) + -1)), 0) - downy$1.x.min_realized)))))] + ((downy$1[((int64(downx$2.s0._1)*int64((max(slices, 2)*downy$1.stride.2))) + ((int64((((downx$2.s0._0.__thread_id_z + downy$2.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy$1.stride.2)) + ((int64((max(downx$2.s0.t103639.s, 0) - downy$1.y.min_realized))*int64((downy$1.x.extent_realized.s + 1))) + int64((max(min(likely(((downx$2.s0.x.__thread_id_x + downy$2.s0.x.x_i.base)*2)), ((left_im.extent.0/4) + -1)), 0) - downy$1.x.min_realized)))))] + downy$1[((int64(downx$2.s0._1)*int64((max(slices, 2)*downy$1.stride.2))) + ((int64((((downx$2.s0._0.__thread_id_z + downy$2.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy$1.stride.2)) + ((int64((max(downx$2.s0.t103639.s, 0) - downy$1.y.min_realized))*int64((downy$1.x.extent_realized.s + 1))) + int64((max(min(likely((((downx$2.s0.x.__thread_id_x + downy$2.s0.x.x_i.base)*2) + 1)), ((left_im.extent.0/4) + -1)), 0) - downy$1.x.min_realized)))))])*3.000000f)))*0.125000f))
                    }
                  }
                }
              }
            }
            consume downx$2 {
              gpu_thread<CUDA> (downy$2.s0._0._0_i.__thread_id_z, 0, 2) {
                gpu_thread<CUDA> (downy$2.s0.y.y_i.__thread_id_y, 0, 14) {
                  gpu_thread<CUDA> (downy$2.s0.x.x_i.__thread_id_x, 0, 8) {
                    for (downy$2.s0._1, 0, 2) {
                      downy$2[((int64(downy$2.s0._1)*int64((max(slices, 2)*downy$2.stride.2))) + ((int64((((downy$2.s0._0._0_i.__thread_id_z + downy$2.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy$2.stride.2)) + ((int64(((downy$2.s0.y.y_i.__thread_id_y + downy$2.s0.y.y_i.base) - downy$2.y.min_realized))*int64((downy$2.x.extent_realized.s + -15))) + int64(((downy$2.s0.x.x_i.__thread_id_x + downy$2.s0.x.x_i.base) - downy$2.x.min_realized)))))] = ((downx$2[(((int64(downy$2.s0._1)*(int64)480) + ((int64(downy$2.s0._0._0_i.__thread_id_z)*(int64)240) + ((int64(((downy$2.s0.y.y_i.__thread_id_y*2) + 1))*(int64)8) + int64(downy$2.s0.x.x_i.__thread_id_x)))) + (int64)16)] + (downx$2[(((int64(downy$2.s0._1)*(int64)480) + ((int64(downy$2.s0._0._0_i.__thread_id_z)*(int64)240) + ((int64(((downy$2.s0.y.y_i.__thread_id_y*2) + 1))*(int64)8) + int64(downy$2.s0.x.x_i.__thread_id_x)))) + (int64)-8)] + ((downx$2[((int64(downy$2.s0._1)*(int64)480) + ((int64(downy$2.s0._0._0_i.__thread_id_z)*(int64)240) + ((int64(((downy$2.s0.y.y_i.__thread_id_y*2) + 1))*(int64)8) + int64(downy$2.s0.x.x_i.__thread_id_x))))] + downx$2[(((int64(downy$2.s0._1)*(int64)480) + ((int64(downy$2.s0._0._0_i.__thread_id_z)*(int64)240) + ((int64(((downy$2.s0.y.y_i.__thread_id_y*2) + 1))*(int64)8) + int64(downy$2.s0.x.x_i.__thread_id_x)))) + (int64)8)])*3.000000f)))*0.125000f)
                    }
                  }
                }
              }
            }
          }
        }
      }
      _halide_buffer_set_device_dirty(downy$2.buffer, (uint1)1)
    }
  }
  let downy$3.y.min_realized = min(max(downy$3.s0.y.min.s, 0), min(min(max(((min(min((argmin.s1.y.min + 49), argmin.s1.y.max.s), (left_im.extent.1 + 63)) + -79)/16), 0), (max(min((left_im.extent.1/16), (min(max(downy$4.s0.y.min.s, 0), (max(downy$4.s0.y.max.s, 0) + -13))*2)), 1) + -1)), (max(downy$3.s0.y.max.s, 0) + -13)))
  let downy$3.y.extent_realized.s = (max(max(min(((min(((argmin.s1.y.max.s + 5)/4), (((argmin.s1.y.min + 54)/4) + (((((argmin.s1.y.max.s + 5)/4) - ((argmin.s1.y.min + -6)/4))/16)*16))) + 6)/4), ((left_im.extent.1/16) + -1)), (max(min((left_im.extent.1/16), ((min(max(downy$4.s0.y.max.s, 0), ((max(downy$4.s0.y.min.s, 0) + (((max(downy$4.s0.y.max.s, 0) - max(downy$4.s0.y.min.s, 0))/14)*14)) + 13))*2) + 3)), 1) + -1)), min(max(downy$3.s0.y.max.s, 0), ((max(downy$3.s0.y.min.s, 0) + (((max(downy$3.s0.y.max.s, 0) - max(downy$3.s0.y.min.s, 0))/14)*14)) + 13))) - downy$3.y.min_realized)
  let downy$3.x.min_realized = min(min(min(max(((min(min((argmin.s1.x.min + 49), argmin.s1.x.max.s), (left_im.extent.0 + 63)) + -79)/16), 0), min(max(min((min((downy$4.s0.x.max.s + -11), downy$4.s0.x.min)*2), ((left_im.extent.0/16) + -1)), 0), (max(min((left_im.extent.0/16), (min((downy$4.s0.x.max.s + -11), downy$4.s0.x.min)*2)), 1) + -1))), (downy$3.s0.x.max.s + -15)), downy$3.s0.x.min)
  let downy$3.x.extent_realized.s = (max(min(((min(((argmin.s1.x.max.s + 5)/4), (((argmin.s1.x.min + 54)/4) + (((((argmin.s1.x.max.s + 5)/4) - ((argmin.s1.x.min + -6)/4))/16)*16))) + 6)/4), ((left_im.extent.0/16) + -1)), (max(max(min((min(((((((downy$4.s0.x.max.s - downy$4.s0.x.min) + -4)/8)*8) + downy$4.s0.x.min) + 11), downy$4.s0.x.max.s)*2), ((left_im.extent.0/16) + 7)), (max(min((left_im.extent.0/16), ((min(((((((downy$4.s0.x.max.s - downy$4.s0.x.min) + -4)/8)*8) + downy$4.s0.x.min) + 11), downy$4.s0.x.max.s)*2) + -5)), 1) + 7)), min((((((downy$3.s0.x.max.s - downy$3.s0.x.min)/8)*8) + downy$3.s0.x.min) + 7), downy$3.s0.x.max.s)) + -8)) - downy$3.x.min_realized)
  let downy$3.stride.2 = ((downy$3.x.extent_realized.s + 1)*(downy$3.y.extent_realized.s + 1))
  allocate downy$3[float32 * (downy$3.x.extent_realized.s + 1) * (downy$3.y.extent_realized.s + 1) * max(slices, 2) * 2] if (uint1)0
  let downy$3.buffer = (let t104136 = make_struct((halide_dimension_t *), downy$3.x.min_realized, (downy$3.x.extent_realized.s + 1), 1, 0, downy$3.y.min_realized, (downy$3.y.extent_realized.s + 1), (downy$3.x.extent_realized.s + 1), 0, (min(slices, 2) + -2), max(slices, 2), downy$3.stride.2, 0, 0, 2, (max(slices, 2)*downy$3.stride.2), 0) in _halide_buffer_init(alloca(size_of_halide_buffer_t()), t104136, reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 4, t104136, (uint64)0))
  register_destructor("halide_device_free_as_destructor", downy$3.buffer)
  let downy$3.s0.y.y_o.loop_extent.s = (max(downy$3.s0.y.max.s, 0) - max(downy$3.s0.y.min.s, 0))
  produce downy$3 {
    consume downy$2 {
      let halide_device_malloc_result$8 = halide_device_malloc(downy$3.buffer, halide_cuda_device_interface())
      assert((halide_device_malloc_result$8 == 0), halide_device_malloc_result$8)
      gpu_block<CUDA> (downy$3.s0._0._0_o.__block_id_z, 0, ((slices + 1)/2)) {
        let downy$3.s0._0._0_i.base = min(likely_if_innermost((downy$3.s0._0._0_o.__block_id_z*2)), (slices + -2))
        gpu_block<CUDA> (downy$3.s0.y.y_o.__block_id_y, 0, ((downy$3.s0.y.y_o.loop_extent.s/14) + 1)) {
          let downy$3.s0.y.y_i.base = min(likely_if_innermost((max(downy$3.s0.y.min.s, 0) + (downy$3.s0.y.y_o.__block_id_y*14))), (max(downy$3.s0.y.max.s, 0) + -13))
          gpu_block<CUDA> (downy$3.s0.x.x_o.__block_id_x, 0, ((downy$3.s0.x.max.s - downy$3.s0.x.min)/8)) {
            let downy$3.s0.x.x_i.base = min(likely_if_innermost(((downy$3.s0.x.x_o.__block_id_x*8) + downy$3.s0.x.min)), (downy$3.s0.x.max.s + -15))
            allocate downx$3[float32 * 8 * 30 * 2 * 2]
            produce downx$3 {
              gpu_thread<CUDA> (downx$3.s0._0.__thread_id_z, 0, 2) {
                gpu_thread<CUDA> (downx$3.s0.y.__thread_id_y, 0, 30) {
                  gpu_thread<CUDA> (downx$3.s0.x.__thread_id_x, 0, 8) {
                    for (downx$3.s0._1, 0, 2) {
                      downx$3[((int64(downx$3.s0._1)*(int64)480) + ((int64(downx$3.s0._0.__thread_id_z)*(int64)240) + ((int64(downx$3.s0.y.__thread_id_y)*(int64)8) + int64(downx$3.s0.x.__thread_id_x))))] = (let downx$3.s0.t103640.s = min(likely((((downy$3.s0.y.y_i.base*2) + downx$3.s0.y.__thread_id_y) + -1)), ((left_im.extent.1/8) + -1)) in ((downy$2[((int64(downx$3.s0._1)*int64((max(slices, 2)*downy$2.stride.2))) + ((int64((((downx$3.s0._0.__thread_id_z + downy$3.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy$2.stride.2)) + ((int64((max(downx$3.s0.t103640.s, 0) - downy$2.y.min_realized))*int64((downy$2.x.extent_realized.s + -15))) + int64((max(min(likely((((downx$3.s0.x.__thread_id_x + downy$3.s0.x.x_i.base)*2) + 2)), ((left_im.extent.0/8) + -1)), 0) - downy$2.x.min_realized)))))] + (downy$2[((int64(downx$3.s0._1)*int64((max(slices, 2)*downy$2.stride.2))) + ((int64((((downx$3.s0._0.__thread_id_z + downy$3.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy$2.stride.2)) + ((int64((max(downx$3.s0.t103640.s, 0) - downy$2.y.min_realized))*int64((downy$2.x.extent_realized.s + -15))) + int64((max(min(likely((((downx$3.s0.x.__thread_id_x + downy$3.s0.x.x_i.base)*2) + -1)), ((left_im.extent.0/8) + -1)), 0) - downy$2.x.min_realized)))))] + ((downy$2[((int64(downx$3.s0._1)*int64((max(slices, 2)*downy$2.stride.2))) + ((int64((((downx$3.s0._0.__thread_id_z + downy$3.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy$2.stride.2)) + ((int64((max(downx$3.s0.t103640.s, 0) - downy$2.y.min_realized))*int64((downy$2.x.extent_realized.s + -15))) + int64((max(min(likely(((downx$3.s0.x.__thread_id_x + downy$3.s0.x.x_i.base)*2)), ((left_im.extent.0/8) + -1)), 0) - downy$2.x.min_realized)))))] + downy$2[((int64(downx$3.s0._1)*int64((max(slices, 2)*downy$2.stride.2))) + ((int64((((downx$3.s0._0.__thread_id_z + downy$3.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy$2.stride.2)) + ((int64((max(downx$3.s0.t103640.s, 0) - downy$2.y.min_realized))*int64((downy$2.x.extent_realized.s + -15))) + int64((max(min(likely((((downx$3.s0.x.__thread_id_x + downy$3.s0.x.x_i.base)*2) + 1)), ((left_im.extent.0/8) + -1)), 0) - downy$2.x.min_realized)))))])*3.000000f)))*0.125000f))
                    }
                  }
                }
              }
            }
            consume downx$3 {
              gpu_thread<CUDA> (downy$3.s0._0._0_i.__thread_id_z, 0, 2) {
                gpu_thread<CUDA> (downy$3.s0.y.y_i.__thread_id_y, 0, 14) {
                  gpu_thread<CUDA> (downy$3.s0.x.x_i.__thread_id_x, 0, 8) {
                    for (downy$3.s0._1, 0, 2) {
                      downy$3[((int64(downy$3.s0._1)*int64((max(slices, 2)*downy$3.stride.2))) + ((int64((((downy$3.s0._0._0_i.__thread_id_z + downy$3.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy$3.stride.2)) + ((int64(((downy$3.s0.y.y_i.__thread_id_y + downy$3.s0.y.y_i.base) - downy$3.y.min_realized))*int64((downy$3.x.extent_realized.s + 1))) + int64(((downy$3.s0.x.x_i.__thread_id_x + downy$3.s0.x.x_i.base) - downy$3.x.min_realized)))))] = ((downx$3[(((int64(downy$3.s0._1)*(int64)480) + ((int64(downy$3.s0._0._0_i.__thread_id_z)*(int64)240) + ((int64(((downy$3.s0.y.y_i.__thread_id_y*2) + 1))*(int64)8) + int64(downy$3.s0.x.x_i.__thread_id_x)))) + (int64)16)] + (downx$3[(((int64(downy$3.s0._1)*(int64)480) + ((int64(downy$3.s0._0._0_i.__thread_id_z)*(int64)240) + ((int64(((downy$3.s0.y.y_i.__thread_id_y*2) + 1))*(int64)8) + int64(downy$3.s0.x.x_i.__thread_id_x)))) + (int64)-8)] + ((downx$3[((int64(downy$3.s0._1)*(int64)480) + ((int64(downy$3.s0._0._0_i.__thread_id_z)*(int64)240) + ((int64(((downy$3.s0.y.y_i.__thread_id_y*2) + 1))*(int64)8) + int64(downy$3.s0.x.x_i.__thread_id_x))))] + downx$3[(((int64(downy$3.s0._1)*(int64)480) + ((int64(downy$3.s0._0._0_i.__thread_id_z)*(int64)240) + ((int64(((downy$3.s0.y.y_i.__thread_id_y*2) + 1))*(int64)8) + int64(downy$3.s0.x.x_i.__thread_id_x)))) + (int64)8)])*3.000000f)))*0.125000f)
                    }
                  }
                }
              }
            }
          }
        }
      }
      _halide_buffer_set_device_dirty(downy$3.buffer, (uint1)1)
    }
  }
  let downy$4.y.min_realized = min(max(downy$4.s0.y.min.s, 0), min(min(max(((min(min((argmin.s1.y.min + 101), argmin.s1.y.max.s), (left_im.extent.1 + 131)) + -163)/32), 0), (max(min((left_im.extent.1/32), ((min(max(downy$5.s0.y.min.s, 1), downy$5.s0.y.max)*2) + -2)), 1) + -1)), (max(downy$4.s0.y.max.s, 0) + -13)))
  let downy$4.y.extent_realized.s = (max(max(min(min(((argmin.s1.y.max.s + 61)/32), (((argmin.s1.y.min + 162)/32) + (((((argmin.s1.y.max.s + 61)/32) - ((argmin.s1.y.min + -62)/32))/8)*8))), ((left_im.extent.1/32) + -1)), (max(min((left_im.extent.1/32), ((min((max(downy$5.s0.y.min.s, 1) + ((((downy$5.s0.y.max - max(downy$5.s0.y.min.s, 1)) + 1)/2)*2)), downy$5.s0.y.max)*2) + 3)), 1) + -1)), min(max(downy$4.s0.y.max.s, 0), ((max(downy$4.s0.y.min.s, 0) + (((max(downy$4.s0.y.max.s, 0) - max(downy$4.s0.y.min.s, 0))/14)*14)) + 13))) - downy$4.y.min_realized)
  let downy$4.x.min_realized = min((min((min(max(min((downy$5.s0.x.min.s*2), ((left_im.extent.0/32) + 3)), 4), (max(min(min(((min((argmin.s1.x.min + 53), argmin.s1.x.max.s) + -83)/32), ((downy$5.s0.x.min.s*2) + -4)), (left_im.extent.0/32)), 1) + 3)) + 7), downy$4.s0.x.max.s) + -11), downy$4.s0.x.min)
  let downy$4.x.extent_realized.s = (max(max(min((downy$5.s0.x.max.s*2), ((left_im.extent.0/32) + 3)), (max(min((left_im.extent.0/32), (max((min(((argmin.s1.x.max.s + 29)/16), (((argmin.s1.x.min + 82)/16) + (((((argmin.s1.x.max.s + 29)/16) - ((argmin.s1.x.min + -30)/16))/8)*8)))/2), ((downy$5.s0.x.max.s*2) + -3)) + 2)), 1) + 3)), min(((((((downy$4.s0.x.max.s - downy$4.s0.x.min) + -4)/8)*8) + downy$4.s0.x.min) + 11), downy$4.s0.x.max.s)) - downy$4.x.min_realized)
  let downy$4.stride.2 = ((downy$4.x.extent_realized.s + -3)*(downy$4.y.extent_realized.s + 1))
  allocate downy$4[float32 * (downy$4.x.extent_realized.s + -3) * (downy$4.y.extent_realized.s + 1) * max(slices, 2) * 2] if (uint1)0
  let downy$4.buffer = (let t104135 = make_struct((halide_dimension_t *), downy$4.x.min_realized, (downy$4.x.extent_realized.s + -3), 1, 0, downy$4.y.min_realized, (downy$4.y.extent_realized.s + 1), (downy$4.x.extent_realized.s + -3), 0, (min(slices, 2) + -2), max(slices, 2), downy$4.stride.2, 0, 0, 2, (max(slices, 2)*downy$4.stride.2), 0) in _halide_buffer_init(alloca(size_of_halide_buffer_t()), t104135, reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 4, t104135, (uint64)0))
  register_destructor("halide_device_free_as_destructor", downy$4.buffer)
  let downy$4.s0.y.y_o.loop_extent.s = (max(downy$4.s0.y.max.s, 0) - max(downy$4.s0.y.min.s, 0))
  produce downy$4 {
    consume downy$3 {
      let halide_device_malloc_result$7 = halide_device_malloc(downy$4.buffer, halide_cuda_device_interface())
      assert((halide_device_malloc_result$7 == 0), halide_device_malloc_result$7)
      gpu_block<CUDA> (downy$4.s0._0._0_o.__block_id_z, 0, ((slices + 1)/2)) {
        let downy$4.s0._0._0_i.base = min(likely_if_innermost((downy$4.s0._0._0_o.__block_id_z*2)), (slices + -2))
        gpu_block<CUDA> (downy$4.s0.y.y_o.__block_id_y, 0, ((downy$4.s0.y.y_o.loop_extent.s/14) + 1)) {
          let downy$4.s0.y.y_i.base = min(likely_if_innermost((max(downy$4.s0.y.min.s, 0) + (downy$4.s0.y.y_o.__block_id_y*14))), (max(downy$4.s0.y.max.s, 0) + -13))
          gpu_block<CUDA> (downy$4.s0.x.x_o.__block_id_x, 0, (((downy$4.s0.x.max.s - downy$4.s0.x.min) + 4)/8)) {
            let downy$4.s0.x.x_i.base = min(likely_if_innermost(((downy$4.s0.x.x_o.__block_id_x*8) + downy$4.s0.x.min)), (downy$4.s0.x.max.s + -11))
            allocate downx$4[float32 * 8 * 30 * 2 * 2]
            produce downx$4 {
              gpu_thread<CUDA> (downx$4.s0._0.__thread_id_z, 0, 2) {
                gpu_thread<CUDA> (downx$4.s0.y.__thread_id_y, 0, 30) {
                  gpu_thread<CUDA> (downx$4.s0.x.__thread_id_x, 0, 8) {
                    for (downx$4.s0._1, 0, 2) {
                      downx$4[((int64(downx$4.s0._1)*(int64)480) + ((int64(downx$4.s0._0.__thread_id_z)*(int64)240) + ((int64(downx$4.s0.y.__thread_id_y)*(int64)8) + int64(downx$4.s0.x.__thread_id_x))))] = (let downx$4.s0.t103641.s = min(likely((((downy$4.s0.y.y_i.base*2) + downx$4.s0.y.__thread_id_y) + -1)), ((left_im.extent.1/16) + -1)) in ((downy$3[((int64(downx$4.s0._1)*int64((max(slices, 2)*downy$3.stride.2))) + ((int64((((downx$4.s0._0.__thread_id_z + downy$4.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy$3.stride.2)) + ((int64((max(downx$4.s0.t103641.s, 0) - downy$3.y.min_realized))*int64((downy$3.x.extent_realized.s + 1))) + int64((max(min(likely((((downx$4.s0.x.__thread_id_x + downy$4.s0.x.x_i.base)*2) + 2)), ((left_im.extent.0/16) + -1)), 0) - downy$3.x.min_realized)))))] + (downy$3[((int64(downx$4.s0._1)*int64((max(slices, 2)*downy$3.stride.2))) + ((int64((((downx$4.s0._0.__thread_id_z + downy$4.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy$3.stride.2)) + ((int64((max(downx$4.s0.t103641.s, 0) - downy$3.y.min_realized))*int64((downy$3.x.extent_realized.s + 1))) + int64((max(min(likely((((downx$4.s0.x.__thread_id_x + downy$4.s0.x.x_i.base)*2) + -1)), ((left_im.extent.0/16) + -1)), 0) - downy$3.x.min_realized)))))] + ((downy$3[((int64(downx$4.s0._1)*int64((max(slices, 2)*downy$3.stride.2))) + ((int64((((downx$4.s0._0.__thread_id_z + downy$4.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy$3.stride.2)) + ((int64((max(downx$4.s0.t103641.s, 0) - downy$3.y.min_realized))*int64((downy$3.x.extent_realized.s + 1))) + int64((max(min(likely(((downx$4.s0.x.__thread_id_x + downy$4.s0.x.x_i.base)*2)), ((left_im.extent.0/16) + -1)), 0) - downy$3.x.min_realized)))))] + downy$3[((int64(downx$4.s0._1)*int64((max(slices, 2)*downy$3.stride.2))) + ((int64((((downx$4.s0._0.__thread_id_z + downy$4.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy$3.stride.2)) + ((int64((max(downx$4.s0.t103641.s, 0) - downy$3.y.min_realized))*int64((downy$3.x.extent_realized.s + 1))) + int64((max(min(likely((((downx$4.s0.x.__thread_id_x + downy$4.s0.x.x_i.base)*2) + 1)), ((left_im.extent.0/16) + -1)), 0) - downy$3.x.min_realized)))))])*3.000000f)))*0.125000f))
                    }
                  }
                }
              }
            }
            consume downx$4 {
              gpu_thread<CUDA> (downy$4.s0._0._0_i.__thread_id_z, 0, 2) {
                gpu_thread<CUDA> (downy$4.s0.y.y_i.__thread_id_y, 0, 14) {
                  gpu_thread<CUDA> (downy$4.s0.x.x_i.__thread_id_x, 0, 8) {
                    for (downy$4.s0._1, 0, 2) {
                      downy$4[((int64(downy$4.s0._1)*int64((max(slices, 2)*downy$4.stride.2))) + ((int64((((downy$4.s0._0._0_i.__thread_id_z + downy$4.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy$4.stride.2)) + ((int64(((downy$4.s0.y.y_i.__thread_id_y + downy$4.s0.y.y_i.base) - downy$4.y.min_realized))*int64((downy$4.x.extent_realized.s + -3))) + int64(((downy$4.s0.x.x_i.__thread_id_x + downy$4.s0.x.x_i.base) - downy$4.x.min_realized)))))] = ((downx$4[(((int64(downy$4.s0._1)*(int64)480) + ((int64(downy$4.s0._0._0_i.__thread_id_z)*(int64)240) + ((int64(((downy$4.s0.y.y_i.__thread_id_y*2) + 1))*(int64)8) + int64(downy$4.s0.x.x_i.__thread_id_x)))) + (int64)16)] + (downx$4[(((int64(downy$4.s0._1)*(int64)480) + ((int64(downy$4.s0._0._0_i.__thread_id_z)*(int64)240) + ((int64(((downy$4.s0.y.y_i.__thread_id_y*2) + 1))*(int64)8) + int64(downy$4.s0.x.x_i.__thread_id_x)))) + (int64)-8)] + ((downx$4[((int64(downy$4.s0._1)*(int64)480) + ((int64(downy$4.s0._0._0_i.__thread_id_z)*(int64)240) + ((int64(((downy$4.s0.y.y_i.__thread_id_y*2) + 1))*(int64)8) + int64(downy$4.s0.x.x_i.__thread_id_x))))] + downx$4[(((int64(downy$4.s0._1)*(int64)480) + ((int64(downy$4.s0._0._0_i.__thread_id_z)*(int64)240) + ((int64(((downy$4.s0.y.y_i.__thread_id_y*2) + 1))*(int64)8) + int64(downy$4.s0.x.x_i.__thread_id_x)))) + (int64)8)])*3.000000f)))*0.125000f)
                    }
                  }
                }
              }
            }
          }
        }
      }
      _halide_buffer_set_device_dirty(downy$4.buffer, (uint1)1)
    }
  }
  let downy$5.y.min_realized = min(max(((min(min((argmin.s1.y.min + 101), argmin.s1.y.max.s), (left_im.extent.1 + 99)) + -163)/64), 0), (min(max(downy$5.s0.y.min.s, 1), min(max(min(min(((min((argmin.s1.y.min + 101), argmin.s1.y.max.s) + -163)/64), (min(max(((downy$6.s0.y.min.s + -254)/128), 0), (max((downy$6.s0.y.max.s/128), 1) + -3))*2)), (left_im.extent.1/64)), 1), downy$5.s0.y.max)) + -1))
  let downy$5.y.extent_realized.s = (max(max(min((min(((argmin.s1.y.max.s + 61)/32), (((argmin.s1.y.min + 162)/32) + (((((argmin.s1.y.max.s + 61)/32) - ((argmin.s1.y.min + -62)/32))/8)*8)))/2), ((left_im.extent.1/64) + -1)), (max(min((left_im.extent.1/64), (max((min(((argmin.s1.y.max.s + 61)/32), (((argmin.s1.y.min + 162)/32) + (((((argmin.s1.y.max.s + 61)/32) - ((argmin.s1.y.min + -62)/32))/8)*8)))/2), ((min(max((downy$6.s0.y.max.s/128), 1), ((max(((downy$6.s0.y.min.s + -254)/128), 0) + ((((max((downy$6.s0.y.max.s/128), 1) - max(((downy$6.s0.y.min.s + -254)/128), 0)) + -1)/3)*3)) + 3))*2) + -1)) + 2)), 1) + -1)), min((max(downy$5.s0.y.min.s, 1) + ((((downy$5.s0.y.max - max(downy$5.s0.y.min.s, 1)) + 1)/2)*2)), downy$5.s0.y.max)) - downy$5.y.min_realized)
  let downy$5.x.min_realized = min(min(max(((min(min((argmin.s1.x.min + 53), argmin.s1.x.max.s), (left_im.extent.0 + 51)) + -115)/64), 0), min(max(((min(min((argmin.s1.x.min + 53), argmin.s1.x.max.s), (left_im.extent.0 + 115)) + -179)/64), 0), min(max(((min(min((argmin.s1.x.min + 53), argmin.s1.x.max.s), (left_im.extent.0 + 51)) + -115)/64), 0), min(max(((min(min((argmin.s1.x.min + 53), argmin.s1.x.max.s), (left_im.extent.0 + 115)) + -179)/64), 0), (min(max(min((min(max((downy$6.s0.x.max.s/128), 1), (max((downy$6.s0.x.min.s/128), 1) + 2))*2), ((left_im.extent.0/64) + 5)), 6), (max(min((left_im.extent.0/64), ((min(max((downy$6.s0.x.max.s/128), 1), (max((downy$6.s0.x.min.s/128), 1) + 2))*2) + -6)), 1) + 5)) + -6))))), (downy$5.s0.x.min.s + -2))
  let downy$5.x.extent_realized.s = (max(max(max(min(((min(((argmin.s1.x.max.s + 29)/16), (((argmin.s1.x.min + 82)/16) + (((((argmin.s1.x.max.s + 29)/16) - ((argmin.s1.x.min + -30)/16))/8)*8))) + 6)/4), ((left_im.extent.0/64) + -1)), (max(min((min(max((downy$6.s0.x.max.s/128), 1), ((max((downy$6.s0.x.min.s/128), 1) + (((max((downy$6.s0.x.max.s/128), 1) - max((downy$6.s0.x.min.s/128), 1))/3)*3)) + 2))*2), ((left_im.extent.0/64) + 1)), (max(min((left_im.extent.0/64), ((min(max((downy$6.s0.x.max.s/128), 1), ((max((downy$6.s0.x.min.s/128), 1) + (((max((downy$6.s0.x.max.s/128), 1) - max((downy$6.s0.x.min.s/128), 1))/3)*3)) + 2))*2) + 1)), 1) + 1)) + -2)), min(((min(((argmin.s1.x.max.s + 29)/16), (((argmin.s1.x.min + 82)/16) + (((((argmin.s1.x.max.s + 29)/16) - ((argmin.s1.x.min + -30)/16))/8)*8))) + 2)/4), ((left_im.extent.0/64) + -1))), (downy$5.s0.x.max.s + -2)) - downy$5.x.min_realized)
  let downy$5.stride.2 = ((downy$5.x.extent_realized.s + 1)*(downy$5.y.extent_realized.s + 1))
  allocate downy$5[float32 * (downy$5.x.extent_realized.s + 1) * (downy$5.y.extent_realized.s + 1) * max(slices, 4) * 2] if (uint1)0
  let downy$5.buffer = (let t104134 = make_struct((halide_dimension_t *), downy$5.x.min_realized, (downy$5.x.extent_realized.s + 1), 1, 0, downy$5.y.min_realized, (downy$5.y.extent_realized.s + 1), (downy$5.x.extent_realized.s + 1), 0, (min(slices, 4) + -4), max(slices, 4), downy$5.stride.2, 0, 0, 2, (max(slices, 4)*downy$5.stride.2), 0) in _halide_buffer_init(alloca(size_of_halide_buffer_t()), t104134, reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 4, t104134, (uint64)0))
  register_destructor("halide_device_free_as_destructor", downy$5.buffer)
  let downy$5.s0.y.y_o.loop_extent.s = (downy$5.s0.y.max - max(downy$5.s0.y.min.s, 1))
  produce downy$5 {
    consume downy$4 {
      let halide_device_malloc_result$6 = halide_device_malloc(downy$5.buffer, halide_cuda_device_interface())
      assert((halide_device_malloc_result$6 == 0), halide_device_malloc_result$6)
      gpu_block<CUDA> (downy$5.s0._0._0_o.__block_id_y, 0, ((slices + 1)/2)) {
        let downy$5.s0._0._0_i.base = min(likely_if_innermost((downy$5.s0._0._0_o.__block_id_y*2)), (slices + -2))
        gpu_block<CUDA> (downy$5.s0.y.y_o.__block_id_x, 0, ((downy$5.s0.y.y_o.loop_extent.s + 3)/2)) {
          let downy$5.s0.y.y_i.base = min(likely_if_innermost(((max(downy$5.s0.y.min.s, 1) + (downy$5.s0.y.y_o.__block_id_x*2)) + -1)), (downy$5.s0.y.max + -1))
          for (downy$5.s0.x, (downy$5.s0.x.min.s + -2), ((downy$5.s0.x.max.s - downy$5.s0.x.min.s) + 1)) {
            allocate downx$5[float32 * 1 * 6 * 2 * 2]
            produce downx$5 {
              gpu_thread<CUDA> (downx$5.s0._0.__thread_id_y, 0, 2) {
                gpu_thread<CUDA> (downx$5.s0.y.__thread_id_x, 0, 6) {
                  for (downx$5.s0._1, 0, 2) {
                    downx$5[((int64(downx$5.s0._1)*(int64)12) + ((int64(downx$5.s0._0.__thread_id_y)*(int64)6) + int64(downx$5.s0.y.__thread_id_x)))] = (let downx$5.s0.t103642.s = min(likely((((downy$5.s0.y.y_i.base*2) + downx$5.s0.y.__thread_id_x) + -1)), ((left_im.extent.1/32) + -1)) in ((downy$4[((int64(downx$5.s0._1)*int64((max(slices, 2)*downy$4.stride.2))) + ((int64((((downx$5.s0._0.__thread_id_y + downy$5.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy$4.stride.2)) + ((int64((max(downx$5.s0.t103642.s, 0) - downy$4.y.min_realized))*int64((downy$4.x.extent_realized.s + -3))) + int64((max(min(likely(((downy$5.s0.x*2) + 2)), ((left_im.extent.0/32) + -1)), 0) - downy$4.x.min_realized)))))] + (downy$4[((int64(downx$5.s0._1)*int64((max(slices, 2)*downy$4.stride.2))) + ((int64((((downx$5.s0._0.__thread_id_y + downy$5.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy$4.stride.2)) + ((int64((max(downx$5.s0.t103642.s, 0) - downy$4.y.min_realized))*int64((downy$4.x.extent_realized.s + -3))) + int64((max(min(likely(((downy$5.s0.x*2) + -1)), ((left_im.extent.0/32) + -1)), 0) - downy$4.x.min_realized)))))] + ((downy$4[((int64(downx$5.s0._1)*int64((max(slices, 2)*downy$4.stride.2))) + ((int64((((downx$5.s0._0.__thread_id_y + downy$5.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy$4.stride.2)) + ((int64((max(downx$5.s0.t103642.s, 0) - downy$4.y.min_realized))*int64((downy$4.x.extent_realized.s + -3))) + int64((max(min(likely((downy$5.s0.x*2)), ((left_im.extent.0/32) + -1)), 0) - downy$4.x.min_realized)))))] + downy$4[((int64(downx$5.s0._1)*int64((max(slices, 2)*downy$4.stride.2))) + ((int64((((downx$5.s0._0.__thread_id_y + downy$5.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(downy$4.stride.2)) + ((int64((max(downx$5.s0.t103642.s, 0) - downy$4.y.min_realized))*int64((downy$4.x.extent_realized.s + -3))) + int64((max(min(likely(((downy$5.s0.x*2) + 1)), ((left_im.extent.0/32) + -1)), 0) - downy$4.x.min_realized)))))])*3.000000f)))*0.125000f))
                  }
                }
              }
            }
            consume downx$5 {
              gpu_thread<CUDA> (downy$5.s0._0._0_i.__thread_id_y, 0, 2) {
                gpu_thread<CUDA> (downy$5.s0.y.y_i.__thread_id_x, 0, 2) {
                  for (downy$5.s0._1, 0, 2) {
                    downy$5[((int64(downy$5.s0._1)*int64((max(slices, 4)*downy$5.stride.2))) + ((int64((((downy$5.s0._0._0_i.__thread_id_y + downy$5.s0._0._0_i.base) - min(slices, 4)) + 4))*int64(downy$5.stride.2)) + ((int64(((downy$5.s0.y.y_i.__thread_id_x + downy$5.s0.y.y_i.base) - downy$5.y.min_realized))*int64((downy$5.x.extent_realized.s + 1))) + int64((downy$5.s0.x - downy$5.x.min_realized)))))] = ((downx$5[(((int64(downy$5.s0._1)*(int64)12) + ((int64(downy$5.s0._0._0_i.__thread_id_y)*(int64)6) + int64(((downy$5.s0.y.y_i.__thread_id_x*2) + 1)))) + (int64)2)] + (downx$5[(((int64(downy$5.s0._1)*(int64)12) + ((int64(downy$5.s0._0._0_i.__thread_id_y)*(int64)6) + int64(((downy$5.s0.y.y_i.__thread_id_x*2) + 1)))) + (int64)-1)] + ((downx$5[((int64(downy$5.s0._1)*(int64)12) + ((int64(downy$5.s0._0._0_i.__thread_id_y)*(int64)6) + int64(((downy$5.s0.y.y_i.__thread_id_x*2) + 1))))] + downx$5[(((int64(downy$5.s0._1)*(int64)12) + ((int64(downy$5.s0._0._0_i.__thread_id_y)*(int64)6) + int64(((downy$5.s0.y.y_i.__thread_id_x*2) + 1)))) + (int64)1)])*3.000000f)))*0.125000f)
                  }
                }
              }
            }
          }
        }
      }
      _halide_buffer_set_device_dirty(downy$5.buffer, (uint1)1)
    }
  }
  let downy$6._0.min_realized.s = diff.z.min_realized.s
  let downy$6.y.min_realized = min(max(((min(min((argmin.s1.y.min + 101), argmin.s1.y.max.s), (left_im.extent.1 + 227)) + -355)/128), 0), min(max(((downy$6.s0.y.min.s + -254)/128), 0), (max((downy$6.s0.y.max.s/128), 1) + -3)))
  let downy$6.y.extent_realized.s = (max(max(min(((min(((argmin.s1.y.max.s + 61)/32), (((argmin.s1.y.min + 162)/32) + (((((argmin.s1.y.max.s + 61)/32) - ((argmin.s1.y.min + -62)/32))/8)*8))) + 6)/4), ((left_im.extent.1/128) + -1)), (min(max((downy$6.s0.y.max.s/128), 1), ((max(((downy$6.s0.y.min.s + -254)/128), 0) + ((((max((downy$6.s0.y.max.s/128), 1) - max(((downy$6.s0.y.min.s + -254)/128), 0)) + -1)/3)*3)) + 3)) + -1)), 0) - downy$6.y.min_realized)
  let downy$6.x.min_realized = min(max(((min(min((argmin.s1.x.min + 53), argmin.s1.x.max.s), (left_im.extent.0 + 179)) + -307)/128), 0), (min(max((downy$6.s0.x.max.s/128), 1), (max((downy$6.s0.x.min.s/128), 1) + 2)) + -3))
  let downy$6.x.extent_realized.s = (max(max(min(((min(((argmin.s1.x.max.s + 29)/16), (((argmin.s1.x.min + 82)/16) + (((((argmin.s1.x.max.s + 29)/16) - ((argmin.s1.x.min + -30)/16))/8)*8))) + 14)/8), ((left_im.extent.0/128) + -1)), (min(max((downy$6.s0.x.max.s/128), 1), ((max((downy$6.s0.x.min.s/128), 1) + (((max((downy$6.s0.x.max.s/128), 1) - max((downy$6.s0.x.min.s/128), 1))/3)*3)) + 2)) + -1)), 0) - downy$6.x.min_realized)
  let downy$6.stride.2 = ((downy$6.x.extent_realized.s + 1)*(downy$6.y.extent_realized.s + 1))
  allocate downy$6[float32 * (downy$6.x.extent_realized.s + 1) * (downy$6.y.extent_realized.s + 1) * max(slices, 4) * 2] if (uint1)0
  let downy$6.buffer = (let t104133 = make_struct((halide_dimension_t *), downy$6.x.min_realized, (downy$6.x.extent_realized.s + 1), 1, 0, downy$6.y.min_realized, (downy$6.y.extent_realized.s + 1), (downy$6.x.extent_realized.s + 1), 0, (downy$6._0.min_realized.s + -4), max(slices, 4), downy$6.stride.2, 0, 0, 2, (max(slices, 4)*downy$6.stride.2), 0) in _halide_buffer_init(alloca(size_of_halide_buffer_t()), t104133, reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 4, t104133, (uint64)0))
  register_destructor("halide_device_free_as_destructor", downy$6.buffer)
  let downy$6.s0.x.x_o.loop_extent.s = (max((downy$6.s0.x.max.s/128), 1) - max((downy$6.s0.x.min.s/128), 1))
  let downy$6.s0.y.y_o.loop_extent.s = (max((downy$6.s0.y.max.s/128), 1) - max(((downy$6.s0.y.min.s + -254)/128), 0))
  produce downy$6 {
    consume downy$5 {
      let halide_device_malloc_result$5 = halide_device_malloc(downy$6.buffer, halide_cuda_device_interface())
      assert((halide_device_malloc_result$5 == 0), halide_device_malloc_result$5)
      gpu_block<CUDA> (downy$6.s0._0._0_o.__block_id_z, 0, ((slices + 3)/4)) {
        let downy$6.s0._0._0_i.base = min(likely_if_innermost((downy$6.s0._0._0_o.__block_id_z*4)), (slices + -4))
        gpu_block<CUDA> (downy$6.s0.y.y_o.__block_id_y, 0, ((downy$6.s0.y.y_o.loop_extent.s + 2)/3)) {
          let downy$6.s0.y.y_i.base = min(likely_if_innermost((max(((downy$6.s0.y.min.s + -254)/128), 0) + (downy$6.s0.y.y_o.__block_id_y*3))), (max((downy$6.s0.y.max.s/128), 1) + -3))
          gpu_block<CUDA> (downy$6.s0.x.x_o.__block_id_x, 0, ((downy$6.s0.x.x_o.loop_extent.s/3) + 1)) {
            let downy$6.s0.x.x_i.base = min(likely_if_innermost(((max((downy$6.s0.x.min.s/128), 1) + (downy$6.s0.x.x_o.__block_id_x*3)) + -1)), (max((downy$6.s0.x.max.s/128), 1) + -3))
            allocate downx$6[float32 * 3 * 8 * 4 * 2]
            produce downx$6 {
              gpu_thread<CUDA> (downx$6.s0._0.__thread_id_z, 0, 4) {
                gpu_thread<CUDA> (downx$6.s0.y.__thread_id_y, 0, 8) {
                  gpu_thread<CUDA> (downx$6.s0.x.__thread_id_x, 0, 3) {
                    for (downx$6.s0._1, 0, 2) {
                      downx$6[((int64(downx$6.s0._1)*(int64)96) + ((int64(downx$6.s0._0.__thread_id_z)*(int64)24) + ((int64(downx$6.s0.y.__thread_id_y)*(int64)3) + int64(downx$6.s0.x.__thread_id_x))))] = (let downx$6.s0.t103643.s = min(likely((((downy$6.s0.y.y_i.base*2) + downx$6.s0.y.__thread_id_y) + -1)), ((left_im.extent.1/64) + -1)) in ((downy$5[((int64(downx$6.s0._1)*int64((max(slices, 4)*downy$5.stride.2))) + ((int64((((downx$6.s0._0.__thread_id_z + downy$6.s0._0._0_i.base) - min(slices, 4)) + 4))*int64(downy$5.stride.2)) + ((int64((max(downx$6.s0.t103643.s, 0) - downy$5.y.min_realized))*int64((downy$5.x.extent_realized.s + 1))) + int64((max(min(likely((((downx$6.s0.x.__thread_id_x + downy$6.s0.x.x_i.base)*2) + 2)), ((left_im.extent.0/64) + -1)), 0) - downy$5.x.min_realized)))))] + (downy$5[((int64(downx$6.s0._1)*int64((max(slices, 4)*downy$5.stride.2))) + ((int64((((downx$6.s0._0.__thread_id_z + downy$6.s0._0._0_i.base) - min(slices, 4)) + 4))*int64(downy$5.stride.2)) + ((int64((max(downx$6.s0.t103643.s, 0) - downy$5.y.min_realized))*int64((downy$5.x.extent_realized.s + 1))) + int64((max(min(likely((((downx$6.s0.x.__thread_id_x + downy$6.s0.x.x_i.base)*2) + -1)), ((left_im.extent.0/64) + -1)), 0) - downy$5.x.min_realized)))))] + ((downy$5[((int64(downx$6.s0._1)*int64((max(slices, 4)*downy$5.stride.2))) + ((int64((((downx$6.s0._0.__thread_id_z + downy$6.s0._0._0_i.base) - min(slices, 4)) + 4))*int64(downy$5.stride.2)) + ((int64((max(downx$6.s0.t103643.s, 0) - downy$5.y.min_realized))*int64((downy$5.x.extent_realized.s + 1))) + int64((max(min(likely(((downx$6.s0.x.__thread_id_x + downy$6.s0.x.x_i.base)*2)), ((left_im.extent.0/64) + -1)), 0) - downy$5.x.min_realized)))))] + downy$5[((int64(downx$6.s0._1)*int64((max(slices, 4)*downy$5.stride.2))) + ((int64((((downx$6.s0._0.__thread_id_z + downy$6.s0._0._0_i.base) - min(slices, 4)) + 4))*int64(downy$5.stride.2)) + ((int64((max(downx$6.s0.t103643.s, 0) - downy$5.y.min_realized))*int64((downy$5.x.extent_realized.s + 1))) + int64((max(min(likely((((downx$6.s0.x.__thread_id_x + downy$6.s0.x.x_i.base)*2) + 1)), ((left_im.extent.0/64) + -1)), 0) - downy$5.x.min_realized)))))])*3.000000f)))*0.125000f))
                    }
                  }
                }
              }
            }
            consume downx$6 {
              gpu_thread<CUDA> (downy$6.s0._0._0_i.__thread_id_z, 0, 4) {
                gpu_thread<CUDA> (downy$6.s0.y.y_i.__thread_id_y, 0, 3) {
                  gpu_thread<CUDA> (downy$6.s0.x.x_i.__thread_id_x, 0, 3) {
                    for (downy$6.s0._1, 0, 2) {
                      downy$6[((int64(downy$6.s0._1)*int64((max(slices, 4)*downy$6.stride.2))) + ((int64((((downy$6.s0._0._0_i.__thread_id_z + downy$6.s0._0._0_i.base) - downy$6._0.min_realized.s) + 4))*int64(downy$6.stride.2)) + ((int64(((downy$6.s0.y.y_i.__thread_id_y + downy$6.s0.y.y_i.base) - downy$6.y.min_realized))*int64((downy$6.x.extent_realized.s + 1))) + int64(((downy$6.s0.x.x_i.__thread_id_x + downy$6.s0.x.x_i.base) - downy$6.x.min_realized)))))] = ((downx$6[(((int64(downy$6.s0._1)*(int64)96) + ((int64(downy$6.s0._0._0_i.__thread_id_z)*(int64)24) + ((int64(((downy$6.s0.y.y_i.__thread_id_y*2) + 1))*(int64)3) + int64(downy$6.s0.x.x_i.__thread_id_x)))) + (int64)6)] + (downx$6[(((int64(downy$6.s0._1)*(int64)96) + ((int64(downy$6.s0._0._0_i.__thread_id_z)*(int64)24) + ((int64(((downy$6.s0.y.y_i.__thread_id_y*2) + 1))*(int64)3) + int64(downy$6.s0.x.x_i.__thread_id_x)))) + (int64)-3)] + ((downx$6[((int64(downy$6.s0._1)*(int64)96) + ((int64(downy$6.s0._0._0_i.__thread_id_z)*(int64)24) + ((int64(((downy$6.s0.y.y_i.__thread_id_y*2) + 1))*(int64)3) + int64(downy$6.s0.x.x_i.__thread_id_x))))] + downx$6[(((int64(downy$6.s0._1)*(int64)96) + ((int64(downy$6.s0._0._0_i.__thread_id_z)*(int64)24) + ((int64(((downy$6.s0.y.y_i.__thread_id_y*2) + 1))*(int64)3) + int64(downy$6.s0.x.x_i.__thread_id_x)))) + (int64)3)])*3.000000f)))*0.125000f)
                    }
                  }
                }
              }
            }
          }
        }
      }
      _halide_buffer_set_device_dirty(downy$6.buffer, (uint1)1)
    }
  }
  let upx$2.y.min_realized.s = min(min((argmin.s1.y.min + 101), argmin.s1.y.max.s), (min((argmin.s1.y.min + 49), argmin.s1.y.max.s) + 52))
  let upx$2.y.extent_realized.s = (max(min(((argmin.s1.y.max.s + 61)/32), (((argmin.s1.y.min + 162)/32) + (((((argmin.s1.y.max.s + 61)/32) - ((argmin.s1.y.min + -62)/32))/8)*8))), ((min(((argmin.s1.y.max.s + 5)/4), (((argmin.s1.y.min + 54)/4) + (((((argmin.s1.y.max.s + 5)/4) - ((argmin.s1.y.min + -6)/4))/16)*16))) + 14)/8)) - ((upx$2.y.min_realized.s + -163)/32))
  let upx$2.x.min_realized.s = min(min((argmin.s1.x.min + 53), argmin.s1.x.max.s), (min((argmin.s1.x.min + 49), argmin.s1.x.max.s) + 4))
  let upx$2.x.extent_realized.s = (max(min(((argmin.s1.x.max.s + 29)/16), (((argmin.s1.x.min + 82)/16) + (((((argmin.s1.x.max.s + 29)/16) - ((argmin.s1.x.min + -30)/16))/8)*8))), ((min(((argmin.s1.x.max.s + 5)/4), (((argmin.s1.x.min + 54)/4) + (((((argmin.s1.x.max.s + 5)/4) - ((argmin.s1.x.min + -6)/4))/16)*16))) + 6)/4)) - ((upx$2.x.min_realized.s + -83)/16))
  let upx$2.stride.2 = ((upx$2.x.extent_realized.s + 1)*(upx$2.y.extent_realized.s + 1))
  allocate upx$2[float32 * (upx$2.x.extent_realized.s + 1) * (upx$2.y.extent_realized.s + 1) * max(slices, 2) * 2] if (uint1)0
  let upx$2.buffer = (let t104132 = make_struct((halide_dimension_t *), ((upx$2.x.min_realized.s + -83)/16), (upx$2.x.extent_realized.s + 1), 1, 0, ((upx$2.y.min_realized.s + -163)/32), (upx$2.y.extent_realized.s + 1), (upx$2.x.extent_realized.s + 1), 0, (min(slices, 2) + -2), max(slices, 2), upx$2.stride.2, 0, 0, 2, (max(slices, 2)*upx$2.stride.2), 0) in _halide_buffer_init(alloca(size_of_halide_buffer_t()), t104132, reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 4, t104132, (uint64)0))
  register_destructor("halide_device_free_as_destructor", upx$2.buffer)
  let upx$2.s0.x.x_o.loop_extent.s = (((argmin.s1.x.max.s + 29)/16) - ((argmin.s1.x.min + -30)/16))
  let upx$2.s0.y.y_o.loop_extent.s = (((argmin.s1.y.max.s + 61)/32) - ((argmin.s1.y.min + -62)/32))
  produce upx$2 {
    consume downy$6 {
      consume downy$5 {
        consume downy$4 {
          let halide_device_malloc_result$4 = halide_device_malloc(upx$2.buffer, halide_cuda_device_interface())
          assert((halide_device_malloc_result$4 == 0), halide_device_malloc_result$4)
          gpu_block<CUDA> (upx$2.s0._0._0_o.__block_id_z, 0, ((slices + 1)/2)) {
            let upx$2.s0._0._0_i.base = min(likely_if_innermost((upx$2.s0._0._0_o.__block_id_z*2)), (slices + -2))
            gpu_block<CUDA> (upx$2.s0.y.y_o.__block_id_y, 0, ((upx$2.s0.y.y_o.loop_extent.s/8) + 1)) {
              let upx$2.s0.y.y_i.base = min(likely_if_innermost((((argmin.s1.y.min + -62)/32) + (upx$2.s0.y.y_o.__block_id_y*8))), ((argmin.s1.y.max.s + -163)/32))
              gpu_block<CUDA> (upx$2.s0.x.x_o.__block_id_x, 0, ((upx$2.s0.x.x_o.loop_extent.s/8) + 1)) {
                let upx$2.s0.x.x_i.base = min(likely_if_innermost((((argmin.s1.x.min + -30)/16) + (upx$2.s0.x.x_o.__block_id_x*8))), ((argmin.s1.x.max.s + -83)/16))
                let upx.stride.2 = (((((upx$2.s0.x.x_i.base + 2) % 4) + 23)/4)*((((upx$2.s0.y.y_i.base + 2) % 4) + 23)/4))
                allocate upx[float32 * ((((upx$2.s0.x.x_i.base + 2) % 4) + 23)/4) * ((((upx$2.s0.y.y_i.base + 2) % 4) + 23)/4) * 2 * 2]
                let upx.s0.y.__thread_id_y.loop_extent = (let t103827 = min(((argmin.s1.y.max.s + -163)/32), (((argmin.s1.y.min + -62)/32) + (upx$2.s0.y.y_o.__block_id_y*8))) in ((((t103827 + 2) % 4) + 23)/4))
                let upx.s0.x.__thread_id_x.loop_extent = (let t103839 = min(((argmin.s1.x.max.s + -83)/16), (((argmin.s1.x.min + -30)/16) + (upx$2.s0.x.x_o.__block_id_x*8))) in ((((t103839 + 2) % 4) + 23)/4))
                produce upx {
                  gpu_thread<CUDA> (upx.s0._0.__thread_id_z, 0, 2) {
                    gpu_thread<CUDA> (upx.s0.y.__thread_id_y, 0, upx.s0.y.__thread_id_y.loop_extent) {
                      gpu_thread<CUDA> (upx.s0.x.__thread_id_x, 0, upx.s0.x.__thread_id_x.loop_extent) {
                        for (upx.s0._1, 0, 2) {
                          upx[((int64(upx.s0._1)*int64((upx.stride.2*2))) + ((int64(upx.s0._0.__thread_id_z)*int64(upx.stride.2)) + ((int64(upx.s0.y.__thread_id_y)*int64(((((upx$2.s0.x.x_i.base + 2) % 4) + 23)/4))) + int64(upx.s0.x.__thread_id_x))))] = (let upx.s0.t103727.s = min(likely((((upx$2.s0.y.y_i.base + -6)/4) + upx.s0.y.__thread_id_y)), ((left_im.extent.1/128) + -1)) in ((downy$6[((int64(upx.s0._1)*int64((max(slices, 4)*downy$6.stride.2))) + ((int64((((upx$2.s0._0._0_i.base + upx.s0._0.__thread_id_z) - downy$6._0.min_realized.s) + 4))*int64(downy$6.stride.2)) + ((int64((max(upx.s0.t103727.s, 0) - downy$6.y.min_realized))*int64((downy$6.x.extent_realized.s + 1))) + int64((max(min(likely(((((((upx$2.s0.x.x_i.base + -6)/4) + upx.s0.x.__thread_id_x)/2) + (((((upx$2.s0.x.x_i.base + -6)/4) + upx.s0.x.__thread_id_x) % 2)*2)) + -1)), ((left_im.extent.0/128) + -1)), 0) - downy$6.x.min_realized)))))] + (downy$6[((int64(upx.s0._1)*int64((max(slices, 4)*downy$6.stride.2))) + ((int64((((upx$2.s0._0._0_i.base + upx.s0._0.__thread_id_z) - downy$6._0.min_realized.s) + 4))*int64(downy$6.stride.2)) + ((int64((max(upx.s0.t103727.s, 0) - downy$6.y.min_realized))*int64((downy$6.x.extent_realized.s + 1))) + int64((max(min(likely(((((upx$2.s0.x.x_i.base + -6)/4) + upx.s0.x.__thread_id_x)/2)), ((left_im.extent.0/128) + -1)), 0) - downy$6.x.min_realized)))))]*3.000000f))*0.250000f))
                        }
                      }
                    }
                  }
                }
                allocate cost_pyramid_pull[5][float32 * ((upx$2.s0.x.x_i.base % 2) + 6) * 8 * 2 * 2]
                let cost_pyramid_pull[5].s0.x.__thread_id_x.loop_extent = (let t103845 = min(((argmin.s1.x.max.s + -83)/16), (((argmin.s1.x.min + -30)/16) + (upx$2.s0.x.x_o.__block_id_x*8))) in ((t103845 % 2) + 6))
                produce cost_pyramid_pull[5] {
                  consume upx {
                    gpu_thread<CUDA> (cost_pyramid_pull[5].s0.y.__thread_id_y, 0, 8) {
                      gpu_thread<CUDA> (cost_pyramid_pull[5].s0.x.__thread_id_x, 0, cost_pyramid_pull[5].s0.x.__thread_id_x.loop_extent) {
                        for (cost_pyramid_pull[5].s0.z, upx$2.s0._0._0_i.base, 2) {
                          for (cost_pyramid_pull[5].s0.c, 0, 2) {
                            cost_pyramid_pull[5][((int64(cost_pyramid_pull[5].s0.c)*int64((((upx$2.s0.x.x_i.base % 2)*16) + 96))) + ((int64((cost_pyramid_pull[5].s0.z - upx$2.s0._0._0_i.base))*int64((((upx$2.s0.x.x_i.base % 2)*8) + 48))) + ((int64(cost_pyramid_pull[5].s0.y.__thread_id_y)*int64(((upx$2.s0.x.x_i.base % 2) + 6))) + int64(cost_pyramid_pull[5].s0.x.__thread_id_x))))] = (let cost_pyramid_pull[5].s0.t103719.s = (((cost_pyramid_pull[5].s0.y.__thread_id_y + upx$2.s0.y.y_i.base)/2) + (((cost_pyramid_pull[5].s0.y.__thread_id_y + upx$2.s0.y.y_i.base) % 2)*2)) in (let cost_pyramid_pull[5].s0.t103720.s = (((((upx$2.s0.x.x_i.base/2) + cost_pyramid_pull[5].s0.x.__thread_id_x) + -1)/2) + (((((upx$2.s0.x.x_i.base/2) + cost_pyramid_pull[5].s0.x.__thread_id_x) + 1) % 2)*2)) in (let cost_pyramid_pull[5].s0.t103721 = (((cost_pyramid_pull[5].s0.t103719.s + -3)/2) + (((cost_pyramid_pull[5].s0.t103719.s + 1) % 2)*2)) in (let cost_pyramid_pull[5].s0.t103722.s = (((cost_pyramid_pull[5].s0.y.__thread_id_y + upx$2.s0.y.y_i.base)/4) + ((((cost_pyramid_pull[5].s0.y.__thread_id_y + upx$2.s0.y.y_i.base)/2) % 2)*2)) in (let cost_pyramid_pull[5].s0.t103723.s = min(likely((cost_pyramid_pull[5].s0.t103719.s + -1)), ((left_im.extent.1/64) + -1)) in (let cost_pyramid_pull[5].s0.t103724.s = min(likely((cost_pyramid_pull[5].s0.t103720.s + -1)), ((left_im.extent.0/64) + -1)) in (let cost_pyramid_pull[5].s0.t103725.s = min(likely(((((upx$2.s0.x.x_i.base/2) + cost_pyramid_pull[5].s0.x.__thread_id_x) + -1)/2)), ((left_im.extent.0/64) + -1)) in (let cost_pyramid_pull[5].s0.t103726.s = min(likely(((cost_pyramid_pull[5].s0.y.__thread_id_y + upx$2.s0.y.y_i.base)/2)), ((left_im.extent.1/64) + -1)) in lerp(((((lerp(((upx[((((int64(cost_pyramid_pull[5].s0.c)*int64((upx.stride.2*2))) + ((int64((cost_pyramid_pull[5].s0.z - upx$2.s0._0._0_i.base))*int64(upx.stride.2)) + ((int64((cost_pyramid_pull[5].s0.t103722.s - ((upx$2.s0.y.y_i.base + -6)/4)))*int64(((((upx$2.s0.x.x_i.base + 2) % 4) + 23)/4))) + int64((cost_pyramid_pull[5].s0.t103720.s - ((upx$2.s0.x.x_i.base + -6)/4)))))) - int64(((((upx$2.s0.x.x_i.base + 2) % 4) + 23)/4))) + (int64)-1)] + (upx[(((int64(cost_pyramid_pull[5].s0.c)*int64((upx.stride.2*2))) + ((int64((cost_pyramid_pull[5].s0.z - upx$2.s0._0._0_i.base))*int64(upx.stride.2)) + ((int64((((cost_pyramid_pull[5].s0.y.__thread_id_y + upx$2.s0.y.y_i.base)/4) - ((upx$2.s0.y.y_i.base + -6)/4)))*int64(((((upx$2.s0.x.x_i.base + 2) % 4) + 23)/4))) + int64((cost_pyramid_pull[5].s0.t103720.s - ((upx$2.s0.x.x_i.base + -6)/4)))))) + (int64)-1)]*3.000000f))*0.250000f), downy$5[((int64(cost_pyramid_pull[5].s0.c)*int64((max(slices, 4)*downy$5.stride.2))) + ((int64(((cost_pyramid_pull[5].s0.z - min(slices, 4)) + 4))*int64(downy$5.stride.2)) + ((int64((max(cost_pyramid_pull[5].s0.t103726.s, 0) - downy$5.y.min_realized))*int64((downy$5.x.extent_realized.s + 1))) + int64((max(cost_pyramid_pull[5].s0.t103724.s, 0) - downy$5.x.min_realized)))))], 0.500000f) + (lerp(((upx[(((int64(cost_pyramid_pull[5].s0.c)*int64((upx.stride.2*2))) + ((int64((cost_pyramid_pull[5].s0.z - upx$2.s0._0._0_i.base))*int64(upx.stride.2)) + ((int64((cost_pyramid_pull[5].s0.t103722.s - ((upx$2.s0.y.y_i.base + -6)/4)))*int64(((((upx$2.s0.x.x_i.base + 2) % 4) + 23)/4))) + int64((((((upx$2.s0.x.x_i.base/2) + cost_pyramid_pull[5].s0.x.__thread_id_x) + -1)/2) - ((upx$2.s0.x.x_i.base + -6)/4)))))) - int64(((((upx$2.s0.x.x_i.base + 2) % 4) + 23)/4)))] + (upx[((int64(cost_pyramid_pull[5].s0.c)*int64((upx.stride.2*2))) + ((int64((cost_pyramid_pull[5].s0.z - upx$2.s0._0._0_i.base))*int64(upx.stride.2)) + ((int64((((cost_pyramid_pull[5].s0.y.__thread_id_y + upx$2.s0.y.y_i.base)/4) - ((upx$2.s0.y.y_i.base + -6)/4)))*int64(((((upx$2.s0.x.x_i.base + 2) % 4) + 23)/4))) + int64((((((upx$2.s0.x.x_i.base/2) + cost_pyramid_pull[5].s0.x.__thread_id_x) + -1)/2) - ((upx$2.s0.x.x_i.base + -6)/4))))))]*3.000000f))*0.250000f), downy$5[((int64(cost_pyramid_pull[5].s0.c)*int64((max(slices, 4)*downy$5.stride.2))) + ((int64(((cost_pyramid_pull[5].s0.z - min(slices, 4)) + 4))*int64(downy$5.stride.2)) + ((int64((max(cost_pyramid_pull[5].s0.t103726.s, 0) - downy$5.y.min_realized))*int64((downy$5.x.extent_realized.s + 1))) + int64((max(cost_pyramid_pull[5].s0.t103725.s, 0) - downy$5.x.min_realized)))))], 0.500000f)*3.000000f))*3.000000f) + (lerp(((upx[(((int64(cost_pyramid_pull[5].s0.c)*int64((upx.stride.2*2))) + ((int64((cost_pyramid_pull[5].s0.z - upx$2.s0._0._0_i.base))*int64(upx.stride.2)) + ((int64((cost_pyramid_pull[5].s0.t103721 - ((upx$2.s0.y.y_i.base + -6)/4)))*int64(((((upx$2.s0.x.x_i.base + 2) % 4) + 23)/4))) + int64((cost_pyramid_pull[5].s0.t103720.s - ((upx$2.s0.x.x_i.base + -6)/4)))))) + (int64)-1)] + (upx[(((int64(cost_pyramid_pull[5].s0.c)*int64((upx.stride.2*2))) + ((int64((cost_pyramid_pull[5].s0.z - upx$2.s0._0._0_i.base))*int64(upx.stride.2)) + ((int64((((cost_pyramid_pull[5].s0.t103719.s + -1)/2) - ((upx$2.s0.y.y_i.base + -6)/4)))*int64(((((upx$2.s0.x.x_i.base + 2) % 4) + 23)/4))) + int64((cost_pyramid_pull[5].s0.t103720.s - ((upx$2.s0.x.x_i.base + -6)/4)))))) + (int64)-1)]*3.000000f))*0.250000f), downy$5[((int64(cost_pyramid_pull[5].s0.c)*int64((max(slices, 4)*downy$5.stride.2))) + ((int64(((cost_pyramid_pull[5].s0.z - min(slices, 4)) + 4))*int64(downy$5.stride.2)) + ((int64((max(cost_pyramid_pull[5].s0.t103723.s, 0) - downy$5.y.min_realized))*int64((downy$5.x.extent_realized.s + 1))) + int64((max(cost_pyramid_pull[5].s0.t103724.s, 0) - downy$5.x.min_realized)))))], 0.500000f) + (lerp(((upx[((int64(cost_pyramid_pull[5].s0.c)*int64((upx.stride.2*2))) + ((int64((cost_pyramid_pull[5].s0.z - upx$2.s0._0._0_i.base))*int64(upx.stride.2)) + ((int64((cost_pyramid_pull[5].s0.t103721 - ((upx$2.s0.y.y_i.base + -6)/4)))*int64(((((upx$2.s0.x.x_i.base + 2) % 4) + 23)/4))) + int64((((((upx$2.s0.x.x_i.base/2) + cost_pyramid_pull[5].s0.x.__thread_id_x) + -1)/2) - ((upx$2.s0.x.x_i.base + -6)/4))))))] + (upx[((int64(cost_pyramid_pull[5].s0.c)*int64((upx.stride.2*2))) + ((int64((cost_pyramid_pull[5].s0.z - upx$2.s0._0._0_i.base))*int64(upx.stride.2)) + ((int64((((cost_pyramid_pull[5].s0.t103719.s + -1)/2) - ((upx$2.s0.y.y_i.base + -6)/4)))*int64(((((upx$2.s0.x.x_i.base + 2) % 4) + 23)/4))) + int64((((((upx$2.s0.x.x_i.base/2) + cost_pyramid_pull[5].s0.x.__thread_id_x) + -1)/2) - ((upx$2.s0.x.x_i.base + -6)/4))))))]*3.000000f))*0.250000f), downy$5[((int64(cost_pyramid_pull[5].s0.c)*int64((max(slices, 4)*downy$5.stride.2))) + ((int64(((cost_pyramid_pull[5].s0.z - min(slices, 4)) + 4))*int64(downy$5.stride.2)) + ((int64((max(cost_pyramid_pull[5].s0.t103723.s, 0) - downy$5.y.min_realized))*int64((downy$5.x.extent_realized.s + 1))) + int64((max(cost_pyramid_pull[5].s0.t103725.s, 0) - downy$5.x.min_realized)))))], 0.500000f)*3.000000f)))*0.062500f), downy$4[((int64(cost_pyramid_pull[5].s0.c)*int64((max(slices, 2)*downy$4.stride.2))) + ((int64(((cost_pyramid_pull[5].s0.z - min(slices, 2)) + 2))*int64(downy$4.stride.2)) + ((int64((max(min(likely((cost_pyramid_pull[5].s0.y.__thread_id_y + upx$2.s0.y.y_i.base)), ((left_im.extent.1/32) + -1)), 0) - downy$4.y.min_realized))*int64((downy$4.x.extent_realized.s + -3))) + int64((max(min(likely((((upx$2.s0.x.x_i.base/2) + cost_pyramid_pull[5].s0.x.__thread_id_x) + -1)), ((left_im.extent.0/32) + -1)), 0) - downy$4.x.min_realized)))))], 0.500000f)))))))))
                          }
                        }
                      }
                    }
                  }
                }
                consume cost_pyramid_pull[5] {
                  gpu_thread<CUDA> (upx$2.s0._0._0_i.__thread_id_z, 0, 2) {
                    gpu_thread<CUDA> (upx$2.s0.y.y_i.__thread_id_y, 0, 8) {
                      gpu_thread<CUDA> (upx$2.s0.x.x_i.__thread_id_x, 0, 8) {
                        for (upx$2.s0._1, 0, 2) {
                          upx$2[((int64(upx$2.s0._1)*int64((max(slices, 2)*upx$2.stride.2))) + ((int64((((upx$2.s0._0._0_i.__thread_id_z + upx$2.s0._0._0_i.base) - min(slices, 2)) + 2))*int64(upx$2.stride.2)) + ((int64(((upx$2.s0.y.y_i.__thread_id_y + upx$2.s0.y.y_i.base) - ((upx$2.y.min_realized.s + -163)/32)))*int64((upx$2.x.extent_realized.s + 1))) + int64(((upx$2.s0.x.x_i.__thread_id_x + upx$2.s0.x.x_i.base) - ((upx$2.x.min_realized.s + -83)/16))))))] = ((cost_pyramid_pull[5][(((int64(upx$2.s0._1)*int64((((upx$2.s0.x.x_i.base % 2)*16) + 96))) + ((int64(upx$2.s0._0._0_i.__thread_id_z)*int64((((upx$2.s0.x.x_i.base % 2)*8) + 48))) + ((int64(upx$2.s0.y.y_i.__thread_id_y)*int64(((upx$2.s0.x.x_i.base % 2) + 6))) + int64((((((upx$2.s0.x.x_i.__thread_id_x + upx$2.s0.x.x_i.base)/2) + (((upx$2.s0.x.x_i.__thread_id_x + upx$2.s0.x.x_i.base) % 2)*2)) - (upx$2.s0.x.x_i.base/2)) + 1))))) + (int64)-1)] + (cost_pyramid_pull[5][((int64(upx$2.s0._1)*int64((((upx$2.s0.x.x_i.base % 2)*16) + 96))) + ((int64(upx$2.s0._0._0_i.__thread_id_z)*int64((((upx$2.s0.x.x_i.base % 2)*8) + 48))) + ((int64(upx$2.s0.y.y_i.__thread_id_y)*int64(((upx$2.s0.x.x_i.base % 2) + 6))) + int64(((((upx$2.s0.x.x_i.__thread_id_x + upx$2.s0.x.x_i.base)/2) - (upx$2.s0.x.x_i.base/2)) + 1)))))]*3.000000f))*0.250000f)
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          let halide_device_free_result$7 = halide_device_free(downy$4.buffer)
          assert((halide_device_free_result$7 == 0), halide_device_free_result$7)
          let halide_device_free_result$6 = halide_device_free(downy$5.buffer)
          assert((halide_device_free_result$6 == 0), halide_device_free_result$6)
          let halide_device_free_result$5 = halide_device_free(downy$6.buffer)
          assert((halide_device_free_result$5 == 0), halide_device_free_result$5)
          _halide_buffer_set_device_dirty(upx$2.buffer, (uint1)1)
        }
      }
    }
  }
  let cost_pyramid_pull[2].y.min_realized.s = min((min((argmin.s1.y.max.s + -16), argmin.s1.y.min) + 49), argmin.s1.y.max.s)
  let cost_pyramid_pull[2].y.extent_realized.s = (max(min(((argmin.s1.y.max.s + 5)/4), (((argmin.s1.y.min + 54)/4) + (((((argmin.s1.y.max.s + 5)/4) - ((argmin.s1.y.min + -6)/4))/16)*16))), ((min(((((((argmin.s1.y.max.s - argmin.s1.y.min) + -1)/16)*16) + argmin.s1.y.min) + 16), argmin.s1.y.max.s) + 5)/4)) - ((cost_pyramid_pull[2].y.min_realized.s + -55)/4))
  let cost_pyramid_pull[2].x.min_realized.s = min((min((argmin.s1.x.max.s + -16), argmin.s1.x.min) + 49), argmin.s1.x.max.s)
  let cost_pyramid_pull[2].x.extent_realized.s = (max(min(((argmin.s1.x.max.s + 5)/4), (((argmin.s1.x.min + 54)/4) + (((((argmin.s1.x.max.s + 5)/4) - ((argmin.s1.x.min + -6)/4))/16)*16))), ((min(((((((argmin.s1.x.max.s - argmin.s1.x.min) + -1)/16)*16) + argmin.s1.x.min) + 16), argmin.s1.x.max.s) + 5)/4)) - ((cost_pyramid_pull[2].x.min_realized.s + -55)/4))
  let cost_pyramid_pull[2].stride.2 = ((cost_pyramid_pull[2].x.extent_realized.s + 1)*(cost_pyramid_pull[2].y.extent_realized.s + 1))
  allocate cost_pyramid_pull[2][float32 * (cost_pyramid_pull[2].x.extent_realized.s + 1) * (cost_pyramid_pull[2].y.extent_realized.s + 1) * max(slices, 2) * 2] if (uint1)0
  let cost_pyramid_pull[2].buffer = (let t104131 = make_struct((halide_dimension_t *), ((cost_pyramid_pull[2].x.min_realized.s + -55)/4), (cost_pyramid_pull[2].x.extent_realized.s + 1), 1, 0, ((cost_pyramid_pull[2].y.min_realized.s + -55)/4), (cost_pyramid_pull[2].y.extent_realized.s + 1), (cost_pyramid_pull[2].x.extent_realized.s + 1), 0, (min(slices, 2) + -2), max(slices, 2), cost_pyramid_pull[2].stride.2, 0, 0, 2, (max(slices, 2)*cost_pyramid_pull[2].stride.2), 0) in _halide_buffer_init(alloca(size_of_halide_buffer_t()), t104131, reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 4, t104131, (uint64)0))
  register_destructor("halide_device_free_as_destructor", cost_pyramid_pull[2].buffer)
  let cost_pyramid_pull[2].s0.x.x_o.loop_extent.s = (((argmin.s1.x.max.s + 5)/4) - ((argmin.s1.x.min + -6)/4))
  let cost_pyramid_pull[2].s0.y.y_o.loop_extent.s = (((argmin.s1.y.max.s + 5)/4) - ((argmin.s1.y.min + -6)/4))
  produce cost_pyramid_pull[2] {
    consume upx$2 {
      consume downy$3 {
        consume downy$2 {
          consume downy$1 {
            let halide_device_malloc_result$3 = halide_device_malloc(cost_pyramid_pull[2].buffer, halide_cuda_device_interface())
            assert((halide_device_malloc_result$3 == 0), halide_device_malloc_result$3)
            gpu_block<CUDA> (cost_pyramid_pull[2].s0.z.z_o.__block_id_z, 0, ((slices + 1)/2)) {
              let cost_pyramid_pull[2].s0.z.z_i.base = min(likely_if_innermost((cost_pyramid_pull[2].s0.z.z_o.__block_id_z*2)), (slices + -2))
              gpu_block<CUDA> (cost_pyramid_pull[2].s0.y.y_o.__block_id_y, 0, ((cost_pyramid_pull[2].s0.y.y_o.loop_extent.s/16) + 1)) {
                let cost_pyramid_pull[2].s0.y.y_i.base = min(likely_if_innermost((((argmin.s1.y.min + -6)/4) + (cost_pyramid_pull[2].s0.y.y_o.__block_id_y*16))), ((argmin.s1.y.max.s + -55)/4))
                gpu_block<CUDA> (cost_pyramid_pull[2].s0.x.x_o.__block_id_x, 0, ((cost_pyramid_pull[2].s0.x.x_o.loop_extent.s/16) + 1)) {
                  let cost_pyramid_pull[2].s0.x.x_i.base = min(likely_if_innermost((((argmin.s1.x.min + -6)/4) + (cost_pyramid_pull[2].s0.x.x_o.__block_id_x*16))), ((argmin.s1.x.max.s + -55)/4))
                  let cost_pyramid_pull[4].stride.2 = (((((cost_pyramid_pull[2].s0.x.x_i.base + 2) % 4) + 31)/4)*((((cost_pyramid_pull[2].s0.y.y_i.base + 2) % 4) + 31)/4))
                  allocate cost_pyramid_pull[4][float32 * ((((cost_pyramid_pull[2].s0.x.x_i.base + 2) % 4) + 31)/4) * ((((cost_pyramid_pull[2].s0.y.y_i.base + 2) % 4) + 31)/4) * 2 * 2]
                  let cost_pyramid_pull[4].s0.y.__thread_id_y.loop_extent = (let t103863 = min(((argmin.s1.y.max.s + -55)/4), (((argmin.s1.y.min + -6)/4) + (cost_pyramid_pull[2].s0.y.y_o.__block_id_y*16))) in ((((t103863 + 2) % 4) + 31)/4))
                  let cost_pyramid_pull[4].s0.x.__thread_id_x.loop_extent = (let t103895 = min(((argmin.s1.x.max.s + -55)/4), (((argmin.s1.x.min + -6)/4) + (cost_pyramid_pull[2].s0.x.x_o.__block_id_x*16))) in ((((t103895 + 2) % 4) + 31)/4))
                  produce cost_pyramid_pull[4] {
                    gpu_thread<CUDA> (cost_pyramid_pull[4].s0.z.__thread_id_z, 0, 2) {
                      gpu_thread<CUDA> (cost_pyramid_pull[4].s0.y.__thread_id_y, 0, cost_pyramid_pull[4].s0.y.__thread_id_y.loop_extent) {
                        gpu_thread<CUDA> (cost_pyramid_pull[4].s0.x.__thread_id_x, 0, cost_pyramid_pull[4].s0.x.__thread_id_x.loop_extent) {
                          for (cost_pyramid_pull[4].s0.c, 0, 2) {
                            cost_pyramid_pull[4][((int64(cost_pyramid_pull[4].s0.c)*int64((cost_pyramid_pull[4].stride.2*2))) + ((int64(cost_pyramid_pull[4].s0.z.__thread_id_z)*int64(cost_pyramid_pull[4].stride.2)) + ((int64(cost_pyramid_pull[4].s0.y.__thread_id_y)*int64(((((cost_pyramid_pull[2].s0.x.x_i.base + 2) % 4) + 31)/4))) + int64(cost_pyramid_pull[4].s0.x.__thread_id_x))))] = lerp(((upx$2[(((int64(cost_pyramid_pull[4].s0.c)*int64((max(slices, 2)*upx$2.stride.2))) + ((int64((((cost_pyramid_pull[2].s0.z.z_i.base + cost_pyramid_pull[4].s0.z.__thread_id_z) - min(slices, 2)) + 2))*int64(upx$2.stride.2)) + ((int64(((((((cost_pyramid_pull[2].s0.y.y_i.base + -6)/4) + cost_pyramid_pull[4].s0.y.__thread_id_y)/2) + (((((cost_pyramid_pull[2].s0.y.y_i.base + -6)/4) + cost_pyramid_pull[4].s0.y.__thread_id_y) % 2)*2)) - ((upx$2.y.min_realized.s + -163)/32)))*int64((upx$2.x.extent_realized.s + 1))) + int64(((((cost_pyramid_pull[2].s0.x.x_i.base + -6)/4) + cost_pyramid_pull[4].s0.x.__thread_id_x) - ((upx$2.x.min_realized.s + -83)/16)))))) - int64((upx$2.x.extent_realized.s + 1)))] + (upx$2[((int64(cost_pyramid_pull[4].s0.c)*int64((max(slices, 2)*upx$2.stride.2))) + ((int64((((cost_pyramid_pull[2].s0.z.z_i.base + cost_pyramid_pull[4].s0.z.__thread_id_z) - min(slices, 2)) + 2))*int64(upx$2.stride.2)) + ((int64((((((cost_pyramid_pull[2].s0.y.y_i.base + -6)/4) + cost_pyramid_pull[4].s0.y.__thread_id_y)/2) - ((upx$2.y.min_realized.s + -163)/32)))*int64((upx$2.x.extent_realized.s + 1))) + int64(((((cost_pyramid_pull[2].s0.x.x_i.base + -6)/4) + cost_pyramid_pull[4].s0.x.__thread_id_x) - ((upx$2.x.min_realized.s + -83)/16))))))]*3.000000f))*0.250000f), downy$3[((int64(cost_pyramid_pull[4].s0.c)*int64((max(slices, 2)*downy$3.stride.2))) + ((int64((((cost_pyramid_pull[2].s0.z.z_i.base + cost_pyramid_pull[4].s0.z.__thread_id_z) - min(slices, 2)) + 2))*int64(downy$3.stride.2)) + ((int64((max(min(likely((((cost_pyramid_pull[2].s0.y.y_i.base + -6)/4) + cost_pyramid_pull[4].s0.y.__thread_id_y)), ((left_im.extent.1/16) + -1)), 0) - downy$3.y.min_realized))*int64((downy$3.x.extent_realized.s + 1))) + int64((max(min(likely((((cost_pyramid_pull[2].s0.x.x_i.base + -6)/4) + cost_pyramid_pull[4].s0.x.__thread_id_x)), ((left_im.extent.0/16) + -1)), 0) - downy$3.x.min_realized)))))], 0.500000f)
                          }
                        }
                      }
                    }
                  }
                  let upx$3.stride.2 = (((((cost_pyramid_pull[2].s0.y.y_i.base + 2) % 4) + 31)/4)*((cost_pyramid_pull[2].s0.x.x_i.base % 2) + 10))
                  allocate upx$3[float32 * ((cost_pyramid_pull[2].s0.x.x_i.base % 2) + 10) * ((((cost_pyramid_pull[2].s0.y.y_i.base + 2) % 4) + 31)/4) * 2 * 2]
                  let upx$3.s0.y.__thread_id_y.loop_extent = (let t103873 = min(((argmin.s1.y.max.s + -55)/4), (((argmin.s1.y.min + -6)/4) + (cost_pyramid_pull[2].s0.y.y_o.__block_id_y*16))) in ((((t103873 + 2) % 4) + 31)/4))
                  let upx$3.s0.x.__thread_id_x.loop_extent = (let t103901 = min(((argmin.s1.x.max.s + -55)/4), (((argmin.s1.x.min + -6)/4) + (cost_pyramid_pull[2].s0.x.x_o.__block_id_x*16))) in ((t103901 % 2) + 10))
                  produce upx$3 {
                    consume cost_pyramid_pull[4] {
                      gpu_thread<CUDA> (upx$3.s0.y.__thread_id_y, 0, upx$3.s0.y.__thread_id_y.loop_extent) {
                        gpu_thread<CUDA> (upx$3.s0.x.__thread_id_x, 0, upx$3.s0.x.__thread_id_x.loop_extent) {
                          for (upx$3.s0._0, cost_pyramid_pull[2].s0.z.z_i.base, 2) {
                            for (upx$3.s0._1, 0, 2) {
                              upx$3[((int64(upx$3.s0._1)*int64((upx$3.stride.2*2))) + ((int64((upx$3.s0._0 - cost_pyramid_pull[2].s0.z.z_i.base))*int64(upx$3.stride.2)) + ((int64(upx$3.s0.y.__thread_id_y)*int64(((cost_pyramid_pull[2].s0.x.x_i.base % 2) + 10))) + int64(upx$3.s0.x.__thread_id_x))))] = ((cost_pyramid_pull[4][(((int64(upx$3.s0._1)*int64((cost_pyramid_pull[4].stride.2*2))) + ((int64((upx$3.s0._0 - cost_pyramid_pull[2].s0.z.z_i.base))*int64(cost_pyramid_pull[4].stride.2)) + ((int64(upx$3.s0.y.__thread_id_y)*int64(((((cost_pyramid_pull[2].s0.x.x_i.base + 2) % 4) + 31)/4))) + int64(((((((cost_pyramid_pull[2].s0.x.x_i.base/2) + upx$3.s0.x.__thread_id_x) + -1)/2) + (((((cost_pyramid_pull[2].s0.x.x_i.base/2) + upx$3.s0.x.__thread_id_x) + 1) % 2)*2)) - ((cost_pyramid_pull[2].s0.x.x_i.base + -6)/4)))))) + (int64)-1)] + (cost_pyramid_pull[4][((int64(upx$3.s0._1)*int64((cost_pyramid_pull[4].stride.2*2))) + ((int64((upx$3.s0._0 - cost_pyramid_pull[2].s0.z.z_i.base))*int64(cost_pyramid_pull[4].stride.2)) + ((int64(upx$3.s0.y.__thread_id_y)*int64(((((cost_pyramid_pull[2].s0.x.x_i.base + 2) % 4) + 31)/4))) + int64((((((cost_pyramid_pull[2].s0.x.x_i.base/2) + upx$3.s0.x.__thread_id_x) + -1)/2) - ((cost_pyramid_pull[2].s0.x.x_i.base + -6)/4))))))]*3.000000f))*0.250000f)
                            }
                          }
                        }
                      }
                    }
                  }
                  let cost_pyramid_pull[3].stride.2 = (((cost_pyramid_pull[2].s0.x.x_i.base % 2) + 10)*((cost_pyramid_pull[2].s0.y.y_i.base % 2) + 10))
                  allocate cost_pyramid_pull[3][float32 * ((cost_pyramid_pull[2].s0.x.x_i.base % 2) + 10) * ((cost_pyramid_pull[2].s0.y.y_i.base % 2) + 10) * 2 * 2]
                  let cost_pyramid_pull[3].s0.y.__thread_id_y.loop_extent = (let t103879 = min(((argmin.s1.y.max.s + -55)/4), (((argmin.s1.y.min + -6)/4) + (cost_pyramid_pull[2].s0.y.y_o.__block_id_y*16))) in ((t103879 % 2) + 10))
                  let cost_pyramid_pull[3].s0.x.__thread_id_x.loop_extent = (let t103907 = min(((argmin.s1.x.max.s + -55)/4), (((argmin.s1.x.min + -6)/4) + (cost_pyramid_pull[2].s0.x.x_o.__block_id_x*16))) in ((t103907 % 2) + 10))
                  produce cost_pyramid_pull[3] {
                    consume upx$3 {
                      gpu_thread<CUDA> (cost_pyramid_pull[3].s0.z.__thread_id_z, 0, 2) {
                        gpu_thread<CUDA> (cost_pyramid_pull[3].s0.y.__thread_id_y, 0, cost_pyramid_pull[3].s0.y.__thread_id_y.loop_extent) {
                          gpu_thread<CUDA> (cost_pyramid_pull[3].s0.x.__thread_id_x, 0, cost_pyramid_pull[3].s0.x.__thread_id_x.loop_extent) {
                            for (cost_pyramid_pull[3].s0.c, 0, 2) {
                              cost_pyramid_pull[3][((int64(cost_pyramid_pull[3].s0.c)*int64((cost_pyramid_pull[3].stride.2*2))) + ((int64(cost_pyramid_pull[3].s0.z.__thread_id_z)*int64(cost_pyramid_pull[3].stride.2)) + ((int64(cost_pyramid_pull[3].s0.y.__thread_id_y)*int64(((cost_pyramid_pull[2].s0.x.x_i.base % 2) + 10))) + int64(cost_pyramid_pull[3].s0.x.__thread_id_x))))] = lerp(((upx$3[(((int64(cost_pyramid_pull[3].s0.c)*int64((upx$3.stride.2*2))) + ((int64(cost_pyramid_pull[3].s0.z.__thread_id_z)*int64(upx$3.stride.2)) + ((int64(((((((cost_pyramid_pull[2].s0.y.y_i.base/2) + cost_pyramid_pull[3].s0.y.__thread_id_y) + -1)/2) + (((((cost_pyramid_pull[2].s0.y.y_i.base/2) + cost_pyramid_pull[3].s0.y.__thread_id_y) + 1) % 2)*2)) - ((cost_pyramid_pull[2].s0.y.y_i.base + -6)/4)))*int64(((cost_pyramid_pull[2].s0.x.x_i.base % 2) + 10))) + int64(cost_pyramid_pull[3].s0.x.__thread_id_x)))) - int64(((cost_pyramid_pull[2].s0.x.x_i.base % 2) + 10)))] + (upx$3[((int64(cost_pyramid_pull[3].s0.c)*int64((upx$3.stride.2*2))) + ((int64(cost_pyramid_pull[3].s0.z.__thread_id_z)*int64(upx$3.stride.2)) + ((int64((((((cost_pyramid_pull[2].s0.y.y_i.base/2) + cost_pyramid_pull[3].s0.y.__thread_id_y) + -1)/2) - ((cost_pyramid_pull[2].s0.y.y_i.base + -6)/4)))*int64(((cost_pyramid_pull[2].s0.x.x_i.base % 2) + 10))) + int64(cost_pyramid_pull[3].s0.x.__thread_id_x))))]*3.000000f))*0.250000f), downy$2[((int64(cost_pyramid_pull[3].s0.c)*int64((max(slices, 2)*downy$2.stride.2))) + ((int64((((cost_pyramid_pull[2].s0.z.z_i.base + cost_pyramid_pull[3].s0.z.__thread_id_z) - min(slices, 2)) + 2))*int64(downy$2.stride.2)) + ((int64((max(min(likely((((cost_pyramid_pull[2].s0.y.y_i.base/2) + cost_pyramid_pull[3].s0.y.__thread_id_y) + -1)), ((left_im.extent.1/8) + -1)), 0) - downy$2.y.min_realized))*int64((downy$2.x.extent_realized.s + -15))) + int64((max(min(likely((((cost_pyramid_pull[2].s0.x.x_i.base/2) + cost_pyramid_pull[3].s0.x.__thread_id_x) + -1)), ((left_im.extent.0/8) + -1)), 0) - downy$2.x.min_realized)))))], 0.500000f)
                            }
                          }
                        }
                      }
                    }
                  }
                  allocate upx$4[float32 * 16 * ((cost_pyramid_pull[2].s0.y.y_i.base % 2) + 10) * 2 * 2]
                  let upx$4.s0.y.__thread_id_y.loop_extent = (let t103885 = min(((argmin.s1.y.max.s + -55)/4), (((argmin.s1.y.min + -6)/4) + (cost_pyramid_pull[2].s0.y.y_o.__block_id_y*16))) in ((t103885 % 2) + 10))
                  produce upx$4 {
                    consume cost_pyramid_pull[3] {
                      gpu_thread<CUDA> (upx$4.s0.y.__thread_id_y, 0, upx$4.s0.y.__thread_id_y.loop_extent) {
                        gpu_thread<CUDA> (upx$4.s0.x.__thread_id_x, 0, 16) {
                          for (upx$4.s0._0, cost_pyramid_pull[2].s0.z.z_i.base, 2) {
                            for (upx$4.s0._1, 0, 2) {
                              upx$4[((int64(upx$4.s0._1)*int64((((cost_pyramid_pull[2].s0.y.y_i.base % 2)*32) + 320))) + ((int64((upx$4.s0._0 - cost_pyramid_pull[2].s0.z.z_i.base))*int64((((cost_pyramid_pull[2].s0.y.y_i.base % 2)*16) + 160))) + ((int64(upx$4.s0.y.__thread_id_y)*(int64)16) + int64(upx$4.s0.x.__thread_id_x))))] = ((cost_pyramid_pull[3][(((int64(upx$4.s0._1)*int64((cost_pyramid_pull[3].stride.2*2))) + ((int64((upx$4.s0._0 - cost_pyramid_pull[2].s0.z.z_i.base))*int64(cost_pyramid_pull[3].stride.2)) + ((int64(upx$4.s0.y.__thread_id_y)*int64(((cost_pyramid_pull[2].s0.x.x_i.base % 2) + 10))) + int64((((((cost_pyramid_pull[2].s0.x.x_i.base + upx$4.s0.x.__thread_id_x)/2) + (((cost_pyramid_pull[2].s0.x.x_i.base + upx$4.s0.x.__thread_id_x) % 2)*2)) - (cost_pyramid_pull[2].s0.x.x_i.base/2)) + 1))))) + (int64)-1)] + (cost_pyramid_pull[3][((int64(upx$4.s0._1)*int64((cost_pyramid_pull[3].stride.2*2))) + ((int64((upx$4.s0._0 - cost_pyramid_pull[2].s0.z.z_i.base))*int64(cost_pyramid_pull[3].stride.2)) + ((int64(upx$4.s0.y.__thread_id_y)*int64(((cost_pyramid_pull[2].s0.x.x_i.base % 2) + 10))) + int64(((((cost_pyramid_pull[2].s0.x.x_i.base % 2) + upx$4.s0.x.__thread_id_x)/2) + 1)))))]*3.000000f))*0.250000f)
                            }
                          }
                        }
                      }
                    }
                  }
                  consume upx$4 {
                    gpu_thread<CUDA> (cost_pyramid_pull[2].s0.z.z_i.__thread_id_z, 0, 2) {
                      gpu_thread<CUDA> (cost_pyramid_pull[2].s0.y.y_i.__thread_id_y, 0, 16) {
                        gpu_thread<CUDA> (cost_pyramid_pull[2].s0.x.x_i.__thread_id_x, 0, 16) {
                          for (cost_pyramid_pull[2].s0.c, 0, 2) {
                            cost_pyramid_pull[2][((int64(cost_pyramid_pull[2].s0.c)*int64((max(slices, 2)*cost_pyramid_pull[2].stride.2))) + ((int64((((cost_pyramid_pull[2].s0.z.z_i.__thread_id_z + cost_pyramid_pull[2].s0.z.z_i.base) - min(slices, 2)) + 2))*int64(cost_pyramid_pull[2].stride.2)) + ((int64(((cost_pyramid_pull[2].s0.y.y_i.__thread_id_y + cost_pyramid_pull[2].s0.y.y_i.base) - ((cost_pyramid_pull[2].y.min_realized.s + -55)/4)))*int64((cost_pyramid_pull[2].x.extent_realized.s + 1))) + int64(((cost_pyramid_pull[2].s0.x.x_i.__thread_id_x + cost_pyramid_pull[2].s0.x.x_i.base) - ((cost_pyramid_pull[2].x.min_realized.s + -55)/4))))))] = lerp(((upx$4[(((int64(cost_pyramid_pull[2].s0.c)*int64((((cost_pyramid_pull[2].s0.y.y_i.base % 2)*32) + 320))) + ((int64(cost_pyramid_pull[2].s0.z.z_i.__thread_id_z)*int64((((cost_pyramid_pull[2].s0.y.y_i.base % 2)*16) + 160))) + ((int64((((((cost_pyramid_pull[2].s0.y.y_i.__thread_id_y + cost_pyramid_pull[2].s0.y.y_i.base)/2) + (((cost_pyramid_pull[2].s0.y.y_i.__thread_id_y + cost_pyramid_pull[2].s0.y.y_i.base) % 2)*2)) - (cost_pyramid_pull[2].s0.y.y_i.base/2)) + 1))*(int64)16) + int64(cost_pyramid_pull[2].s0.x.x_i.__thread_id_x)))) + (int64)-16)] + (upx$4[((int64(cost_pyramid_pull[2].s0.c)*int64((((cost_pyramid_pull[2].s0.y.y_i.base % 2)*32) + 320))) + ((int64(cost_pyramid_pull[2].s0.z.z_i.__thread_id_z)*int64((((cost_pyramid_pull[2].s0.y.y_i.base % 2)*16) + 160))) + ((int64(((((cost_pyramid_pull[2].s0.y.y_i.__thread_id_y + cost_pyramid_pull[2].s0.y.y_i.base)/2) - (cost_pyramid_pull[2].s0.y.y_i.base/2)) + 1))*(int64)16) + int64(cost_pyramid_pull[2].s0.x.x_i.__thread_id_x))))]*3.000000f))*0.250000f), downy$1[((int64(cost_pyramid_pull[2].s0.c)*int64((max(slices, 2)*downy$1.stride.2))) + ((int64((((cost_pyramid_pull[2].s0.z.z_i.__thread_id_z + cost_pyramid_pull[2].s0.z.z_i.base) - min(slices, 2)) + 2))*int64(downy$1.stride.2)) + ((int64((max(min(likely((cost_pyramid_pull[2].s0.y.y_i.__thread_id_y + cost_pyramid_pull[2].s0.y.y_i.base)), ((left_im.extent.1/4) + -1)), 0) - downy$1.y.min_realized))*int64((downy$1.x.extent_realized.s + 1))) + int64((max(min(likely((cost_pyramid_pull[2].s0.x.x_i.__thread_id_x + cost_pyramid_pull[2].s0.x.x_i.base)), ((left_im.extent.0/4) + -1)), 0) - downy$1.x.min_realized)))))], 0.500000f)
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            let halide_device_free_result$10 = halide_device_free(downy$1.buffer)
            assert((halide_device_free_result$10 == 0), halide_device_free_result$10)
            let halide_device_free_result$9 = halide_device_free(downy$2.buffer)
            assert((halide_device_free_result$9 == 0), halide_device_free_result$9)
            let halide_device_free_result$8 = halide_device_free(downy$3.buffer)
            assert((halide_device_free_result$8 == 0), halide_device_free_result$8)
            let halide_device_free_result$4 = halide_device_free(upx$2.buffer)
            assert((halide_device_free_result$4 == 0), halide_device_free_result$4)
            _halide_buffer_set_device_dirty(cost_pyramid_pull[2].buffer, (uint1)1)
          }
        }
      }
    }
  }
  let filtered_cost.y.min_realized = min((argmin.s1.y.max.s + -16), argmin.s1.y.min)
  let filtered_cost.y.extent_realized = (max(min(((((((argmin.s1.y.max.s - argmin.s1.y.min) + -1)/16)*16) + argmin.s1.y.min) + 16), argmin.s1.y.max.s), ((((((argmin.s1.y.max.s - argmin.s1.y.min) + -1)/8)*8) + argmin.s1.y.min) + 8)) - filtered_cost.y.min_realized)
  let filtered_cost.x.min_realized = min((argmin.s1.x.max.s + -16), argmin.s1.x.min)
  let filtered_cost.x.extent_realized.s = ((((((argmin.s1.x.max.s - argmin.s1.x.min) + -1)/16)*16) + argmin.s1.x.min) - filtered_cost.x.min_realized)
  allocate filtered_cost[float32 * (filtered_cost.x.extent_realized.s + 16) * filtered_cost.y.extent_realized * max(slices, 2)] if (uint1)0
  let filtered_cost.buffer = (let t104130 = make_struct((halide_dimension_t *), filtered_cost.x.min_realized, (filtered_cost.x.extent_realized.s + 16), 1, 0, filtered_cost.y.min_realized, filtered_cost.y.extent_realized, (filtered_cost.x.extent_realized.s + 16), 0, (min(slices, 2) + -2), max(slices, 2), ((filtered_cost.x.extent_realized.s + 16)*filtered_cost.y.extent_realized), 0) in _halide_buffer_init(alloca(size_of_halide_buffer_t()), t104130, reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 3, t104130, (uint64)0))
  register_destructor("halide_device_free_as_destructor", filtered_cost.buffer)
  produce filtered_cost {
    consume cost_pyramid_pull[2] {
      consume downy {
        consume cost_confidence {
          consume diff {
            let halide_device_malloc_result$2 = halide_device_malloc(filtered_cost.buffer, halide_cuda_device_interface())
            assert((halide_device_malloc_result$2 == 0), halide_device_malloc_result$2)
            gpu_block<CUDA> (filtered_cost.s0.z.z_o.__block_id_z, 0, ((slices + 1)/2)) {
              let filtered_cost.s0.z.z_i.base = min(likely_if_innermost((filtered_cost.s0.z.z_o.__block_id_z*2)), (slices + -2))
              gpu_block<CUDA> (filtered_cost.s0.y.y_o.__block_id_y, 0, (((argmin.s1.y.max.s - argmin.s1.y.min) + 15)/16)) {
                let filtered_cost.s0.y.y_i.base = min(likely_if_innermost(((filtered_cost.s0.y.y_o.__block_id_y*16) + argmin.s1.y.min)), (argmin.s1.y.max.s + -16))
                gpu_block<CUDA> (filtered_cost.s0.x.x_o.__block_id_x, 0, (((argmin.s1.x.max.s - argmin.s1.x.min) + 15)/16)) {
                  let filtered_cost.s0.x.x_i.base = min(likely_if_innermost(((filtered_cost.s0.x.x_o.__block_id_x*16) + argmin.s1.x.min)), (argmin.s1.x.max.s + -16))
                  let upx$5.stride.2 = (((((filtered_cost.s0.y.y_i.base + 2) % 4) + 31)/4)*((filtered_cost.s0.x.x_i.base % 2) + 10))
                  allocate upx$5[float32 * ((filtered_cost.s0.x.x_i.base % 2) + 10) * ((((filtered_cost.s0.y.y_i.base + 2) % 4) + 31)/4) * 2 * 2]
                  let upx$5.s0.y.__thread_id_y.loop_extent = (let t103925 = min(((filtered_cost.s0.y.y_o.__block_id_y*16) + argmin.s1.y.min), (argmin.s1.y.max.s + -16)) in ((((t103925 + 2) % 4) + 31)/4))
                  let upx$5.s0.x.__thread_id_x.loop_extent = (let t103943 = min(((filtered_cost.s0.x.x_o.__block_id_x*16) + argmin.s1.x.min), (argmin.s1.x.max.s + -16)) in ((t103943 % 2) + 10))
                  produce upx$5 {
                    gpu_thread<CUDA> (upx$5.s0.y.__thread_id_y, 0, upx$5.s0.y.__thread_id_y.loop_extent) {
                      gpu_thread<CUDA> (upx$5.s0.x.__thread_id_x, 0, upx$5.s0.x.__thread_id_x.loop_extent) {
                        for (upx$5.s0._0, filtered_cost.s0.z.z_i.base, 2) {
                          for (upx$5.s0._1, 0, 2) {
                            upx$5[((int64(upx$5.s0._1)*int64((upx$5.stride.2*2))) + ((int64((upx$5.s0._0 - filtered_cost.s0.z.z_i.base))*int64(upx$5.stride.2)) + ((int64(upx$5.s0.y.__thread_id_y)*int64(((filtered_cost.s0.x.x_i.base % 2) + 10))) + int64(upx$5.s0.x.__thread_id_x))))] = ((cost_pyramid_pull[2][(((int64(upx$5.s0._1)*int64((max(slices, 2)*cost_pyramid_pull[2].stride.2))) + ((int64(((upx$5.s0._0 - min(slices, 2)) + 2))*int64(cost_pyramid_pull[2].stride.2)) + ((int64(((((filtered_cost.s0.y.y_i.base + -6)/4) + upx$5.s0.y.__thread_id_y) - ((cost_pyramid_pull[2].y.min_realized.s + -55)/4)))*int64((cost_pyramid_pull[2].x.extent_realized.s + 1))) + int64(((((((filtered_cost.s0.x.x_i.base/2) + upx$5.s0.x.__thread_id_x) + -1)/2) + (((((filtered_cost.s0.x.x_i.base/2) + upx$5.s0.x.__thread_id_x) + 1) % 2)*2)) - ((cost_pyramid_pull[2].x.min_realized.s + -55)/4)))))) + (int64)-1)] + (cost_pyramid_pull[2][((int64(upx$5.s0._1)*int64((max(slices, 2)*cost_pyramid_pull[2].stride.2))) + ((int64(((upx$5.s0._0 - min(slices, 2)) + 2))*int64(cost_pyramid_pull[2].stride.2)) + ((int64(((((filtered_cost.s0.y.y_i.base + -6)/4) + upx$5.s0.y.__thread_id_y) - ((cost_pyramid_pull[2].y.min_realized.s + -55)/4)))*int64((cost_pyramid_pull[2].x.extent_realized.s + 1))) + int64((((((filtered_cost.s0.x.x_i.base/2) + upx$5.s0.x.__thread_id_x) + -1)/2) - ((cost_pyramid_pull[2].x.min_realized.s + -55)/4))))))]*3.000000f))*0.250000f)
                          }
                        }
                      }
                    }
                  }
                  let cost_pyramid_pull[1].stride.2 = (((filtered_cost.s0.x.x_i.base % 2) + 10)*((filtered_cost.s0.y.y_i.base % 2) + 10))
                  allocate cost_pyramid_pull[1][float32 * ((filtered_cost.s0.x.x_i.base % 2) + 10) * ((filtered_cost.s0.y.y_i.base % 2) + 10) * 2 * 2]
                  let cost_pyramid_pull[1].s0.y.__thread_id_y.loop_extent = (let t103931 = min(((filtered_cost.s0.y.y_o.__block_id_y*16) + argmin.s1.y.min), (argmin.s1.y.max.s + -16)) in ((t103931 % 2) + 10))
                  let cost_pyramid_pull[1].s0.x.__thread_id_x.loop_extent = (let t103949 = min(((filtered_cost.s0.x.x_o.__block_id_x*16) + argmin.s1.x.min), (argmin.s1.x.max.s + -16)) in ((t103949 % 2) + 10))
                  produce cost_pyramid_pull[1] {
                    consume upx$5 {
                      gpu_thread<CUDA> (cost_pyramid_pull[1].s0.z.__thread_id_z, 0, 2) {
                        gpu_thread<CUDA> (cost_pyramid_pull[1].s0.y.__thread_id_y, 0, cost_pyramid_pull[1].s0.y.__thread_id_y.loop_extent) {
                          gpu_thread<CUDA> (cost_pyramid_pull[1].s0.x.__thread_id_x, 0, cost_pyramid_pull[1].s0.x.__thread_id_x.loop_extent) {
                            for (cost_pyramid_pull[1].s0.c, 0, 2) {
                              cost_pyramid_pull[1][((int64(cost_pyramid_pull[1].s0.c)*int64((cost_pyramid_pull[1].stride.2*2))) + ((int64(cost_pyramid_pull[1].s0.z.__thread_id_z)*int64(cost_pyramid_pull[1].stride.2)) + ((int64(cost_pyramid_pull[1].s0.y.__thread_id_y)*int64(((filtered_cost.s0.x.x_i.base % 2) + 10))) + int64(cost_pyramid_pull[1].s0.x.__thread_id_x))))] = lerp(((upx$5[(((int64(cost_pyramid_pull[1].s0.c)*int64((upx$5.stride.2*2))) + ((int64(cost_pyramid_pull[1].s0.z.__thread_id_z)*int64(upx$5.stride.2)) + ((int64(((((((filtered_cost.s0.y.y_i.base/2) + cost_pyramid_pull[1].s0.y.__thread_id_y) + -1)/2) + (((((filtered_cost.s0.y.y_i.base/2) + cost_pyramid_pull[1].s0.y.__thread_id_y) + 1) % 2)*2)) - ((filtered_cost.s0.y.y_i.base + -6)/4)))*int64(((filtered_cost.s0.x.x_i.base % 2) + 10))) + int64(cost_pyramid_pull[1].s0.x.__thread_id_x)))) - int64(((filtered_cost.s0.x.x_i.base % 2) + 10)))] + (upx$5[((int64(cost_pyramid_pull[1].s0.c)*int64((upx$5.stride.2*2))) + ((int64(cost_pyramid_pull[1].s0.z.__thread_id_z)*int64(upx$5.stride.2)) + ((int64((((((filtered_cost.s0.y.y_i.base/2) + cost_pyramid_pull[1].s0.y.__thread_id_y) + -1)/2) - ((filtered_cost.s0.y.y_i.base + -6)/4)))*int64(((filtered_cost.s0.x.x_i.base % 2) + 10))) + int64(cost_pyramid_pull[1].s0.x.__thread_id_x))))]*3.000000f))*0.250000f), downy[((int64(cost_pyramid_pull[1].s0.c)*int64((max(slices, 2)*downy.stride.2))) + ((int64((((cost_pyramid_pull[1].s0.z.__thread_id_z + filtered_cost.s0.z.z_i.base) - min(slices, 2)) + 2))*int64(downy.stride.2)) + ((int64(((max(min(likely((((filtered_cost.s0.y.y_i.base/2) + cost_pyramid_pull[1].s0.y.__thread_id_y) + -1)), ((left_im.extent.1/2) + -1)), 0) - downy.y.min_realized.s) + 13))*int64((downy.x.extent_realized.s + -63))) + int64((max(min(likely((((filtered_cost.s0.x.x_i.base/2) + cost_pyramid_pull[1].s0.x.__thread_id_x) + -1)), ((left_im.extent.0/2) + -1)), 0) - downy.x.min_realized)))))], 0.500000f)
                            }
                          }
                        }
                      }
                    }
                  }
                  allocate upx$6[float32 * 16 * ((filtered_cost.s0.y.y_i.base % 2) + 10) * 2 * 2]
                  let upx$6.s0.y.__thread_id_y.loop_extent = (let t103937 = min(((filtered_cost.s0.y.y_o.__block_id_y*16) + argmin.s1.y.min), (argmin.s1.y.max.s + -16)) in ((t103937 % 2) + 10))
                  produce upx$6 {
                    consume cost_pyramid_pull[1] {
                      gpu_thread<CUDA> (upx$6.s0.y.__thread_id_y, 0, upx$6.s0.y.__thread_id_y.loop_extent) {
                        gpu_thread<CUDA> (upx$6.s0.x.__thread_id_x, 0, 16) {
                          for (upx$6.s0._0, filtered_cost.s0.z.z_i.base, 2) {
                            for (upx$6.s0._1, 0, 2) {
                              upx$6[((int64(upx$6.s0._1)*int64((((filtered_cost.s0.y.y_i.base % 2)*32) + 320))) + ((int64((upx$6.s0._0 - filtered_cost.s0.z.z_i.base))*int64((((filtered_cost.s0.y.y_i.base % 2)*16) + 160))) + ((int64(upx$6.s0.y.__thread_id_y)*(int64)16) + int64(upx$6.s0.x.__thread_id_x))))] = ((cost_pyramid_pull[1][(((int64(upx$6.s0._1)*int64((cost_pyramid_pull[1].stride.2*2))) + ((int64((upx$6.s0._0 - filtered_cost.s0.z.z_i.base))*int64(cost_pyramid_pull[1].stride.2)) + ((int64(upx$6.s0.y.__thread_id_y)*int64(((filtered_cost.s0.x.x_i.base % 2) + 10))) + int64((((((filtered_cost.s0.x.x_i.base + upx$6.s0.x.__thread_id_x)/2) + (((filtered_cost.s0.x.x_i.base + upx$6.s0.x.__thread_id_x) % 2)*2)) - (filtered_cost.s0.x.x_i.base/2)) + 1))))) + (int64)-1)] + (cost_pyramid_pull[1][((int64(upx$6.s0._1)*int64((cost_pyramid_pull[1].stride.2*2))) + ((int64((upx$6.s0._0 - filtered_cost.s0.z.z_i.base))*int64(cost_pyramid_pull[1].stride.2)) + ((int64(upx$6.s0.y.__thread_id_y)*int64(((filtered_cost.s0.x.x_i.base % 2) + 10))) + int64(((((filtered_cost.s0.x.x_i.base % 2) + upx$6.s0.x.__thread_id_x)/2) + 1)))))]*3.000000f))*0.250000f)
                            }
                          }
                        }
                      }
                    }
                  }
                  consume upx$6 {
                    gpu_thread<CUDA> (filtered_cost.s0.z.z_i.__thread_id_z, 0, 2) {
                      gpu_thread<CUDA> (filtered_cost.s0.y.y_i.__thread_id_y, 0, 16) {
                        gpu_thread<CUDA> (filtered_cost.s0.x.x_i.__thread_id_x, 0, 16) {
                          filtered_cost[((int64((((filtered_cost.s0.z.z_i.__thread_id_z + filtered_cost.s0.z.z_i.base) - min(slices, 2)) + 2))*int64(((filtered_cost.x.extent_realized.s + 16)*filtered_cost.y.extent_realized))) + ((int64(((filtered_cost.s0.y.y_i.__thread_id_y + filtered_cost.s0.y.y_i.base) - filtered_cost.y.min_realized))*int64((filtered_cost.x.extent_realized.s + 16))) + int64(((filtered_cost.s0.x.x_i.__thread_id_x + filtered_cost.s0.x.x_i.base) - filtered_cost.x.min_realized))))] = (let t103744.s = (((filtered_cost.s0.y.y_i.__thread_id_y + filtered_cost.s0.y.y_i.base)/2) + (((filtered_cost.s0.y.y_i.__thread_id_y + filtered_cost.s0.y.y_i.base) % 2)*2)) in (let t103745 = cost_confidence[((int64(((filtered_cost.s0.y.y_i.__thread_id_y + filtered_cost.s0.y.y_i.base) - cost_confidence.y.min_realized))*int64((cost_confidence.x.extent_realized.s + -125))) + int64(((filtered_cost.s0.x.x_i.__thread_id_x + filtered_cost.s0.x.x_i.base) - cost_confidence.x.min_realized)))] in (let t103746.s = diff[((int64((((filtered_cost.s0.z.z_i.__thread_id_z + filtered_cost.s0.z.z_i.base) - downy$6._0.min_realized.s) + 4))*int64(((diff.x.extent_realized.s + -128)*diff.y.extent_realized))) + ((int64(((filtered_cost.s0.y.y_i.__thread_id_y + filtered_cost.s0.y.y_i.base) - diff.y.min_realized))*int64((diff.x.extent_realized.s + -128))) + int64(((filtered_cost.s0.x.x_i.__thread_id_x + filtered_cost.s0.x.x_i.base) - diff.x.min_realized))))] in (let t103747.s = diff[(((int64((((filtered_cost.s0.z.z_i.__thread_id_z + filtered_cost.s0.z.z_i.base) - downy$6._0.min_realized.s) + 4))*int64(((diff.x.extent_realized.s + -128)*diff.y.extent_realized))) + ((int64(((filtered_cost.s0.y.y_i.__thread_id_y + filtered_cost.s0.y.y_i.base) - diff.y.min_realized))*int64((diff.x.extent_realized.s + -128))) + int64(((filtered_cost.s0.x.x_i.__thread_id_x + filtered_cost.s0.x.x_i.base) - diff.x.min_realized)))) + int64(diff.stride.3))] in (let t103748.s = diff[((int64(diff.stride.3)*(int64)2) + ((int64((((filtered_cost.s0.z.z_i.__thread_id_z + filtered_cost.s0.z.z_i.base) - downy$6._0.min_realized.s) + 4))*int64(((diff.x.extent_realized.s + -128)*diff.y.extent_realized))) + ((int64(((filtered_cost.s0.y.y_i.__thread_id_y + filtered_cost.s0.y.y_i.base) - diff.y.min_realized))*int64((diff.x.extent_realized.s + -128))) + int64(((filtered_cost.s0.x.x_i.__thread_id_x + filtered_cost.s0.x.x_i.base) - diff.x.min_realized)))))] in (let t103749.s = ((float32(t103748.s)*float32(t103748.s)) + ((float32(t103746.s)*float32(t103746.s)) + (float32(t103747.s)*float32(t103747.s)))) in (lerp(((upx$6[(((int64(filtered_cost.s0.z.z_i.__thread_id_z)*int64((((filtered_cost.s0.y.y_i.base % 2)*16) + 160))) + ((int64(((t103744.s - (filtered_cost.s0.y.y_i.base/2)) + 1))*(int64)16) + int64(filtered_cost.s0.x.x_i.__thread_id_x))) + (int64)-16)] + (upx$6[((int64(filtered_cost.s0.z.z_i.__thread_id_z)*int64((((filtered_cost.s0.y.y_i.base % 2)*16) + 160))) + ((int64(((((filtered_cost.s0.y.y_i.__thread_id_y + filtered_cost.s0.y.y_i.base)/2) - (filtered_cost.s0.y.y_i.base/2)) + 1))*(int64)16) + int64(filtered_cost.s0.x.x_i.__thread_id_x)))]*3.000000f))*0.250000f), (t103745*t103749.s), 0.500000f)/lerp(((upx$6[((((int64(filtered_cost.s0.z.z_i.__thread_id_z)*int64((((filtered_cost.s0.y.y_i.base % 2)*16) + 160))) + ((int64(((t103744.s - (filtered_cost.s0.y.y_i.base/2)) + 1))*(int64)16) + int64(filtered_cost.s0.x.x_i.__thread_id_x))) + int64((((filtered_cost.s0.y.y_i.base % 2)*32) + 320))) + (int64)-16)] + (upx$6[(((int64(filtered_cost.s0.z.z_i.__thread_id_z)*int64((((filtered_cost.s0.y.y_i.base % 2)*16) + 160))) + ((int64(((((filtered_cost.s0.y.y_i.__thread_id_y + filtered_cost.s0.y.y_i.base)/2) - (filtered_cost.s0.y.y_i.base/2)) + 1))*(int64)16) + int64(filtered_cost.s0.x.x_i.__thread_id_x))) + int64((((filtered_cost.s0.y.y_i.base % 2)*32) + 320)))]*3.000000f))*0.250000f), t103745, 0.500000f))))))))
                        }
                      }
                    }
                  }
                }
              }
            }
            let halide_device_free_result$13 = halide_device_free(diff.buffer)
            assert((halide_device_free_result$13 == 0), halide_device_free_result$13)
            let halide_device_free_result$12 = halide_device_free(cost_confidence.buffer)
            assert((halide_device_free_result$12 == 0), halide_device_free_result$12)
            let halide_device_free_result$11 = halide_device_free(downy.buffer)
            assert((halide_device_free_result$11 == 0), halide_device_free_result$11)
            let halide_device_free_result$3 = halide_device_free(cost_pyramid_pull[2].buffer)
            assert((halide_device_free_result$3 == 0), halide_device_free_result$3)
            _halide_buffer_set_device_dirty(filtered_cost.buffer, (uint1)1)
          }
        }
      }
    }
  }
  let argmin.y.min_realized = min(min(min(min(min(min((final.min.1 - maximum$1.s1.r$2$x.max), argmin.s1.y.min), ((final.extent.1 + final.min.1) + -8)), final.min.1), (final.min.1 - int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(max((slices - focus_depth), focus_depth)))))), (argmin.s1.y.max.s + -8)), argmin.s1.y.min)
  let argmin.y.extent_realized = (max(max(max(max(((((((argmin.s1.y.max.s - argmin.s1.y.min) + -1)/8)*8) + argmin.s1.y.min) + 8), ((final.extent.1 + final.min.1) + maximum$1.s1.r$2$x.max)), (final.extent.1 + final.min.1)), (max((0 - int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(max((slices - focus_depth), focus_depth))))), int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(max((slices - focus_depth), focus_depth))))) + (final.extent.1 + final.min.1))), min(((((((argmin.s1.y.max.s - argmin.s1.y.min) + -1)/8)*8) + argmin.s1.y.min) + 8), argmin.s1.y.max.s)) - min(min(min(min(min(min((final.min.1 - maximum$1.s1.r$2$x.max), argmin.s1.y.min), ((final.extent.1 + final.min.1) + -8)), final.min.1), (final.min.1 - int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(max((slices - focus_depth), focus_depth)))))), (argmin.s1.y.max.s + -8)), argmin.s1.y.min))
  let argmin.x.min_realized = min(min(min(min(min(min((final.min.0 - maximum$1.s1.r$2$x.max), argmin.s1.x.min), ((final.extent.0 + final.min.0) + -10)), final.min.0), (final.min.0 - int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(max((slices - focus_depth), focus_depth)))))), (argmin.s1.x.max.s + -8)), argmin.s1.x.min)
  let argmin.x.extent_realized = (max(max(max(max(((((((argmin.s1.x.max.s - argmin.s1.x.min) + -1)/16)*16) + argmin.s1.x.min) + 16), ((final.extent.0 + final.min.0) + maximum$1.s1.r$2$x.max)), (final.extent.0 + final.min.0)), (max((0 - int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(max((slices - focus_depth), focus_depth))))), int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(max((slices - focus_depth), focus_depth))))) + (final.extent.0 + final.min.0))), min(((((((argmin.s1.x.max.s - argmin.s1.x.min) + -1)/8)*8) + argmin.s1.x.min) + 8), argmin.s1.x.max.s)) - min(min(min(min(min(min((final.min.0 - maximum$1.s1.r$2$x.max), argmin.s1.x.min), ((final.extent.0 + final.min.0) + -10)), final.min.0), (final.min.0 - int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(max((slices - focus_depth), focus_depth)))))), (argmin.s1.x.max.s + -8)), argmin.s1.x.min))
  allocate argmin.0[int32 * argmin.x.extent_realized * argmin.y.extent_realized] if (uint1)0
  let argmin.0.buffer = (let t104129 = make_struct((halide_dimension_t *), argmin.x.min_realized, argmin.x.extent_realized, 1, 0, argmin.y.min_realized, argmin.y.extent_realized, argmin.x.extent_realized, 0) in _halide_buffer_init(alloca(size_of_halide_buffer_t()), t104129, reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, t104129, (uint64)0))
  register_destructor("halide_device_free_as_destructor", argmin.0.buffer)
  allocate argmin.1[float32 * argmin.x.extent_realized * argmin.y.extent_realized] if (uint1)0
  let argmin.1.buffer = (let t104128 = make_struct((halide_dimension_t *), argmin.x.min_realized, argmin.x.extent_realized, 1, 0, argmin.y.min_realized, argmin.y.extent_realized, argmin.x.extent_realized, 0) in _halide_buffer_init(alloca(size_of_halide_buffer_t()), t104128, reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 2, t104128, (uint64)0))
  register_destructor("halide_device_free_as_destructor", argmin.1.buffer)
  produce argmin {
    let halide_device_malloc_result = halide_device_malloc(argmin.1.buffer, halide_cuda_device_interface())
    assert((halide_device_malloc_result == 0), halide_device_malloc_result)
    let halide_device_malloc_result$1 = halide_device_malloc(argmin.0.buffer, halide_cuda_device_interface())
    assert((halide_device_malloc_result$1 == 0), halide_device_malloc_result$1)
    gpu_block<CUDA> (argmin.s0.y.y_o.__block_id_y, 0, (((argmin.s1.y.max.s - argmin.s1.y.min) + 7)/8)) {
      let argmin.s0.y.y_i.base = min(likely_if_innermost(((argmin.s0.y.y_o.__block_id_y*8) + argmin.s1.y.min)), (argmin.s1.y.max.s + -8))
      gpu_block<CUDA> (argmin.s0.x.x_o.__block_id_x, 0, (((argmin.s1.x.max.s - argmin.s1.x.min) + 7)/8)) {
        let argmin.s0.x.x_i.base = min(likely_if_innermost(((argmin.s0.x.x_o.__block_id_x*8) + argmin.s1.x.min)), (argmin.s1.x.max.s + -8))
        gpu_thread<CUDA> (argmin.s0.y.y_i.__thread_id_y, 0, 8) {
          gpu_thread<CUDA> (argmin.s0.x.x_i.__thread_id_x, 0, 8) {
            argmin.0[((int64(((argmin.s0.y.y_i.__thread_id_y + argmin.s0.y.y_i.base) - argmin.y.min_realized))*int64(argmin.x.extent_realized)) + int64(((argmin.s0.x.x_i.__thread_id_x + argmin.s0.x.x_i.base) - argmin.x.min_realized)))] = 0
            argmin.1[((int64(((argmin.s0.y.y_i.__thread_id_y + argmin.s0.y.y_i.base) - argmin.y.min_realized))*int64(argmin.x.extent_realized)) + int64(((argmin.s0.x.x_i.__thread_id_x + argmin.s0.x.x_i.base) - argmin.x.min_realized)))] = inff
          }
        }
      }
    }
    _halide_buffer_set_device_dirty(argmin.0.buffer, (uint1)1)
    _halide_buffer_set_device_dirty(argmin.1.buffer, (uint1)1)
    consume filtered_cost {
      gpu_block<CUDA> (argmin.s1.y.y_o.__block_id_y, 0, (((argmin.s1.y.max.s - argmin.s1.y.min) + 7)/8)) {
        gpu_block<CUDA> (argmin.s1.x.x_o.__block_id_x, 0, (((argmin.s1.x.max.s - argmin.s1.x.min) + 15)/16)) {
          gpu_thread<CUDA> (argmin.s1.y.y_i.__thread_id_y, 0, 8) {
            gpu_thread<CUDA> (argmin.s1.x.x_i.__thread_id_x, 0, 16) {
              for (argmin.s1.r$1$x, 0, slices) {
                let argmin.0.value = select((filtered_cost[((int64(((argmin.s1.r$1$x - min(slices, 2)) + 2))*int64(((filtered_cost.x.extent_realized.s + 16)*filtered_cost.y.extent_realized))) + ((int64(((((argmin.s1.y.y_o.__block_id_y*8) + argmin.s1.y.min) + argmin.s1.y.y_i.__thread_id_y) - filtered_cost.y.min_realized))*int64((filtered_cost.x.extent_realized.s + 16))) + int64(((((argmin.s1.x.x_o.__block_id_x*16) + argmin.s1.x.min) + argmin.s1.x.x_i.__thread_id_x) - filtered_cost.x.min_realized))))] < argmin.1[((int64(((((argmin.s1.y.y_o.__block_id_y*8) + argmin.s1.y.min) + argmin.s1.y.y_i.__thread_id_y) - argmin.y.min_realized))*int64(argmin.x.extent_realized)) + int64(((((argmin.s1.x.x_o.__block_id_x*16) + argmin.s1.x.min) + argmin.s1.x.x_i.__thread_id_x) - argmin.x.min_realized)))]), argmin.s1.r$1$x, argmin.0[((int64(((((argmin.s1.y.y_o.__block_id_y*8) + argmin.s1.y.min) + argmin.s1.y.y_i.__thread_id_y) - argmin.y.min_realized))*int64(argmin.x.extent_realized)) + int64(((((argmin.s1.x.x_o.__block_id_x*16) + argmin.s1.x.min) + argmin.s1.x.x_i.__thread_id_x) - argmin.x.min_realized)))])
                let argmin.1.value = (let argmin.s1.t13 = filtered_cost[((int64(((argmin.s1.r$1$x - min(slices, 2)) + 2))*int64(((filtered_cost.x.extent_realized.s + 16)*filtered_cost.y.extent_realized))) + ((int64(((((argmin.s1.y.y_o.__block_id_y*8) + argmin.s1.y.min) + argmin.s1.y.y_i.__thread_id_y) - filtered_cost.y.min_realized))*int64((filtered_cost.x.extent_realized.s + 16))) + int64(((((argmin.s1.x.x_o.__block_id_x*16) + argmin.s1.x.min) + argmin.s1.x.x_i.__thread_id_x) - filtered_cost.x.min_realized))))] in (let argmin.s1.t14 = argmin.1[((int64(((((argmin.s1.y.y_o.__block_id_y*8) + argmin.s1.y.min) + argmin.s1.y.y_i.__thread_id_y) - argmin.y.min_realized))*int64(argmin.x.extent_realized)) + int64(((((argmin.s1.x.x_o.__block_id_x*16) + argmin.s1.x.min) + argmin.s1.x.x_i.__thread_id_x) - argmin.x.min_realized)))] in min(argmin.s1.t13, argmin.s1.t14)))
                argmin.0[((int64(((((argmin.s1.y.y_o.__block_id_y*8) + argmin.s1.y.min) + argmin.s1.y.y_i.__thread_id_y) - argmin.y.min_realized))*int64(argmin.x.extent_realized)) + int64(((((argmin.s1.x.x_o.__block_id_x*16) + argmin.s1.x.min) + argmin.s1.x.x_i.__thread_id_x) - argmin.x.min_realized)))] = argmin.0.value
                argmin.1[((int64(((((argmin.s1.y.y_o.__block_id_y*8) + argmin.s1.y.min) + argmin.s1.y.y_i.__thread_id_y) - argmin.y.min_realized))*int64(argmin.x.extent_realized)) + int64(((((argmin.s1.x.x_o.__block_id_x*16) + argmin.s1.x.min) + argmin.s1.x.x_i.__thread_id_x) - argmin.x.min_realized)))] = argmin.1.value
              }
            }
          }
        }
      }
      let halide_device_free_result$2 = halide_device_free(filtered_cost.buffer)
      assert((halide_device_free_result$2 == 0), halide_device_free_result$2)
      let halide_device_free_result = halide_device_free(argmin.1.buffer)
      assert((halide_device_free_result == 0), halide_device_free_result)
    }
  }
  assert(((0 <= final.min.2) && ((final.extent.2 + final.min.2) <= 3)), halide_error_explicit_bounds_too_small("c", "final", 0, 2, final.min.2, ((final.extent.2 + final.min.2) + -1)))
  produce final {
    consume argmin {
      consume repeat_edge {
        let halide_copy_to_device_result = halide_copy_to_device(final.buffer, halide_cuda_device_interface())
        assert((halide_copy_to_device_result == 0), halide_copy_to_device_result)
        gpu_block<CUDA> (final.s0.y.y_o.__block_id_y, 0, ((final.extent.1 + 7)/8)) {
          let final.s0.y.y_i.base = min(likely_if_innermost(((final.s0.y.y_o.__block_id_y*8) + final.min.1)), ((final.extent.1 + final.min.1) + -8))
          gpu_block<CUDA> (final.s0.x.x_o.__block_id_x, 0, ((final.extent.0 + 9)/10)) {
            let final.s0.x.x_i.base = min(likely_if_innermost(((final.s0.x.x_o.__block_id_x*10) + final.min.0)), ((final.extent.0 + final.min.0) + -10))
            let maximum$1.s1.r$2$x.max_1 = maximum.s1.r$2$x.max
            let maximum$1.s1.r$2$x.min_1 = maximum$1.s1.r$2$x.min
            let maximum.s1.r$2$x.max_1 = maximum.s1.r$2$x.max
            let maximum.s1.r$2$x.min_1 = maximum$1.s1.r$2$x.min
            allocate maximum[float32 * ((maximum.s1.r$2$x.max - maximum$1.s1.r$2$x.min) + 10) * 8]
            let maximum.s0.x.__thread_id_x.loop_extent = (let t103979 = maximum.s1.r$2$x.max in ((maximum.s1.r$2$x.max*2) + 10))
            let maximum.s1.x.__thread_id_x.loop_extent = (let t103985 = maximum.s1.r$2$x.max in ((maximum.s1.r$2$x.max*2) + 10))
            produce maximum {
              gpu_thread<CUDA> (maximum.s0.y.__thread_id_y, 0, 8) {
                gpu_thread<CUDA> (maximum.s0.x.__thread_id_x, 0, maximum.s0.x.__thread_id_x.loop_extent) {
                  maximum[((int64(maximum.s0.y.__thread_id_y)*int64(((maximum.s1.r$2$x.max - maximum$1.s1.r$2$x.min) + 10))) + int64(maximum.s0.x.__thread_id_x))] = -inff
                }
              }
              gpu_thread<CUDA> (maximum.s1.y.__thread_id_y, 0, 8) {
                gpu_thread<CUDA> (maximum.s1.x.__thread_id_x, 0, maximum.s1.x.__thread_id_x.loop_extent) {
                  for (maximum.s1.r$2$x, maximum$1.s1.r$2$x.min, ((maximum.s1.r$2$x.max - maximum$1.s1.r$2$x.min) + 1)) {
                    maximum[((int64(maximum.s1.y.__thread_id_y)*int64(((maximum.s1.r$2$x.max - maximum$1.s1.r$2$x.min) + 10))) + int64(maximum.s1.x.__thread_id_x))] = max(maximum[((int64(maximum.s1.y.__thread_id_y)*int64(((maximum.s1.r$2$x.max - maximum$1.s1.r$2$x.min) + 10))) + int64(maximum.s1.x.__thread_id_x))], (max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(abs((argmin.0[((int64((((final.s0.y.y_i.base + maximum.s1.y.__thread_id_y) + maximum.s1.r$2$x) - argmin.y.min_realized))*int64(argmin.x.extent_realized)) + int64((((final.s0.x.x_i.base + maximum$1.s1.r$2$x.min) + maximum.s1.x.__thread_id_x) - argmin.x.min_realized)))] - focus_depth)))))
                  }
                }
              }
            }
            allocate maximum$1[float32 * 10 * 8]
            produce maximum$1 {
              gpu_thread<CUDA> (maximum$1.s0.y.__thread_id_y, 0, 8) {
                gpu_thread<CUDA> (maximum$1.s0.x.__thread_id_x, 0, 10) {
                  maximum$1[((int64(maximum$1.s0.y.__thread_id_y)*(int64)10) + int64(maximum$1.s0.x.__thread_id_x))] = -inff
                }
              }
              consume maximum {
                gpu_thread<CUDA> (maximum$1.s1.y.__thread_id_y, 0, 8) {
                  gpu_thread<CUDA> (maximum$1.s1.x.__thread_id_x, 0, 10) {
                    for (maximum$1.s1.r$2$x, maximum$1.s1.r$2$x.min, ((maximum.s1.r$2$x.max - maximum$1.s1.r$2$x.min) + 1)) {
                      maximum$1[((int64(maximum$1.s1.y.__thread_id_y)*(int64)10) + int64(maximum$1.s1.x.__thread_id_x))] = max(maximum[((int64(maximum$1.s1.y.__thread_id_y)*int64(((maximum.s1.r$2$x.max - maximum$1.s1.r$2$x.min) + 10))) + int64((((final.s0.x.x_i.base + maximum$1.s1.x.__thread_id_x) + maximum$1.s1.r$2$x) - (final.s0.x.x_i.base + maximum$1.s1.r$2$x.min))))], maximum$1[((int64(maximum$1.s1.y.__thread_id_y)*(int64)10) + int64(maximum$1.s1.x.__thread_id_x))])
                    }
                  }
                }
              }
            }
            allocate sample_weight[float32 * 10 * 8 * aperture_samples]
            produce sample_weight {
              consume maximum$1 {
                gpu_thread<CUDA> (sample_weight.s0.y.__thread_id_y, 0, 8) {
                  gpu_thread<CUDA> (sample_weight.s0.x.__thread_id_x, 0, 10) {
                    for (sample_weight.s0.z, 0, aperture_samples) {
                      sample_weight[((int64(sample_weight.s0.z)*(int64)80) + ((int64(sample_weight.s0.y.__thread_id_y)*(int64)10) + int64(sample_weight.s0.x.__thread_id_x)))] = (let sample_weight.s0.t103686 = int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(max((slices - focus_depth), focus_depth)))) in (let sample_weight.s0.t103687.s = uint32((final.s0.x.x_i.base + sample_weight.s0.x.__thread_id_x)) in (let sample_weight.s0.t103688.s = ((((sample_weight.s0.t103687.s*(uint32)1040796640) + (uint32)1527534985)*(sample_weight.s0.t103687.s + (uint32)3392003200)) + uint32((final.s0.y.y_i.base + sample_weight.s0.y.__thread_id_y))) in (let sample_weight.s0.t103689.s = ((((sample_weight.s0.t103688.s*(uint32)1040796640) + (uint32)1337891305)*(sample_weight.s0.t103688.s + (uint32)576942909)) + uint32(sample_weight.s0.z)) in (let sample_weight.s0.t103690 = maximum$1[((int64(sample_weight.s0.y.__thread_id_y)*(int64)10) + int64(sample_weight.s0.x.__thread_id_x))] in (let sample_weight.s0.t103691 = max(min(sample_weight.s0.t103686, int32((((max(min(reinterpret(float32, bitwise_or(1065353216, reinterpret(int32, (((((sample_weight.s0.t103689.s*(uint32)1040796640) + (uint32)1337891305)*(sample_weight.s0.t103689.s + (uint32)576942909)) + (uint32)576942909)/(uint32)512)))), 2.000000f), 1.000000f)*2.000000f) + -3.000000f)*sample_weight.s0.t103690))), (0 - sample_weight.s0.t103686)) in (let sample_weight.s0.t103692.s = sample_weight.s0.t103687.s in (let sample_weight.s0.t103693.s = ((((sample_weight.s0.t103692.s*(uint32)1040796640) + (uint32)2753653065)*(sample_weight.s0.t103692.s + (uint32)475272354)) + uint32((final.s0.y.y_i.base + sample_weight.s0.y.__thread_id_y))) in (let sample_weight.s0.t103694.s = ((((sample_weight.s0.t103693.s*(uint32)1040796640) + (uint32)1337891305)*(sample_weight.s0.t103693.s + (uint32)576942909)) + uint32(sample_weight.s0.z)) in (let sample_weight.s0.t103695 = max(min(sample_weight.s0.t103686, int32((((max(min(reinterpret(float32, bitwise_or(1065353216, reinterpret(int32, (((((sample_weight.s0.t103694.s*(uint32)1040796640) + (uint32)1337891305)*(sample_weight.s0.t103694.s + (uint32)576942909)) + (uint32)576942909)/(uint32)512)))), 2.000000f), 1.000000f)*2.000000f) + -3.000000f)*sample_weight.s0.t103690))), (0 - sample_weight.s0.t103686)) in (let sample_weight.s0.t103696 = float32(((sample_weight.s0.t103691*sample_weight.s0.t103691) + (sample_weight.s0.t103695*sample_weight.s0.t103695))) in (let sample_weight.s0.t103697 = argmin.0[((int64(((final.s0.y.y_i.base + sample_weight.s0.y.__thread_id_y) - argmin.y.min_realized))*int64(argmin.x.extent_realized)) + int64(((final.s0.x.x_i.base + sample_weight.s0.x.__thread_id_x) - argmin.x.min_realized)))] in (let sample_weight.s0.t103698 = (max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(abs((sample_weight.s0.t103697 - focus_depth)))) in (let sample_weight.s0.t103699 = argmin.0[((int64((((final.s0.y.y_i.base + sample_weight.s0.y.__thread_id_y) + sample_weight.s0.t103695) - argmin.y.min_realized))*int64(argmin.x.extent_realized)) + int64((((final.s0.x.x_i.base + sample_weight.s0.x.__thread_id_x) + sample_weight.s0.t103691) - argmin.x.min_realized)))] in (let sample_weight.s0.t103700 = (max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(abs((sample_weight.s0.t103699 - focus_depth)))) in select((((sample_weight.s0.t103696 < (sample_weight.s0.t103698*sample_weight.s0.t103698)) || (sample_weight.s0.t103699 < sample_weight.s0.t103697)) && (sample_weight.s0.t103696 < (sample_weight.s0.t103700*sample_weight.s0.t103700))), 1.000000f, 0.000000f))))))))))))))))
                    }
                  }
                }
              }
            }
            allocate output[float32 * 10 * 8 * 4]
            produce output {
              gpu_thread<CUDA> (output.s0.y.__thread_id_y, 0, 8) {
                gpu_thread<CUDA> (output.s0.x.__thread_id_x, 0, 10) {
                  unrolled (output.s0.c, 0, 4) {
                    output[((int64(output.s0.c)*(int64)80) + ((int64(output.s0.y.__thread_id_y)*(int64)10) + int64(output.s0.x.__thread_id_x)))] = select((output.s0.c == 0), float32(repeat_edge[((int64(((final.s0.y.y_i.base + output.s0.y.__thread_id_y) - repeat_edge._1.min_realized))*int64((repeat_edge._0.extent_realized.s + 1))) + int64(((final.s0.x.x_i.base + output.s0.x.__thread_id_x) - repeat_edge._0.min_realized)))]), select((output.s0.c == 1), float32(repeat_edge[(((int64(((final.s0.y.y_i.base + output.s0.y.__thread_id_y) - repeat_edge._1.min_realized))*int64((repeat_edge._0.extent_realized.s + 1))) + int64(((final.s0.x.x_i.base + output.s0.x.__thread_id_x) - repeat_edge._0.min_realized))) + int64(repeat_edge.stride.2))]), select((output.s0.c == 2), float32(repeat_edge[((int64(repeat_edge.stride.2)*(int64)2) + ((int64(((final.s0.y.y_i.base + output.s0.y.__thread_id_y) - repeat_edge._1.min_realized))*int64((repeat_edge._0.extent_realized.s + 1))) + int64(((final.s0.x.x_i.base + output.s0.x.__thread_id_x) - repeat_edge._0.min_realized))))]), 255.000000f)))
                  }
                }
              }
              consume sample_weight {
                consume maximum$1 {
                  gpu_thread<CUDA> (output.s1.y.__thread_id_y, 0, 8) {
                    gpu_thread<CUDA> (output.s1.x.__thread_id_x, 0, 10) {
                      for (output.s1.s$x, 0, aperture_samples) {
                        unrolled (output.s1.c, 0, 4) {
                          output[((int64(output.s1.c)*(int64)80) + ((int64(output.s1.y.__thread_id_y)*(int64)10) + int64(output.s1.x.__thread_id_x)))] = (let output.s1.t103652 = int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(max((slices - focus_depth), focus_depth)))) in (let output.s1.t103653.s = uint32((final.s0.x.x_i.base + output.s1.x.__thread_id_x)) in (let output.s1.t103654.s = ((((output.s1.t103653.s*(uint32)1040796640) + (uint32)1527534985)*(output.s1.t103653.s + (uint32)3392003200)) + uint32((final.s0.y.y_i.base + output.s1.y.__thread_id_y))) in (let output.s1.t103655.s = ((((output.s1.t103654.s*(uint32)1040796640) + (uint32)1337891305)*(output.s1.t103654.s + (uint32)576942909)) + uint32(output.s1.s$x)) in (let output.s1.t103656 = maximum$1[((int64(output.s1.y.__thread_id_y)*(int64)10) + int64(output.s1.x.__thread_id_x))] in (let output.s1.t103657.s = output.s1.t103653.s in (let output.s1.t103658.s = ((((output.s1.t103657.s*(uint32)1040796640) + (uint32)2753653065)*(output.s1.t103657.s + (uint32)475272354)) + uint32((final.s0.y.y_i.base + output.s1.y.__thread_id_y))) in (let output.s1.t103659.s = ((((output.s1.t103658.s*(uint32)1040796640) + (uint32)1337891305)*(output.s1.t103658.s + (uint32)576942909)) + uint32(output.s1.s$x)) in (let output.s1.t103660.s = max(min(output.s1.t103652, int32((((max(min(reinterpret(float32, bitwise_or(1065353216, reinterpret(int32, (((((output.s1.t103659.s*(uint32)1040796640) + (uint32)1337891305)*(output.s1.t103659.s + (uint32)576942909)) + (uint32)576942909)/(uint32)512)))), 2.000000f), 1.000000f)*2.000000f) + -3.000000f)*output.s1.t103656))), (0 - output.s1.t103652)) in (let output.s1.t103661.s = max(min(output.s1.t103652, int32((((max(min(reinterpret(float32, bitwise_or(1065353216, reinterpret(int32, (((((output.s1.t103655.s*(uint32)1040796640) + (uint32)1337891305)*(output.s1.t103655.s + (uint32)576942909)) + (uint32)576942909)/(uint32)512)))), 2.000000f), 1.000000f)*2.000000f) + -3.000000f)*output.s1.t103656))), (0 - output.s1.t103652)) in (output[((int64(output.s1.c)*(int64)80) + ((int64(output.s1.y.__thread_id_y)*(int64)10) + int64(output.s1.x.__thread_id_x)))] + (sample_weight[((int64(output.s1.s$x)*(int64)80) + ((int64(output.s1.y.__thread_id_y)*(int64)10) + int64(output.s1.x.__thread_id_x)))]*select((output.s1.c == 0), float32(repeat_edge[((int64((((final.s0.y.y_i.base + output.s1.y.__thread_id_y) + output.s1.t103660.s) - repeat_edge._1.min_realized))*int64((repeat_edge._0.extent_realized.s + 1))) + int64((((final.s0.x.x_i.base + output.s1.x.__thread_id_x) + output.s1.t103661.s) - repeat_edge._0.min_realized)))]), select((output.s1.c == 1), float32(repeat_edge[(((int64((((final.s0.y.y_i.base + output.s1.y.__thread_id_y) + output.s1.t103660.s) - repeat_edge._1.min_realized))*int64((repeat_edge._0.extent_realized.s + 1))) + int64((((final.s0.x.x_i.base + output.s1.x.__thread_id_x) + output.s1.t103661.s) - repeat_edge._0.min_realized))) + int64(repeat_edge.stride.2))]), select((output.s1.c == 2), float32(repeat_edge[((int64(repeat_edge.stride.2)*(int64)2) + ((int64((((final.s0.y.y_i.base + output.s1.y.__thread_id_y) + output.s1.t103660.s) - repeat_edge._1.min_realized))*int64((repeat_edge._0.extent_realized.s + 1))) + int64((((final.s0.x.x_i.base + output.s1.x.__thread_id_x) + output.s1.t103661.s) - repeat_edge._0.min_realized))))]), 255.000000f)))))))))))))))
                        }
                      }
                    }
                  }
                }
              }
            }
            consume output {
              gpu_thread<CUDA> (final.s0.y.y_i.__thread_id_y, 0, 8) {
                gpu_thread<CUDA> (final.s0.x.x_i.__thread_id_x, 0, 10) {
                  unrolled (final.s0.c, 0, 3) {
                    final[(((int64(final.s0.c)*int64(final.stride.2)) + ((int64((final.s0.y.y_i.__thread_id_y + final.s0.y.y_i.base))*int64(final.stride.1)) + int64((final.s0.x.x_i.__thread_id_x + final.s0.x.x_i.base)))) - ((int64(final.min.1)*int64(final.stride.1)) + int64(final.min.0)))] = (output[((int64(final.s0.c)*(int64)80) + ((int64(final.s0.y.y_i.__thread_id_y)*(int64)10) + int64(final.s0.x.x_i.__thread_id_x)))]/output[(((int64(final.s0.y.y_i.__thread_id_y)*(int64)10) + int64(final.s0.x.x_i.__thread_id_x)) + (int64)240)])
                  }
                }
              }
            }
          }
        }
        _halide_buffer_set_device_dirty(final.buffer, (uint1)1)
        let halide_device_free_result$15 = halide_device_free(repeat_edge.buffer)
        assert((halide_device_free_result$15 == 0), halide_device_free_result$15)
        let halide_device_free_result$1 = halide_device_free(argmin.0.buffer)
        assert((halide_device_free_result$1 == 0), halide_device_free_result$1)
      }
    }
  }
}

Simplifying correlated differences...
Unrolling...
Vectorizing...
Injecting per-block gpu synchronization...
User error triggered at /home/ssioutas/Halide_RTX/src/FuseGPUThreadLoops.cpp:325
Warning:
Shared allocation for cost_pyramid_pull[5] has a size that is non-monontonic in the gpu block variable upx$2.s0.x.x_o.__block_id_x: (((min(((argmin.s1.x.max.s + -83)/16), (((argmin.s1.x.min + -30)/16) + (upx$2.s0.x.x_o.__block_id_x*8))) % 2)*32) + 192)
User error triggered at /home/ssioutas/Halide_RTX/src/FuseGPUThreadLoops.cpp:325
Warning:
Shared allocation for upx has a size that is non-monontonic in the gpu block variable upx$2.s0.x.x_o.__block_id_x: ((((((min(((argmin.s1.x.max.s + -83)/16), (((argmin.s1.x.min + -30)/16) + (upx$2.s0.x.x_o.__block_id_x*8))) + 2) % 4) + 23)/4)*((((upx$2.s0.y.y_i.base + 2) % 4) + 23)/4))*4)
User error triggered at /home/ssioutas/Halide_RTX/src/FuseGPUThreadLoops.cpp:325
Warning:
Shared allocation for cost_pyramid_pull[3] has a size that is non-monontonic in the gpu block variable cost_pyramid_pull[2].s0.x.x_o.__block_id_x: ((((min(((argmin.s1.x.max.s + -55)/4), (((argmin.s1.x.min + -6)/4) + (cost_pyramid_pull[2].s0.x.x_o.__block_id_x*16))) % 2)*(((cost_pyramid_pull[2].s0.y.y_i.base % 2)*4) + 40)) + ((cost_pyramid_pull[2].s0.y.y_i.base % 2)*40)) + 400)
User error triggered at /home/ssioutas/Halide_RTX/src/FuseGPUThreadLoops.cpp:325
Warning:
Shared allocation for upx$3 has a size that is non-monontonic in the gpu block variable cost_pyramid_pull[2].s0.x.x_o.__block_id_x: ((((((cost_pyramid_pull[2].s0.y.y_i.base + 2) % 4) + 31)/4)*((min(((argmin.s1.x.max.s + -55)/4), (((argmin.s1.x.min + -6)/4) + (cost_pyramid_pull[2].s0.x.x_o.__block_id_x*16))) % 2) + 10))*4)
User error triggered at /home/ssioutas/Halide_RTX/src/FuseGPUThreadLoops.cpp:325
Warning:
Shared allocation for cost_pyramid_pull[4] has a size that is non-monontonic in the gpu block variable cost_pyramid_pull[2].s0.x.x_o.__block_id_x: ((((((min(((argmin.s1.x.max.s + -55)/4), (((argmin.s1.x.min + -6)/4) + (cost_pyramid_pull[2].s0.x.x_o.__block_id_x*16))) + 2) % 4) + 31)/4)*((((cost_pyramid_pull[2].s0.y.y_i.base + 2) % 4) + 31)/4))*4)
User error triggered at /home/ssioutas/Halide_RTX/src/FuseGPUThreadLoops.cpp:325
Warning:
Shared allocation for upx$4 has a size that is non-monontonic in the gpu block variable cost_pyramid_pull[2].s0.y.y_o.__block_id_y: (((min(((argmin.s1.y.max.s + -55)/4), (((argmin.s1.y.min + -6)/4) + (cost_pyramid_pull[2].s0.y.y_o.__block_id_y*16))) % 2)*64) + 640)
User error triggered at /home/ssioutas/Halide_RTX/src/FuseGPUThreadLoops.cpp:325
Warning:
Shared allocation for cost_pyramid_pull[1] has a size that is non-monontonic in the gpu block variable filtered_cost.s0.x.x_o.__block_id_x: ((((min(((filtered_cost.s0.x.x_o.__block_id_x*16) + argmin.s1.x.min), (argmin.s1.x.max.s + -16)) % 2)*(((filtered_cost.s0.y.y_i.base % 2)*4) + 40)) + ((filtered_cost.s0.y.y_i.base % 2)*40)) + 400)
User error triggered at /home/ssioutas/Halide_RTX/src/FuseGPUThreadLoops.cpp:325
Warning:
Shared allocation for upx$5 has a size that is non-monontonic in the gpu block variable filtered_cost.s0.x.x_o.__block_id_x: ((((((filtered_cost.s0.y.y_i.base + 2) % 4) + 31)/4)*((min(((filtered_cost.s0.x.x_o.__block_id_x*16) + argmin.s1.x.min), (argmin.s1.x.max.s + -16)) % 2) + 10))*4)
User error triggered at /home/ssioutas/Halide_RTX/src/FuseGPUThreadLoops.cpp:325
Warning:
Shared allocation for upx$6 has a size that is non-monontonic in the gpu block variable filtered_cost.s0.y.y_o.__block_id_y: (((min(((filtered_cost.s0.y.y_o.__block_id_y*16) + argmin.s1.y.min), (argmin.s1.y.max.s + -16)) % 2)*64) + 640)
Detecting vector interleavings...
Partitioning loops to simplify boundary conditions...
Trimming loops to the region over which they do something...
Injecting early frees...
Simplifying correlated differences...
Bounding small allocations...
Injecting warp shuffles...
Simplifying...
Lowering unsafe promises...
Lowering after final simplification:
assert((reinterpret(uint64, right_im.buffer) != (uint64)0), halide_error_buffer_argument_is_null("right_im"))
assert((reinterpret(uint64, left_im.buffer) != (uint64)0), halide_error_buffer_argument_is_null("left_im"))
assert((reinterpret(uint64, final.buffer) != (uint64)0), halide_error_buffer_argument_is_null("final"))
let final = _halide_buffer_get_host(final.buffer)
let final.type = _halide_buffer_get_type(final.buffer)
let final.dimensions = _halide_buffer_get_dimensions(final.buffer)
let final.min.0 = _halide_buffer_get_min(final.buffer, 0)
let final.extent.0 = _halide_buffer_get_extent(final.buffer, 0)
let final.stride.0 = _halide_buffer_get_stride(final.buffer, 0)
let final.min.1 = _halide_buffer_get_min(final.buffer, 1)
let final.extent.1 = _halide_buffer_get_extent(final.buffer, 1)
let final.stride.1 = _halide_buffer_get_stride(final.buffer, 1)
let final.min.2 = _halide_buffer_get_min(final.buffer, 2)
let final.extent.2 = _halide_buffer_get_extent(final.buffer, 2)
let final.stride.2 = _halide_buffer_get_stride(final.buffer, 2)
let left_im = _halide_buffer_get_host(left_im.buffer)
let left_im.type = _halide_buffer_get_type(left_im.buffer)
let left_im.dimensions = _halide_buffer_get_dimensions(left_im.buffer)
let left_im.min.0 = _halide_buffer_get_min(left_im.buffer, 0)
let left_im.extent.0 = _halide_buffer_get_extent(left_im.buffer, 0)
let left_im.stride.0 = _halide_buffer_get_stride(left_im.buffer, 0)
let left_im.min.1 = _halide_buffer_get_min(left_im.buffer, 1)
let left_im.extent.1 = _halide_buffer_get_extent(left_im.buffer, 1)
let left_im.stride.1 = _halide_buffer_get_stride(left_im.buffer, 1)
let left_im.min.2 = _halide_buffer_get_min(left_im.buffer, 2)
let left_im.extent.2 = _halide_buffer_get_extent(left_im.buffer, 2)
let left_im.stride.2 = _halide_buffer_get_stride(left_im.buffer, 2)
let right_im = _halide_buffer_get_host(right_im.buffer)
let right_im.type = _halide_buffer_get_type(right_im.buffer)
let right_im.dimensions = _halide_buffer_get_dimensions(right_im.buffer)
let right_im.min.0 = _halide_buffer_get_min(right_im.buffer, 0)
let right_im.extent.0 = _halide_buffer_get_extent(right_im.buffer, 0)
let right_im.stride.0 = _halide_buffer_get_stride(right_im.buffer, 0)
let right_im.min.1 = _halide_buffer_get_min(right_im.buffer, 1)
let right_im.extent.1 = _halide_buffer_get_extent(right_im.buffer, 1)
let right_im.stride.1 = _halide_buffer_get_stride(right_im.buffer, 1)
let right_im.min.2 = _halide_buffer_get_min(right_im.buffer, 2)
let right_im.extent.2 = _halide_buffer_get_extent(right_im.buffer, 2)
let right_im.stride.2 = _halide_buffer_get_stride(right_im.buffer, 2)
let maximum$1.s1.r$2$x.max = int32((blur_radius_scale*float32(max((slices - focus_depth), focus_depth))))
let argmin.s1.y.max.s.s = max((0 - maximum$1.s1.r$2$x.max), maximum$1.s1.r$2$x.max)
let argmin.s1.y.min = (final.min.1 - max(maximum$1.s1.r$2$x.max, 0))
let argmin.s1.x.max.s.s = max((0 - maximum$1.s1.r$2$x.max), maximum$1.s1.r$2$x.max)
let argmin.s1.x.min = (final.min.0 - max(maximum$1.s1.r$2$x.max, 0))
let downy$6.s0.y.max.s = min((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 381), left_im.extent.1)
let downy$6.s0.y.min.s = min((left_im.extent.1 + 126), argmin.s1.y.min)
let downy$6.s0.x.max.s = min((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 381), left_im.extent.0)
let downy$6.s0.x.min.s = min((argmin.s1.x.min + -126), left_im.extent.0)
let downy$5.s0.y.max = max(min((max((downy$6.s0.y.max.s/128), 1)*2), ((left_im.extent.1/64) + -1)), (max((min((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 189), left_im.extent.1)/64), 1) + -1))
let downy$5.s0.y.min.s = min(min((left_im.extent.1/64), (max(((downy$6.s0.y.min.s + -254)/128), 0)*2)), (min((argmin.s1.y.min + -62), left_im.extent.1)/64))
let downy$5.s0.x.max.s = max(min((max((downy$6.s0.x.max.s/128), 1)*2), ((left_im.extent.0/64) + 1)), (max(max(min((left_im.extent.0/64), ((max((downy$6.s0.x.max.s/128), 1)*2) + 1)), (min((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 189), left_im.extent.0)/64)), 1) + 1))
let downy$5.s0.x.min.s = min(max(min((max((downy$6.s0.x.min.s/128), 1)*2), ((left_im.extent.0/64) + 1)), 2), (max(min(min((left_im.extent.0/64), ((max((downy$6.s0.x.min.s/128), 1)*2) + -2)), (min((argmin.s1.x.min + -62), left_im.extent.0)/64)), 1) + 1))
let downy$4.s0.y.max.s = min(max(((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 61)/32), ((downy$5.s0.y.max*2) + 2)), ((left_im.extent.1/32) + -1))
let downy$4.s0.y.min.s = min(min(((argmin.s1.y.min + -62)/32), ((max(downy$5.s0.y.min.s, 1)*2) + -3)), ((left_im.extent.1/32) + -1))
let downy$4.s0.x.max.s = max(min((downy$5.s0.x.max.s*2), ((left_im.extent.0/32) + 3)), (max(max(min((left_im.extent.0/32), ((downy$5.s0.x.max.s*2) + -1)), (min((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 93), left_im.extent.0)/32)), 1) + 3))
let downy$4.s0.x.min = min(max(((min((left_im.extent.0 + 30), argmin.s1.x.min) + -62)/32), 0), (min(max(min((downy$5.s0.x.min.s*2), ((left_im.extent.0/32) + 3)), 4), (max(min((left_im.extent.0/32), ((downy$5.s0.x.min.s*2) + -4)), 1) + 3)) + -4))
let downy$3.s0.y.max.s = min(max(((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 29)/16), ((max(downy$4.s0.y.max.s, 0)*2) + 2)), ((left_im.extent.1/16) + -1))
let downy$3.s0.y.min.s = min(((argmin.s1.y.min + -30)/16), (min((left_im.extent.1/16), (max(downy$4.s0.y.min.s, 0)*2)) + -1))
let downy$3.s0.x.max.s = max(min((downy$4.s0.x.max.s*2), ((left_im.extent.0/16) + 7)), (max(max(min((left_im.extent.0/16), ((downy$4.s0.x.max.s*2) + -5)), (min((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 45), left_im.extent.0)/16)), 1) + 7))
let downy$3.s0.x.min = min(max(((min((left_im.extent.0 + 14), argmin.s1.x.min) + -30)/16), 0), min(max(min((downy$4.s0.x.min*2), ((left_im.extent.0/16) + -1)), 0), (max(min((left_im.extent.0/16), (downy$4.s0.x.min*2)), 1) + -1)))
let downy$2.s0.y.max.s = min(max(((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 13)/8), ((max(downy$3.s0.y.max.s, 0)*2) + 2)), ((left_im.extent.1/8) + -1))
let downy$2.s0.y.min.s = min(((argmin.s1.y.min + -14)/8), (min((left_im.extent.1/8), (max(downy$3.s0.y.min.s, 0)*2)) + -1))
let downy$2.s0.x.max.s = max(min((downy$3.s0.x.max.s*2), ((left_im.extent.0/8) + 15)), (max(max(min((left_im.extent.0/8), ((downy$3.s0.x.max.s*2) + -13)), (min((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 21), left_im.extent.0)/8)), 1) + 15))
let downy$2.s0.x.min = min(max(((min((left_im.extent.0 + 6), argmin.s1.x.min) + -14)/8), 0), min(max(min((downy$3.s0.x.min*2), ((left_im.extent.0/8) + -1)), 0), (max(min((left_im.extent.0/8), (downy$3.s0.x.min*2)), 1) + -1)))
let downy$1.s0.y.max.s = min(max(((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 5)/4), ((max(downy$2.s0.y.max.s, 0)*2) + 2)), ((left_im.extent.1/4) + -1))
let downy$1.s0.y.min.s = min(((argmin.s1.y.min + -6)/4), (min((left_im.extent.1/4), (max(downy$2.s0.y.min.s, 0)*2)) + -1))
let downy$1.s0.x.max.s = max(min((downy$2.s0.x.max.s*2), ((left_im.extent.0/4) + 31)), (max(max(min((left_im.extent.0/4), ((downy$2.s0.x.max.s*2) + -29)), (min((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 9), left_im.extent.0)/4)), 1) + 31))
let downy$1.s0.x.min = min(max(((min((left_im.extent.0 + 2), argmin.s1.x.min) + -6)/4), 0), min(max(min((downy$2.s0.x.min*2), ((left_im.extent.0/4) + -1)), 0), (max(min((left_im.extent.0/4), (downy$2.s0.x.min*2)), 1) + -1)))
let downy.s0.y.max.s = min(max(((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 1)/2), ((max(downy$1.s0.y.max.s, 0)*2) + 2)), ((left_im.extent.1/2) + -1))
let downy.s0.y.min.s = min(min((argmin.s1.y.min/2), (max(downy$1.s0.y.min.s, 0)*2)), (left_im.extent.1/2))
let downy.s0.x.max.s = max(min((downy$1.s0.x.max.s*2), ((left_im.extent.0/2) + 63)), (max(max(min((left_im.extent.0/2), ((downy$1.s0.x.max.s*2) + -61)), (min((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 3), left_im.extent.0)/2)), 1) + 63))
let downy.s0.x.min = min(max(min((downy$1.s0.x.min*2), ((left_im.extent.0/2) + -1)), 0), (max(min(min((left_im.extent.0/2), (downy$1.s0.x.min*2)), (min(argmin.s1.x.min, left_im.extent.0)/2)), 1) + -1))
let cost_confidence.s0.y.max.s = max(((max(downy.s0.y.max.s, 0)*2) + 3), ((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1))
let cost_confidence.s0.y.min = min(((max(downy.s0.y.min.s, 1)*2) + -3), argmin.s1.y.min)
let cost_confidence.s0.x.max.s = max((downy.s0.x.max.s*2), (((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 125))
let cost_confidence.s0.x.min = min(((downy.s0.x.min*2) + -1), argmin.s1.x.min)
let repeat_edge.s0._1.max.s = max(((max(max((0 - maximum$1.s1.r$2$x.max), maximum$1.s1.r$2$x.max), 0) + final.extent.1) + final.min.1), cost_confidence.s0.y.max.s)
let repeat_edge.s0._1.min = min(min(cost_confidence.s0.y.min, final.min.1), (final.min.1 - maximum$1.s1.r$2$x.max))
let repeat_edge.s0._0.max.s = max((((max(max((0 - maximum$1.s1.r$2$x.max), maximum$1.s1.r$2$x.max), 0) + final.extent.0) + final.min.0) + 125), cost_confidence.s0.x.max.s)
let repeat_edge.s0._0.min = min(min(cost_confidence.s0.x.min, final.min.0), (final.min.0 - maximum$1.s1.r$2$x.max))
let final.extent.0.required.s = (min((((final.extent.0 + -1)/10)*10), (final.extent.0 + -10)) - min(final.extent.0, 10))
let final.extent.1.required.s = (min((((final.extent.1 + -1)/8)*8), (final.extent.1 + -8)) - min(final.extent.1, 8))
let final.stride.2.required = ((final.extent.0.required.s + 20)*(final.extent.1.required.s + 16))
let left_im.extent.0.required.s = (max((min(min(((((((repeat_edge.s0._0.max.s - repeat_edge.s0._0.min) + -126)/32)*32) + repeat_edge.s0._0.min) + 157), repeat_edge.s0._0.max.s), ((left_im.extent.0 + left_im.min.0) + 125)) + -126), left_im.min.0) - max(min(min((repeat_edge.s0._0.max.s + -157), repeat_edge.s0._0.min), ((left_im.extent.0 + left_im.min.0) + -1)), left_im.min.0))
let left_im.min.0.required = max(min(min((repeat_edge.s0._0.max.s + -157), repeat_edge.s0._0.min), ((left_im.extent.0 + left_im.min.0) + -1)), left_im.min.0)
let left_im.extent.1.required = (max(min(min(((((((repeat_edge.s0._1.max.s - repeat_edge.s0._1.min) + -1)/8)*8) + repeat_edge.s0._1.min) + 8), repeat_edge.s0._1.max.s), (left_im.extent.1 + left_im.min.1)), (left_im.min.1 + 1)) - max(min(min((repeat_edge.s0._1.max.s + -8), repeat_edge.s0._1.min), ((left_im.extent.1 + left_im.min.1) + -1)), left_im.min.1))
let left_im.min.1.required = max(min(min((repeat_edge.s0._1.max.s + -8), repeat_edge.s0._1.min), ((left_im.extent.1 + left_im.min.1) + -1)), left_im.min.1)
let left_im.extent.2.required = (max(min((left_im.extent.2 + left_im.min.2), 3), (left_im.min.2 + 1)) - max((min((left_im.extent.2 + left_im.min.2), 1) + -1), left_im.min.2))
let left_im.min.2.required = max((min((left_im.extent.2 + left_im.min.2), 1) + -1), left_im.min.2)
let right_im.extent.0.required.s = (max((min(min(((((((((slices*2) + cost_confidence.s0.x.max.s) - cost_confidence.s0.x.min) + -127)/32)*32) + cost_confidence.s0.x.min) + 158), ((slices*2) + cost_confidence.s0.x.max.s)), ((right_im.extent.0 + right_im.min.0) + 126)) + -127), right_im.min.0) - max(min(min((((slices*2) + cost_confidence.s0.x.max.s) + -158), cost_confidence.s0.x.min), ((right_im.extent.0 + right_im.min.0) + -1)), right_im.min.0))
let right_im.min.0.required = max(min(min((((slices*2) + cost_confidence.s0.x.max.s) + -158), cost_confidence.s0.x.min), ((right_im.extent.0 + right_im.min.0) + -1)), right_im.min.0)
let right_im.extent.1.required = (max(min(min(((((((cost_confidence.s0.y.max.s - cost_confidence.s0.y.min) + -1)/8)*8) + cost_confidence.s0.y.min) + 8), cost_confidence.s0.y.max.s), (right_im.extent.1 + right_im.min.1)), (right_im.min.1 + 1)) - max(min(min((cost_confidence.s0.y.max.s + -8), cost_confidence.s0.y.min), ((right_im.extent.1 + right_im.min.1) + -1)), right_im.min.1))
let right_im.min.1.required = max(min(min((cost_confidence.s0.y.max.s + -8), cost_confidence.s0.y.min), ((right_im.extent.1 + right_im.min.1) + -1)), right_im.min.1)
let right_im.extent.2.required = (max(min((right_im.extent.2 + right_im.min.2), 3), (right_im.min.2 + 1)) - max((min((right_im.extent.2 + right_im.min.2), 1) + -1), right_im.min.2))
let right_im.min.2.required = max((min((right_im.extent.2 + right_im.min.2), 1) + -1), right_im.min.2)
if (_halide_buffer_is_bounds_query(final.buffer)) {
  _halide_buffer_init(final.buffer, _halide_buffer_get_shape(final.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 3, make_struct((halide_dimension_t *), ((min(final.extent.0, 10) + final.min.0) + -10), (final.extent.0.required.s + 20), 1, 0, ((min(final.extent.1, 8) + final.min.1) + -8), (final.extent.1.required.s + 16), (final.extent.0.required.s + 20), 0, 0, 3, final.stride.2.required, 0), (uint64)0)
}
if (_halide_buffer_is_bounds_query(left_im.buffer)) {
  _halide_buffer_init(left_im.buffer, _halide_buffer_get_shape(left_im.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 1, 8, 3, make_struct((halide_dimension_t *), left_im.min.0.required, (left_im.extent.0.required.s + 1), 1, 0, left_im.min.1.required, left_im.extent.1.required, (left_im.extent.0.required.s + 1), 0, left_im.min.2.required, left_im.extent.2.required, ((left_im.extent.0.required.s + 1)*left_im.extent.1.required), 0), (uint64)0)
}
if (_halide_buffer_is_bounds_query(right_im.buffer)) {
  _halide_buffer_init(right_im.buffer, _halide_buffer_get_shape(right_im.buffer), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 1, 8, 3, make_struct((halide_dimension_t *), right_im.min.0.required, (right_im.extent.0.required.s + 1), 1, 0, right_im.min.1.required, right_im.extent.1.required, (right_im.extent.0.required.s + 1), 0, right_im.min.2.required, right_im.extent.2.required, ((right_im.extent.0.required.s + 1)*right_im.extent.1.required), 0), (uint64)0)
}
if (!(_halide_buffer_is_bounds_query(right_im.buffer) || (_halide_buffer_is_bounds_query(final.buffer) || _halide_buffer_is_bounds_query(left_im.buffer)))) {
  assert((final.type == (uint32)73730), halide_error_bad_type("Output buffer final", final.type, (uint32)73730))
  assert((final.dimensions == 3), halide_error_bad_dimensions("Output buffer final", final.dimensions, 3))
  assert((left_im.type == (uint32)67585), halide_error_bad_type("Input buffer left_im", left_im.type, (uint32)67585))
  assert((left_im.dimensions == 3), halide_error_bad_dimensions("Input buffer left_im", left_im.dimensions, 3))
  assert((right_im.type == (uint32)67585), halide_error_bad_type("Input buffer right_im", right_im.type, (uint32)67585))
  assert((right_im.dimensions == 3), halide_error_bad_dimensions("Input buffer right_im", right_im.dimensions, 3))
  assert(((10 <= final.extent.0) && ((((min(final.extent.0, 10) + final.min.0) + final.extent.0.required.s) + 10) <= (final.extent.0 + final.min.0))), halide_error_access_out_of_bounds("Output buffer final", 0, ((min(final.extent.0, 10) + final.min.0) + -10), (((min(final.extent.0, 10) + final.min.0) + final.extent.0.required.s) + 9), final.min.0, ((final.extent.0 + final.min.0) + -1)))
  assert(((8 <= final.extent.1) && ((((min(final.extent.1, 8) + final.min.1) + final.extent.1.required.s) + 8) <= (final.extent.1 + final.min.1))), halide_error_access_out_of_bounds("Output buffer final", 1, ((min(final.extent.1, 8) + final.min.1) + -8), (((min(final.extent.1, 8) + final.min.1) + final.extent.1.required.s) + 7), final.min.1, ((final.extent.1 + final.min.1) + -1)))
  assert(((final.min.2 <= 0) && (3 <= (final.extent.2 + final.min.2))), halide_error_access_out_of_bounds("Output buffer final", 2, 0, 2, final.min.2, ((final.extent.2 + final.min.2) + -1)))
  assert((0 <= final.extent.2), halide_error_buffer_extents_negative("Output buffer final", 2, final.extent.2))
  assert(((left_im.min.0 <= left_im.min.0.required) && (((left_im.extent.0.required.s + left_im.min.0.required) + 1) <= (left_im.extent.0 + left_im.min.0))), halide_error_access_out_of_bounds("Input buffer left_im", 0, left_im.min.0.required, (left_im.extent.0.required.s + left_im.min.0.required), left_im.min.0, ((left_im.extent.0 + left_im.min.0) + -1)))
  assert((0 <= left_im.extent.0), halide_error_buffer_extents_negative("Input buffer left_im", 0, left_im.extent.0))
  assert(((left_im.min.1 <= left_im.min.1.required) && ((left_im.extent.1.required + left_im.min.1.required) <= (left_im.extent.1 + left_im.min.1))), halide_error_access_out_of_bounds("Input buffer left_im", 1, left_im.min.1.required, ((left_im.extent.1.required + left_im.min.1.required) + -1), left_im.min.1, ((left_im.extent.1 + left_im.min.1) + -1)))
  assert((0 <= left_im.extent.1), halide_error_buffer_extents_negative("Input buffer left_im", 1, left_im.extent.1))
  assert(((left_im.min.2 <= left_im.min.2.required) && ((left_im.extent.2.required + left_im.min.2.required) <= (left_im.extent.2 + left_im.min.2))), halide_error_access_out_of_bounds("Input buffer left_im", 2, left_im.min.2.required, ((left_im.extent.2.required + left_im.min.2.required) + -1), left_im.min.2, ((left_im.extent.2 + left_im.min.2) + -1)))
  assert((0 <= left_im.extent.2), halide_error_buffer_extents_negative("Input buffer left_im", 2, left_im.extent.2))
  assert(((right_im.min.0 <= right_im.min.0.required) && (((right_im.extent.0.required.s + right_im.min.0.required) + 1) <= (right_im.extent.0 + right_im.min.0))), halide_error_access_out_of_bounds("Input buffer right_im", 0, right_im.min.0.required, (right_im.extent.0.required.s + right_im.min.0.required), right_im.min.0, ((right_im.extent.0 + right_im.min.0) + -1)))
  assert((0 <= right_im.extent.0), halide_error_buffer_extents_negative("Input buffer right_im", 0, right_im.extent.0))
  assert(((right_im.min.1 <= right_im.min.1.required) && ((right_im.extent.1.required + right_im.min.1.required) <= (right_im.extent.1 + right_im.min.1))), halide_error_access_out_of_bounds("Input buffer right_im", 1, right_im.min.1.required, ((right_im.extent.1.required + right_im.min.1.required) + -1), right_im.min.1, ((right_im.extent.1 + right_im.min.1) + -1)))
  assert((0 <= right_im.extent.1), halide_error_buffer_extents_negative("Input buffer right_im", 1, right_im.extent.1))
  assert(((right_im.min.2 <= right_im.min.2.required) && ((right_im.extent.2.required + right_im.min.2.required) <= (right_im.extent.2 + right_im.min.2))), halide_error_access_out_of_bounds("Input buffer right_im", 2, right_im.min.2.required, ((right_im.extent.2.required + right_im.min.2.required) + -1), right_im.min.2, ((right_im.extent.2 + right_im.min.2) + -1)))
  assert((0 <= right_im.extent.2), halide_error_buffer_extents_negative("Input buffer right_im", 2, right_im.extent.2))
  assert((final.stride.0 == 1), halide_error_constraint_violated("final.stride.0", final.stride.0, "1", 1))
  assert((left_im.stride.0 == 1), halide_error_constraint_violated("left_im.stride.0", left_im.stride.0, "1", 1))
  assert((right_im.stride.0 == 1), halide_error_constraint_violated("right_im.stride.0", right_im.stride.0, "1", 1))
  assert((abs(int64(final.extent.0)) <= (uint64)9223372036854775807), halide_error_buffer_allocation_too_large("final", abs(int64(final.extent.0)), (uint64)9223372036854775807))
  assert((abs((int64(final.extent.1)*int64(final.stride.1))) <= (uint64)9223372036854775807), halide_error_buffer_allocation_too_large("final", abs((int64(final.extent.1)*int64(final.stride.1))), (uint64)9223372036854775807))
  assert((abs((int64(final.extent.2)*int64(final.stride.2))) <= (uint64)9223372036854775807), halide_error_buffer_allocation_too_large("final", abs((int64(final.extent.2)*int64(final.stride.2))), (uint64)9223372036854775807))
  assert((abs(int64(left_im.extent.0)) <= (uint64)9223372036854775807), halide_error_buffer_allocation_too_large("left_im", abs(int64(left_im.extent.0)), (uint64)9223372036854775807))
  assert((abs((int64(left_im.extent.1)*int64(left_im.stride.1))) <= (uint64)9223372036854775807), halide_error_buffer_allocation_too_large("left_im", abs((int64(left_im.extent.1)*int64(left_im.stride.1))), (uint64)9223372036854775807))
  assert((abs((int64(left_im.extent.2)*int64(left_im.stride.2))) <= (uint64)9223372036854775807), halide_error_buffer_allocation_too_large("left_im", abs((int64(left_im.extent.2)*int64(left_im.stride.2))), (uint64)9223372036854775807))
  assert((abs(int64(right_im.extent.0)) <= (uint64)9223372036854775807), halide_error_buffer_allocation_too_large("right_im", abs(int64(right_im.extent.0)), (uint64)9223372036854775807))
  assert((abs((int64(right_im.extent.1)*int64(right_im.stride.1))) <= (uint64)9223372036854775807), halide_error_buffer_allocation_too_large("right_im", abs((int64(right_im.extent.1)*int64(right_im.stride.1))), (uint64)9223372036854775807))
  assert((abs((int64(right_im.extent.2)*int64(right_im.stride.2))) <= (uint64)9223372036854775807), halide_error_buffer_allocation_too_large("right_im", abs((int64(right_im.extent.2)*int64(right_im.stride.2))), (uint64)9223372036854775807))
  assert((slices <= 64), halide_error_param_too_large_i64("slices", int64(slices), (int64)64))
  assert((1 <= slices), halide_error_param_too_small_i64("slices", int64(slices), (int64)1))
  assert((focus_depth <= 32), halide_error_param_too_large_i64("focus_depth", int64(focus_depth), (int64)32))
  assert((1 <= focus_depth), halide_error_param_too_small_i64("focus_depth", int64(focus_depth), (int64)1))
  assert((blur_radius_scale <= 1.000000f), halide_error_param_too_large_f64("blur_radius_scale", float64(max(blur_radius_scale, 0.000000f)), 1.000000))
  assert((0.000000f <= blur_radius_scale), halide_error_param_too_small_f64("blur_radius_scale", float64(blur_radius_scale), 0.000000))
  let repeat_edge._1.min_realized = min(min(min(min(min(min((min((final.extent.1 + final.min.1), cost_confidence.s0.y.max.s) + -8), final.min.1), cost_confidence.s0.y.min), ((final.extent.1 + final.min.1) + -8)), (final.min.1 - int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(max((slices - focus_depth), focus_depth)))))), (repeat_edge.s0._1.max.s + -8)), repeat_edge.s0._1.min)
  let repeat_edge._1.extent_realized.s.s = (let t105990 = int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(max((slices - focus_depth), focus_depth)))) in (max(max(min(((((((cost_confidence.s0.y.max.s - cost_confidence.s0.y.min) + -1)/8)*8) + cost_confidence.s0.y.min) + 8), cost_confidence.s0.y.max.s), ((max(max((0 - t105990), t105990), 0) + final.extent.1) + final.min.1)), min(((((((repeat_edge.s0._1.max.s - repeat_edge.s0._1.min) + -1)/8)*8) + repeat_edge.s0._1.min) + 8), repeat_edge.s0._1.max.s)) + -1))
  let repeat_edge._0.min_realized = min(min(min(min(min((cost_confidence.s0.x.max.s + -157), final.min.0), cost_confidence.s0.x.min), (final.min.0 - int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(max((slices - focus_depth), focus_depth)))))), (repeat_edge.s0._0.max.s + -157)), repeat_edge.s0._0.min)
  let repeat_edge._0.extent_realized.s.s = (let t105991 = int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(max((slices - focus_depth), focus_depth)))) in (max(max(min(((((((cost_confidence.s0.x.max.s - cost_confidence.s0.x.min) + -126)/32)*32) + cost_confidence.s0.x.min) + 157), cost_confidence.s0.x.max.s), (((max(max((0 - t105991), t105991), 0) + final.extent.0) + final.min.0) + 125)), min(((((((repeat_edge.s0._0.max.s - repeat_edge.s0._0.min) + -126)/32)*32) + repeat_edge.s0._0.min) + 157), repeat_edge.s0._0.max.s)) + -126))
  let repeat_edge.stride.2 = (((repeat_edge._0.extent_realized.s.s - repeat_edge._0.min_realized) + 1)*((repeat_edge._1.extent_realized.s.s - repeat_edge._1.min_realized) + 1))
  allocate repeat_edge[uint8 * ((repeat_edge._0.extent_realized.s.s - repeat_edge._0.min_realized) + 1) * ((repeat_edge._1.extent_realized.s.s - repeat_edge._1.min_realized) + 1) * 3] if (uint1)0
  let repeat_edge.buffer = _halide_buffer_init(alloca(size_of_halide_buffer_t()), make_struct((halide_dimension_t *), repeat_edge._0.min_realized, ((repeat_edge._0.extent_realized.s.s - repeat_edge._0.min_realized) + 1), 1, 0, repeat_edge._1.min_realized, ((repeat_edge._1.extent_realized.s.s - repeat_edge._1.min_realized) + 1), ((repeat_edge._0.extent_realized.s.s - repeat_edge._0.min_realized) + 1), 0, 0, 3, repeat_edge.stride.2, 0), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 1, 8, 3, make_struct((halide_dimension_t *), repeat_edge._0.min_realized, ((repeat_edge._0.extent_realized.s.s - repeat_edge._0.min_realized) + 1), 1, 0, repeat_edge._1.min_realized, ((repeat_edge._1.extent_realized.s.s - repeat_edge._1.min_realized) + 1), ((repeat_edge._0.extent_realized.s.s - repeat_edge._0.min_realized) + 1), 0, 0, 3, repeat_edge.stride.2, 0), (uint64)0)
  register_destructor("halide_device_free_as_destructor", repeat_edge.buffer)
  produce repeat_edge {
    let halide_device_malloc_result$15 = halide_device_malloc(repeat_edge.buffer, halide_cuda_device_interface())
    assert((halide_device_malloc_result$15 == 0), halide_device_malloc_result$15)
    let halide_copy_to_device_result$1 = halide_copy_to_device(left_im.buffer, halide_cuda_device_interface())
    assert((halide_copy_to_device_result$1 == 0), halide_copy_to_device_result$1)
    let repeat_edge.s0._1._1_o.__block_id_y.prologue = min(max((((left_im.min.1 - repeat_edge.s0._1.min) + 7)/8), 0), (((repeat_edge.s0._1.max.s - repeat_edge.s0._1.min) + 7)/8))
    let repeat_edge.s0._1._1_o.__block_id_y.epilogue = max(min(max((((left_im.min.1 - repeat_edge.s0._1.min) + 7)/8), 0), (((repeat_edge.s0._1.max.s - repeat_edge.s0._1.min) + 7)/8)), (min((min(min(((left_im.extent.1 + left_im.min.1) + 7), repeat_edge.s0._1.max.s), (left_im.extent.1 + left_im.min.1)) - repeat_edge.s0._1.min), ((repeat_edge.s0._1.max.s - repeat_edge.s0._1.min) + 7))/8))
    let t104172 = min(max((((left_im.min.0 - repeat_edge.s0._0.min) + 31)/32), 0), (((repeat_edge.s0._0.max.s - repeat_edge.s0._0.min) + -94)/32))
    let t104173 = max(min(max((((left_im.min.0 - repeat_edge.s0._0.min) + 31)/32), 0), (((repeat_edge.s0._0.max.s - repeat_edge.s0._0.min) + -94)/32)), ((min(min((min(((left_im.extent.0 + left_im.min.0) + 156), repeat_edge.s0._0.max.s) - repeat_edge.s0._0.min), (((left_im.extent.0 + left_im.min.0) - repeat_edge.s0._0.min) + 125)), ((repeat_edge.s0._0.max.s - repeat_edge.s0._0.min) + 31)) + -125)/32))
    let t104960 = (((int64(left_im.min.2)*int64(left_im.stride.2)) + (int64(left_im.min.1)*int64(left_im.stride.1))) + int64(left_im.min.0))
    let t106295 = (left_im.extent.2 + left_im.min.2)
    let t106296 = max(min(t106295, 3), 0)
    let t106297 = max(min(left_im.min.2, 3), 0)
    let t106283 = (((repeat_edge.s0._1.max.s - repeat_edge.s0._1.min) + 7)/8)
    let t106284 = (((repeat_edge.s0._0.max.s - repeat_edge.s0._0.min) + -94)/32)
    let t106287 = ((repeat_edge._0.extent_realized.s.s - repeat_edge._0.min_realized) + 1)
    let t106289 = (t106295 + -1)
    let t106294 = ((left_im.extent.1 + left_im.min.1) + -1)
    let t106293 = ((left_im.extent.0 + left_im.min.0) + -1)
    let t106285 = (repeat_edge.s0._1.max.s + -8)
    let t106286 = (repeat_edge.s0._0.max.s + -157)
    gpu_block<CUDA> (repeat_edge.s0._1._1_o.__block_id_y, 0, t106283) {
      gpu_block<CUDA> (repeat_edge.s0._0._0_o.__block_id_x, 0, t106284) {
        gpu_thread<CUDA> (.__thread_id_y, 0, 8) {
          gpu_thread<CUDA> (.__thread_id_x, 0, 32) {
            if (((repeat_edge.s0._1._1_o.__block_id_y.prologue <= repeat_edge.s0._1._1_o.__block_id_y) && (repeat_edge.s0._1._1_o.__block_id_y < repeat_edge.s0._1._1_o.__block_id_y.epilogue))) {
              let repeat_edge.s0._1._1_i.base = min(((repeat_edge.s0._1._1_o.__block_id_y*8) + repeat_edge.s0._1.min), t106285)
              if (((t104172 <= repeat_edge.s0._0._0_o.__block_id_x) && (repeat_edge.s0._0._0_o.__block_id_x < t104173))) {
                let repeat_edge.s0._0._0_i.base = min(((repeat_edge.s0._0._0_o.__block_id_x*32) + repeat_edge.s0._0.min), t106286)
                let t104972 = ((int64(((repeat_edge.s0._1._1_i.base - repeat_edge._1.min_realized) + .__thread_id_y))*int64(t106287)) + int64(((repeat_edge.s0._0._0_i.base - repeat_edge._0.min_realized) + .__thread_id_x)))
                let t104971 = (((int64((.__thread_id_y + repeat_edge.s0._1._1_i.base))*int64(left_im.stride.1)) - t104960) + int64((.__thread_id_x + repeat_edge.s0._0._0_i.base)))
                for (repeat_edge.s0._2, 0, t106297) {
                  repeat_edge[((int64(repeat_edge.s0._2)*int64(repeat_edge.stride.2)) + t104972)] = left_im[((int64(max(min(repeat_edge.s0._2, t106289), left_im.min.2))*int64(left_im.stride.2)) + t104971)]
                }
                let t104975 = ((int64(((repeat_edge.s0._1._1_i.base - repeat_edge._1.min_realized) + .__thread_id_y))*int64(t106287)) + int64(((repeat_edge.s0._0._0_i.base - repeat_edge._0.min_realized) + .__thread_id_x)))
                let t104974 = (((int64((.__thread_id_y + repeat_edge.s0._1._1_i.base))*int64(left_im.stride.1)) - t104960) + int64((.__thread_id_x + repeat_edge.s0._0._0_i.base)))
                let t106298 = (t106296 - t106297)
                for (repeat_edge.s0._2, t106297, t106298) {
                  repeat_edge[((int64(repeat_edge.s0._2)*int64(repeat_edge.stride.2)) + t104975)] = left_im[((int64(repeat_edge.s0._2)*int64(left_im.stride.2)) + t104974)]
                }
                let t104978 = ((int64(((repeat_edge.s0._1._1_i.base - repeat_edge._1.min_realized) + .__thread_id_y))*int64(t106287)) + int64(((repeat_edge.s0._0._0_i.base - repeat_edge._0.min_realized) + .__thread_id_x)))
                let t104977 = (((int64((.__thread_id_y + repeat_edge.s0._1._1_i.base))*int64(left_im.stride.1)) - t104960) + int64((.__thread_id_x + repeat_edge.s0._0._0_i.base)))
                for (repeat_edge.s0._2, t106296, (3 - t106296)) {
                  repeat_edge[((int64(repeat_edge.s0._2)*int64(repeat_edge.stride.2)) + t104978)] = left_im[((int64(max(min(repeat_edge.s0._2, t106289), left_im.min.2))*int64(left_im.stride.2)) + t104977)]
                }
              } else {
                let repeat_edge.s0._0._0_i.base = min(((repeat_edge.s0._0._0_o.__block_id_x*32) + repeat_edge.s0._0.min), t106286)
                let t104980 = ((int64(((repeat_edge.s0._1._1_i.base - repeat_edge._1.min_realized) + .__thread_id_y))*int64(t106287)) + int64(((repeat_edge.s0._0._0_i.base - repeat_edge._0.min_realized) + .__thread_id_x)))
                let t104979 = (((int64((.__thread_id_y + repeat_edge.s0._1._1_i.base))*int64(left_im.stride.1)) - t104960) + int64(max(min((.__thread_id_x + repeat_edge.s0._0._0_i.base), t106293), left_im.min.0)))
                for (repeat_edge.s0._2, 0, 3) {
                  repeat_edge[((int64(repeat_edge.s0._2)*int64(repeat_edge.stride.2)) + t104980)] = left_im[((int64(max(min(repeat_edge.s0._2, t106289), left_im.min.2))*int64(left_im.stride.2)) + t104979)]
                }
              }
            } else {
              let repeat_edge.s0._1._1_i.base = min(((repeat_edge.s0._1._1_o.__block_id_y*8) + repeat_edge.s0._1.min), t106285)
              let repeat_edge.s0._0._0_i.base = min(((repeat_edge.s0._0._0_o.__block_id_x*32) + repeat_edge.s0._0.min), t106286)
              let t104982 = ((int64(((repeat_edge.s0._1._1_i.base - repeat_edge._1.min_realized) + .__thread_id_y))*int64(t106287)) + int64(((repeat_edge.s0._0._0_i.base - repeat_edge._0.min_realized) + .__thread_id_x)))
              let t104981 = (((int64(max(min((.__thread_id_y + repeat_edge.s0._1._1_i.base), t106294), left_im.min.1))*int64(left_im.stride.1)) - t104960) + int64(max(min((.__thread_id_x + repeat_edge.s0._0._0_i.base), t106293), left_im.min.0)))
              for (repeat_edge.s0._2, 0, 3) {
                repeat_edge[((int64(repeat_edge.s0._2)*int64(repeat_edge.stride.2)) + t104982)] = left_im[((int64(max(min(repeat_edge.s0._2, t106289), left_im.min.2))*int64(left_im.stride.2)) + t104981)]
              }
            }
          }
        }
      }
    }
    _halide_buffer_set_device_dirty(repeat_edge.buffer, (uint1)1)
  }
  let repeat_edge$1._1.min_realized = min((cost_confidence.s0.y.max.s + -8), cost_confidence.s0.y.min)
  let repeat_edge$1._1.extent_realized.s = min(((((((cost_confidence.s0.y.max.s - cost_confidence.s0.y.min) + -1)/8)*8) + cost_confidence.s0.y.min) + 8), cost_confidence.s0.y.max.s)
  let repeat_edge$1._0.min_realized = min(min((((slices*2) + cost_confidence.s0.x.max.s) + -158), cost_confidence.s0.x.min), ((min((cost_confidence.s0.x.max.s + -157), cost_confidence.s0.x.min) + (min(slices, 4)*2)) + -8))
  let repeat_edge$1._0.extent_realized.s.s = max(min(((((((((slices*2) + cost_confidence.s0.x.max.s) - cost_confidence.s0.x.min) + -127)/32)*32) + cost_confidence.s0.x.min) + 158), ((slices*2) + cost_confidence.s0.x.max.s)), (min(((((((cost_confidence.s0.x.max.s - cost_confidence.s0.x.min) + -126)/32)*32) + cost_confidence.s0.x.min) + 157), cost_confidence.s0.x.max.s) + (slices*2)))
  allocate repeat_edge$1[uint8 * ((repeat_edge$1._0.extent_realized.s.s - repeat_edge$1._0.min_realized) + -126) * (repeat_edge$1._1.extent_realized.s - repeat_edge$1._1.min_realized) * 3] if (uint1)0
  let repeat_edge$1.buffer = (let t106001 = ((repeat_edge$1._1.extent_realized.s - repeat_edge$1._1.min_realized)*((repeat_edge$1._0.extent_realized.s.s - repeat_edge$1._0.min_realized) + -126)) in _halide_buffer_init(alloca(size_of_halide_buffer_t()), make_struct((halide_dimension_t *), repeat_edge$1._0.min_realized, ((repeat_edge$1._0.extent_realized.s.s - repeat_edge$1._0.min_realized) + -126), 1, 0, repeat_edge$1._1.min_realized, (repeat_edge$1._1.extent_realized.s - repeat_edge$1._1.min_realized), ((repeat_edge$1._0.extent_realized.s.s - repeat_edge$1._0.min_realized) + -126), 0, 0, 3, t106001, 0), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 1, 8, 3, make_struct((halide_dimension_t *), repeat_edge$1._0.min_realized, ((repeat_edge$1._0.extent_realized.s.s - repeat_edge$1._0.min_realized) + -126), 1, 0, repeat_edge$1._1.min_realized, (repeat_edge$1._1.extent_realized.s - repeat_edge$1._1.min_realized), ((repeat_edge$1._0.extent_realized.s.s - repeat_edge$1._0.min_realized) + -126), 0, 0, 3, t106001, 0), (uint64)0))
  register_destructor("halide_device_free_as_destructor", repeat_edge$1.buffer)
  produce repeat_edge$1 {
    let halide_device_malloc_result$14 = halide_device_malloc(repeat_edge$1.buffer, halide_cuda_device_interface())
    assert((halide_device_malloc_result$14 == 0), halide_device_malloc_result$14)
    let halide_copy_to_device_result$2 = halide_copy_to_device(right_im.buffer, halide_cuda_device_interface())
    assert((halide_copy_to_device_result$2 == 0), halide_copy_to_device_result$2)
    let repeat_edge$1.s0._1._1_o.__block_id_y.prologue = min(max((((right_im.min.1 - cost_confidence.s0.y.min) + 7)/8), 0), (((cost_confidence.s0.y.max.s - cost_confidence.s0.y.min) + 7)/8))
    let repeat_edge$1.s0._1._1_o.__block_id_y.epilogue = max(min(max((((right_im.min.1 - cost_confidence.s0.y.min) + 7)/8), 0), (((cost_confidence.s0.y.max.s - cost_confidence.s0.y.min) + 7)/8)), (min((min(min(((right_im.extent.1 + right_im.min.1) + 7), cost_confidence.s0.y.max.s), (right_im.extent.1 + right_im.min.1)) - cost_confidence.s0.y.min), ((cost_confidence.s0.y.max.s - cost_confidence.s0.y.min) + 7))/8))
    let t104184 = min(max((((right_im.min.0 - cost_confidence.s0.x.min) + 31)/32), 0), (((((slices*2) + cost_confidence.s0.x.max.s) - cost_confidence.s0.x.min) + -95)/32))
    let t104185 = max(min(max((((right_im.min.0 - cost_confidence.s0.x.min) + 31)/32), 0), (((((slices*2) + cost_confidence.s0.x.max.s) - cost_confidence.s0.x.min) + -95)/32)), ((min(min((min(((slices*2) + cost_confidence.s0.x.max.s), ((right_im.extent.0 + right_im.min.0) + 157)) - cost_confidence.s0.x.min), (((right_im.extent.0 + right_im.min.0) - cost_confidence.s0.x.min) + 126)), ((((slices*2) + cost_confidence.s0.x.max.s) - cost_confidence.s0.x.min) + 31)) + -126)/32))
    let t104988 = (((int64(right_im.min.2)*int64(right_im.stride.2)) + (int64(right_im.min.1)*int64(right_im.stride.1))) + int64(right_im.min.0))
    let t106313 = (right_im.extent.2 + right_im.min.2)
    let t106314 = ((slices*2) + cost_confidence.s0.x.max.s)
    let t106315 = ((repeat_edge$1._0.extent_realized.s.s - repeat_edge$1._0.min_realized) + -126)
    let t106316 = max(min(t106313, 3), 0)
    let t106317 = max(min(right_im.min.2, 3), 0)
    let t106301 = (((t106314 - cost_confidence.s0.x.min) + -95)/32)
    let t106300 = (((cost_confidence.s0.y.max.s - cost_confidence.s0.y.min) + 7)/8)
    let t106304 = ((repeat_edge$1._1.extent_realized.s - repeat_edge$1._1.min_realized)*t106315)
    let t106303 = (t106314 + -158)
    let t106307 = (t106313 + -1)
    let t106312 = ((right_im.extent.1 + right_im.min.1) + -1)
    let t106311 = ((right_im.extent.0 + right_im.min.0) + -1)
    let t106302 = (cost_confidence.s0.y.max.s + -8)
    gpu_block<CUDA> (repeat_edge$1.s0._1._1_o.__block_id_y, 0, t106300) {
      gpu_block<CUDA> (repeat_edge$1.s0._0._0_o.__block_id_x, 0, t106301) {
        gpu_thread<CUDA> (.__thread_id_y, 0, 8) {
          gpu_thread<CUDA> (.__thread_id_x, 0, 32) {
            if (((repeat_edge$1.s0._1._1_o.__block_id_y.prologue <= repeat_edge$1.s0._1._1_o.__block_id_y) && (repeat_edge$1.s0._1._1_o.__block_id_y < repeat_edge$1.s0._1._1_o.__block_id_y.epilogue))) {
              let repeat_edge$1.s0._1._1_i.base = min(((repeat_edge$1.s0._1._1_o.__block_id_y*8) + cost_confidence.s0.y.min), t106302)
              if (((t104184 <= repeat_edge$1.s0._0._0_o.__block_id_x) && (repeat_edge$1.s0._0._0_o.__block_id_x < t104185))) {
                let repeat_edge$1.s0._0._0_i.base = min(((repeat_edge$1.s0._0._0_o.__block_id_x*32) + cost_confidence.s0.x.min), t106303)
                let t105002 = ((int64(((repeat_edge$1.s0._1._1_i.base - repeat_edge$1._1.min_realized) + .__thread_id_y))*int64(t106315)) + int64(((repeat_edge$1.s0._0._0_i.base - repeat_edge$1._0.min_realized) + .__thread_id_x)))
                let t105001 = (((int64((.__thread_id_y + repeat_edge$1.s0._1._1_i.base))*int64(right_im.stride.1)) - t104988) + int64((.__thread_id_x + repeat_edge$1.s0._0._0_i.base)))
                for (repeat_edge$1.s0._2, 0, t106317) {
                  repeat_edge$1[((int64(repeat_edge$1.s0._2)*int64(t106304)) + t105002)] = right_im[((int64(max(min(repeat_edge$1.s0._2, t106307), right_im.min.2))*int64(right_im.stride.2)) + t105001)]
                }
                let t105007 = ((int64(((repeat_edge$1.s0._1._1_i.base - repeat_edge$1._1.min_realized) + .__thread_id_y))*int64(t106315)) + int64(((repeat_edge$1.s0._0._0_i.base - repeat_edge$1._0.min_realized) + .__thread_id_x)))
                let t105006 = (((int64((.__thread_id_y + repeat_edge$1.s0._1._1_i.base))*int64(right_im.stride.1)) - t104988) + int64((.__thread_id_x + repeat_edge$1.s0._0._0_i.base)))
                let t106318 = (t106316 - t106317)
                for (repeat_edge$1.s0._2, t106317, t106318) {
                  repeat_edge$1[((int64(repeat_edge$1.s0._2)*int64(t106304)) + t105007)] = right_im[((int64(repeat_edge$1.s0._2)*int64(right_im.stride.2)) + t105006)]
                }
                let t105012 = ((int64(((repeat_edge$1.s0._1._1_i.base - repeat_edge$1._1.min_realized) + .__thread_id_y))*int64(t106315)) + int64(((repeat_edge$1.s0._0._0_i.base - repeat_edge$1._0.min_realized) + .__thread_id_x)))
                let t105011 = (((int64((.__thread_id_y + repeat_edge$1.s0._1._1_i.base))*int64(right_im.stride.1)) - t104988) + int64((.__thread_id_x + repeat_edge$1.s0._0._0_i.base)))
                for (repeat_edge$1.s0._2, t106316, (3 - t106316)) {
                  repeat_edge$1[((int64(repeat_edge$1.s0._2)*int64(t106304)) + t105012)] = right_im[((int64(max(min(repeat_edge$1.s0._2, t106307), right_im.min.2))*int64(right_im.stride.2)) + t105011)]
                }
              } else {
                let repeat_edge$1.s0._0._0_i.base = min(((repeat_edge$1.s0._0._0_o.__block_id_x*32) + cost_confidence.s0.x.min), t106303)
                let t105016 = ((int64(((repeat_edge$1.s0._1._1_i.base - repeat_edge$1._1.min_realized) + .__thread_id_y))*int64(t106315)) + int64(((repeat_edge$1.s0._0._0_i.base - repeat_edge$1._0.min_realized) + .__thread_id_x)))
                let t105015 = (((int64((.__thread_id_y + repeat_edge$1.s0._1._1_i.base))*int64(right_im.stride.1)) - t104988) + int64(max(min((.__thread_id_x + repeat_edge$1.s0._0._0_i.base), t106311), right_im.min.0)))
                for (repeat_edge$1.s0._2, 0, 3) {
                  repeat_edge$1[((int64(repeat_edge$1.s0._2)*int64(t106304)) + t105016)] = right_im[((int64(max(min(repeat_edge$1.s0._2, t106307), right_im.min.2))*int64(right_im.stride.2)) + t105015)]
                }
              }
            } else {
              let repeat_edge$1.s0._1._1_i.base = min(((repeat_edge$1.s0._1._1_o.__block_id_y*8) + cost_confidence.s0.y.min), t106302)
              let repeat_edge$1.s0._0._0_i.base = min(((repeat_edge$1.s0._0._0_o.__block_id_x*32) + cost_confidence.s0.x.min), t106303)
              let t105020 = ((int64(((repeat_edge$1.s0._1._1_i.base - repeat_edge$1._1.min_realized) + .__thread_id_y))*int64(t106315)) + int64(((repeat_edge$1.s0._0._0_i.base - repeat_edge$1._0.min_realized) + .__thread_id_x)))
              let t105019 = (((int64(max(min((.__thread_id_y + repeat_edge$1.s0._1._1_i.base), t106312), right_im.min.1))*int64(right_im.stride.1)) - t104988) + int64(max(min((.__thread_id_x + repeat_edge$1.s0._0._0_i.base), t106311), right_im.min.0)))
              for (repeat_edge$1.s0._2, 0, 3) {
                repeat_edge$1[((int64(repeat_edge$1.s0._2)*int64(t106304)) + t105020)] = right_im[((int64(max(min(repeat_edge$1.s0._2, t106307), right_im.min.2))*int64(right_im.stride.2)) + t105019)]
              }
            }
          }
        }
      }
    }
    _halide_buffer_set_device_dirty(repeat_edge$1.buffer, (uint1)1)
  }
  let diff.z.min_realized.s = min((min(slices, 2) + 2), slices)
  let diff.y.min_realized = min(min(min(min((cost_confidence.s0.y.max.s + -8), cost_confidence.s0.y.min), ((min(max(downy.s0.y.max.s, 0), (max(downy.s0.y.min.s, 1) + 12))*2) + -27)), (((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + -16)), argmin.s1.y.min)
  let diff.y.extent_realized.s = max(max(min(((((((cost_confidence.s0.y.max.s - cost_confidence.s0.y.min) + -1)/8)*8) + cost_confidence.s0.y.min) + 8), cost_confidence.s0.y.max.s), ((min(max(downy.s0.y.max.s, 0), ((max(downy.s0.y.min.s, 1) + ((((max(downy.s0.y.max.s, 0) - max(downy.s0.y.min.s, 1)) + 1)/14)*14)) + 12))*2) + 3)), min(((((((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) - argmin.s1.y.min) + -1)/16)*16) + argmin.s1.y.min) + 16), ((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1)))
  let diff.x.min_realized = (let t106010 = min((downy.s0.x.max.s + -79), downy.s0.x.min) in min(min(min(min(min(min(min(min((cost_confidence.s0.x.max.s + -157), cost_confidence.s0.x.min), ((t106010*2) + -1)), (t106010*2)), ((t106010*2) + 1)), (((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + -16)), argmin.s1.x.min), (cost_confidence.s0.x.max.s + -157)), cost_confidence.s0.x.min))
  let diff.x.extent_realized.s.s = (let t106011 = min((((((downy.s0.x.max.s - downy.s0.x.min)/16)*16) + downy.s0.x.min) + 15), downy.s0.x.max.s) in (let t106012 = min(((((((cost_confidence.s0.x.max.s - cost_confidence.s0.x.min) + -126)/32)*32) + cost_confidence.s0.x.min) + 157), cost_confidence.s0.x.max.s) in max(max(max((t106011*2), (max((t106011*2), t106012) + 3)), (min(((((((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) - argmin.s1.x.min) + -1)/16)*16) + argmin.s1.x.min) + 16), ((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0)) + 128)), (t106012 + 3))))
  let diff.stride.3 = (max(slices, 4)*((diff.y.extent_realized.s - diff.y.min_realized)*((diff.x.extent_realized.s.s - diff.x.min_realized) + -128)))
  allocate diff[uint8 * ((diff.x.extent_realized.s.s - diff.x.min_realized) + -128) * (diff.y.extent_realized.s - diff.y.min_realized) * max(slices, 4) * 3] if (uint1)0
  let diff.buffer = (let t106016 = ((diff.y.extent_realized.s - diff.y.min_realized)*((diff.x.extent_realized.s.s - diff.x.min_realized) + -128)) in _halide_buffer_init(alloca(size_of_halide_buffer_t()), make_struct((halide_dimension_t *), diff.x.min_realized, ((diff.x.extent_realized.s.s - diff.x.min_realized) + -128), 1, 0, diff.y.min_realized, (diff.y.extent_realized.s - diff.y.min_realized), ((diff.x.extent_realized.s.s - diff.x.min_realized) + -128), 0, (diff.z.min_realized.s + -4), max(slices, 4), t106016, 0, 0, 3, diff.stride.3, 0), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 1, 8, 4, make_struct((halide_dimension_t *), diff.x.min_realized, ((diff.x.extent_realized.s.s - diff.x.min_realized) + -128), 1, 0, diff.y.min_realized, (diff.y.extent_realized.s - diff.y.min_realized), ((diff.x.extent_realized.s.s - diff.x.min_realized) + -128), 0, (diff.z.min_realized.s + -4), max(slices, 4), t106016, 0, 0, 3, diff.stride.3, 0), (uint64)0))
  register_destructor("halide_device_free_as_destructor", diff.buffer)
  produce diff {
    consume repeat_edge$1 {
      consume repeat_edge {
        let halide_device_malloc_result$13 = halide_device_malloc(diff.buffer, halide_cuda_device_interface())
        assert((halide_device_malloc_result$13 == 0), halide_device_malloc_result$13)
        let t106332 = ((repeat_edge$1._0.extent_realized.s.s - repeat_edge$1._0.min_realized) + -126)
        let t106321 = (((cost_confidence.s0.y.max.s - cost_confidence.s0.y.min) + 7)/8)
        let t106322 = (((cost_confidence.s0.x.max.s - cost_confidence.s0.x.min) + -94)/32)
        let t106320 = ((slices + 3)/4)
        let t106327 = ((repeat_edge$1._1.extent_realized.s - repeat_edge$1._1.min_realized)*t106332)
        let t106331 = (diff.y.extent_realized.s - diff.y.min_realized)
        let t106329 = (diff.x.extent_realized.s.s - diff.x.min_realized)
        let t106330 = (4 - diff.z.min_realized.s)
        let t106328 = ((repeat_edge._0.extent_realized.s.s - repeat_edge._0.min_realized) + 1)
        let t106323 = (slices + -4)
        let t106324 = (cost_confidence.s0.y.max.s + -8)
        let t106325 = (cost_confidence.s0.x.max.s + -157)
        gpu_block<CUDA> (diff.s0.z.z_o.__block_id_z, 0, t106320) {
          gpu_block<CUDA> (diff.s0.y.y_o.__block_id_y, 0, t106321) {
            gpu_block<CUDA> (diff.s0.x.x_o.__block_id_x, 0, t106322) {
              gpu_thread<CUDA> (.__thread_id_z, 0, 4) {
                gpu_thread<CUDA> (.__thread_id_y, 0, 8) {
                  gpu_thread<CUDA> (.__thread_id_x, 0, 32) {
                    let diff.s0.z.z_i.base = min((diff.s0.z.z_o.__block_id_z*4), t106323)
                    let diff.s0.y.y_i.base = min(((diff.s0.y.y_o.__block_id_y*8) + cost_confidence.s0.y.min), t106324)
                    let diff.s0.x.x_i.base = min(((diff.s0.x.x_o.__block_id_x*32) + cost_confidence.s0.x.min), t106325)
                    let t105036 = (int64(((diff.s0.y.y_i.base - repeat_edge$1._1.min_realized) + .__thread_id_y))*int64(t106332))
                    let t105035 = ((int64(((diff.s0.y.y_i.base - repeat_edge._1.min_realized) + .__thread_id_y))*int64(t106328)) + int64(((diff.s0.x.x_i.base - repeat_edge._0.min_realized) + .__thread_id_x)))
                    let t105039 = (((int64(((diff.s0.z.z_i.base + t106330) + .__thread_id_z))*int64(((t106329 + -128)*t106331))) + (int64(((diff.s0.y.y_i.base - diff.y.min_realized) + .__thread_id_y))*int64((t106329 + -128)))) + int64(((diff.s0.x.x_i.base - diff.x.min_realized) + .__thread_id_x)))
                    let t106333 = (t105036 + int64(((((.__thread_id_z + diff.s0.z.z_i.base)*2) + (diff.s0.x.x_i.base - repeat_edge$1._0.min_realized)) + .__thread_id_x)))
                    for (diff.s0.c, 0, 3) {
                      diff[((int64(diff.s0.c)*int64(diff.stride.3)) + t105039)] = (let t106019 = repeat_edge[((int64(diff.s0.c)*int64(repeat_edge.stride.2)) + t105035)] in (let t106020.s = (int64(diff.s0.c)*int64(t106327)) in min(absd(t106019, repeat_edge$1[(t106020.s + t106333)]), absd(t106019, repeat_edge$1[((t106020.s + t106333) + (int64)1)]))))
                    }
                  }
                }
              }
            }
          }
        }
        let halide_device_free_result$14 = halide_device_free(repeat_edge$1.buffer)
        assert((halide_device_free_result$14 == 0), halide_device_free_result$14)
        free repeat_edge$1
        _halide_buffer_set_device_dirty(diff.buffer, (uint1)1)
      }
    }
  }
  let cost_confidence.y.min_realized = min(min(min(min((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + -16), argmin.s1.y.min), ((min(max(downy.s0.y.max.s, 0), (max(downy.s0.y.min.s, 1) + 12))*2) + -27)), (cost_confidence.s0.y.max.s + -8)), cost_confidence.s0.y.min)
  let cost_confidence.y.extent_realized.s = max(max(min(((((((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) - argmin.s1.y.min) + -1)/16)*16) + argmin.s1.y.min) + 16), ((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1)), ((min(max(downy.s0.y.max.s, 0), ((max(downy.s0.y.min.s, 1) + ((((max(downy.s0.y.max.s, 0) - max(downy.s0.y.min.s, 1)) + 1)/14)*14)) + 12))*2) + 3)), min(((((((cost_confidence.s0.y.max.s - cost_confidence.s0.y.min) + -1)/8)*8) + cost_confidence.s0.y.min) + 8), cost_confidence.s0.y.max.s))
  let cost_confidence.x.min_realized = min(min(min(min((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + -16), argmin.s1.x.min), ((min((downy.s0.x.max.s + -79), downy.s0.x.min)*2) + -1)), (cost_confidence.s0.x.max.s + -157)), cost_confidence.s0.x.min)
  let cost_confidence.x.extent_realized.s.s = max(max((min((((((downy.s0.x.max.s - downy.s0.x.min)/16)*16) + downy.s0.x.min) + 15), downy.s0.x.max.s)*2), (min(((((((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) - argmin.s1.x.min) + -1)/16)*16) + argmin.s1.x.min) + 16), ((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0)) + 125)), min(((((((cost_confidence.s0.x.max.s - cost_confidence.s0.x.min) + -126)/32)*32) + cost_confidence.s0.x.min) + 157), cost_confidence.s0.x.max.s))
  allocate cost_confidence[float32 * ((cost_confidence.x.extent_realized.s.s - cost_confidence.x.min_realized) + -125) * (cost_confidence.y.extent_realized.s - cost_confidence.y.min_realized)] if (uint1)0
  let cost_confidence.buffer = _halide_buffer_init(alloca(size_of_halide_buffer_t()), make_struct((halide_dimension_t *), cost_confidence.x.min_realized, ((cost_confidence.x.extent_realized.s.s - cost_confidence.x.min_realized) + -125), 1, 0, cost_confidence.y.min_realized, (cost_confidence.y.extent_realized.s - cost_confidence.y.min_realized), ((cost_confidence.x.extent_realized.s.s - cost_confidence.x.min_realized) + -125), 0), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 2, make_struct((halide_dimension_t *), cost_confidence.x.min_realized, ((cost_confidence.x.extent_realized.s.s - cost_confidence.x.min_realized) + -125), 1, 0, cost_confidence.y.min_realized, (cost_confidence.y.extent_realized.s - cost_confidence.y.min_realized), ((cost_confidence.x.extent_realized.s.s - cost_confidence.x.min_realized) + -125), 0), (uint64)0)
  register_destructor("halide_device_free_as_destructor", cost_confidence.buffer)
  produce cost_confidence {
    consume diff {
      let halide_device_malloc_result$12 = halide_device_malloc(cost_confidence.buffer, halide_cuda_device_interface())
      assert((halide_device_malloc_result$12 == 0), halide_device_malloc_result$12)
      let t105050 = float32(slices)
      let t106343 = ((diff.x.extent_realized.s.s - diff.x.min_realized) + -128)
      let t106334 = (((cost_confidence.s0.y.max.s - cost_confidence.s0.y.min) + 7)/8)
      let t106335 = (((cost_confidence.s0.x.max.s - cost_confidence.s0.x.min) + -94)/32)
      let t106341 = (int64(diff.stride.3)*(int64)2)
      let t106339 = ((diff.y.extent_realized.s - diff.y.min_realized)*t106343)
      let t106340 = (4 - diff.z.min_realized.s)
      let t106342 = ((cost_confidence.x.extent_realized.s.s - cost_confidence.x.min_realized) + -125)
      let t106336 = (cost_confidence.s0.y.max.s + -8)
      let t106337 = (cost_confidence.s0.x.max.s + -157)
      gpu_block<CUDA> (cost_confidence.s0.y.y_o.__block_id_y, 0, t106334) {
        gpu_block<CUDA> (cost_confidence.s0.x.x_o.__block_id_x, 0, t106335) {
          allocate __shared[uint8 * 2048] in GPUShared
          gpu_thread<CUDA> (.__thread_id_y, 0, 8) {
            gpu_thread<CUDA> (.__thread_id_x, 0, 32) {
              let cost_confidence.s0.y.y_i.base = min(((cost_confidence.s0.y.y_o.__block_id_y*8) + cost_confidence.s0.y.min), t106336)
              let cost_confidence.s0.x.x_i.base = min(((cost_confidence.s0.x.x_o.__block_id_x*32) + cost_confidence.s0.x.min), t106337)
              produce sum {
                __shared[((int64(.__thread_id_y)*(int64)32) + int64(.__thread_id_x))] = 0.000000f
                gpu_thread_barrier()
                let t105052 = (int64(((cost_confidence.s0.y.y_i.base - diff.y.min_realized) + .__thread_id_y))*int64(t106343))
                let t105055 = ((int64(.__thread_id_y)*(int64)32) + int64(.__thread_id_x))
                let t106345 = (t105052 + t106341)
                let t106346 = (t105052 + int64(diff.stride.3))
                let t106344 = ((cost_confidence.s0.x.x_i.base - diff.x.min_realized) + .__thread_id_x)
                for (sum.s1.r$x, 0, slices) {
                  __shared[t105055] = (let t106027 = (int64((sum.s1.r$x + t106340))*int64(t106339)) in (let t106029.s = diff[((t106345 + int64(t106344)) + t106027)] in (let t106030.s = diff[((t105052 + int64(t106344)) + t106027)] in (let t106031.s = diff[((t106346 + int64(t106344)) + t106027)] in (let t106032 = ((float32(t106029.s)*float32(t106029.s)) + ((float32(t106030.s)*float32(t106030.s)) + (float32(t106031.s)*float32(t106031.s)))) in (__shared[t105055] + (t106032*t106032)))))))
                }
              }
              gpu_thread_barrier()
              produce sum$1 {
                __shared[(((int64(.__thread_id_y)*(int64)32) + int64(.__thread_id_x)) + (int64)256)] = 0.000000f
                gpu_thread_barrier()
                let t105057 = (int64(((cost_confidence.s0.y.y_i.base - diff.y.min_realized) + .__thread_id_y))*int64(t106343))
                let t105060.s = ((int64(.__thread_id_y)*(int64)32) + int64(.__thread_id_x))
                let t106350 = (t105060.s + (int64)256)
                let t106348 = (t105057 + t106341)
                let t106349 = (t105057 + int64(diff.stride.3))
                let t106347 = ((cost_confidence.s0.x.x_i.base - diff.x.min_realized) + .__thread_id_x)
                for (sum$1.s1.r$x, 0, slices) {
                  __shared[t106350] = (let t106033 = (int64((sum$1.s1.r$x + t106340))*int64(t106339)) in (let t106035.s = diff[((t106348 + int64(t106347)) + t106033)] in (let t106036.s = diff[((t105057 + int64(t106347)) + t106033)] in (let t106037.s = diff[((t106349 + int64(t106347)) + t106033)] in (__shared[t106350] + (((float32(t106035.s)*float32(t106035.s)) + ((float32(t106036.s)*float32(t106036.s)) + (float32(t106037.s)*float32(t106037.s))))/t105050))))))
                }
              }
              gpu_thread_barrier()
              consume sum$1 {
                consume sum {
                  cost_confidence[((int64(((cost_confidence.s0.y.y_i.base - cost_confidence.y.min_realized) + .__thread_id_y))*int64(t106342)) + int64(((cost_confidence.s0.x.x_i.base - cost_confidence.x.min_realized) + .__thread_id_x)))] = (let t106038 = ((int64(.__thread_id_y)*(int64)32) + int64(.__thread_id_x)) in (let t106039 = __shared[(t106038 + (int64)256)] in ((__shared[t106038]/t105050) - (t106039*t106039))))
                }
              }
            }
          }
          free __shared
        }
      }
      _halide_buffer_set_device_dirty(cost_confidence.buffer, (uint1)1)
    }
  }
  let downy.y.min_realized.s = min(max(downy.s0.y.max.s, 0), (max(min(min(min((left_im.extent.1/2), (min(max(downy$1.s0.y.min.s, 0), (max(downy$1.s0.y.max.s, 0) + -13))*2)), (min(min((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + -16), argmin.s1.y.min), left_im.extent.1)/2)), downy.s0.y.min.s), 1) + 12))
  let downy.y.extent_realized.s.s = max(min(max(downy.s0.y.max.s, 0), ((max(downy.s0.y.min.s, 1) + ((((max(downy.s0.y.max.s, 0) - max(downy.s0.y.min.s, 1)) + 1)/14)*14)) + 12)), (max(max(min((left_im.extent.1/2), ((min(max(downy$1.s0.y.max.s, 0), ((max(downy$1.s0.y.min.s, 0) + (((max(downy$1.s0.y.max.s, 0) - max(downy$1.s0.y.min.s, 0))/14)*14)) + 13))*2) + 3)), (min((min(((((((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) - argmin.s1.y.min) + -1)/16)*16) + argmin.s1.y.min) + 16), ((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1)) + 3), left_im.extent.1)/2)), 1) + -1))
  let downy.x.min_realized = (let t106045 = min((downy$1.s0.x.max.s + -39), downy$1.s0.x.min) in min(min(min(max(min((t106045*2), ((left_im.extent.0/2) + -1)), 0), (max(min(min((left_im.extent.0/2), (t106045*2)), (min(min((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + -16), argmin.s1.x.min), left_im.extent.0)/2)), 1) + -1)), (downy.s0.x.max.s + -79)), downy.s0.x.min))
  let downy.x.extent_realized.s.s = (let t106046 = min((((((downy$1.s0.x.max.s - downy$1.s0.x.min)/8)*8) + downy$1.s0.x.min) + 7), downy$1.s0.x.max.s) in max(max(min((t106046*2), ((left_im.extent.0/2) + 63)), (max(max(min((left_im.extent.0/2), ((t106046*2) + -61)), (min((min(((((((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) - argmin.s1.x.min) + -1)/16)*16) + argmin.s1.x.min) + 16), ((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0)) + 3), left_im.extent.0)/2)), 1) + 63)), min((((((downy.s0.x.max.s - downy.s0.x.min)/16)*16) + downy.s0.x.min) + 15), downy.s0.x.max.s)))
  let downy.stride.2 = (((downy.x.extent_realized.s.s - downy.x.min_realized) + -63)*((downy.y.extent_realized.s.s - downy.y.min_realized.s) + 14))
  allocate downy[float32 * ((downy.x.extent_realized.s.s - downy.x.min_realized) + -63) * ((downy.y.extent_realized.s.s - downy.y.min_realized.s) + 14) * max(slices, 2) * 2] if (uint1)0
  let downy.buffer = _halide_buffer_init(alloca(size_of_halide_buffer_t()), make_struct((halide_dimension_t *), downy.x.min_realized, ((downy.x.extent_realized.s.s - downy.x.min_realized) + -63), 1, 0, (downy.y.min_realized.s + -13), ((downy.y.extent_realized.s.s - downy.y.min_realized.s) + 14), ((downy.x.extent_realized.s.s - downy.x.min_realized) + -63), 0, (min(slices, 2) + -2), max(slices, 2), downy.stride.2, 0, 0, 2, (max(slices, 2)*downy.stride.2), 0), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 4, make_struct((halide_dimension_t *), downy.x.min_realized, ((downy.x.extent_realized.s.s - downy.x.min_realized) + -63), 1, 0, (downy.y.min_realized.s + -13), ((downy.y.extent_realized.s.s - downy.y.min_realized.s) + 14), ((downy.x.extent_realized.s.s - downy.x.min_realized) + -63), 0, (min(slices, 2) + -2), max(slices, 2), downy.stride.2, 0, 0, 2, (max(slices, 2)*downy.stride.2), 0), (uint64)0)
  register_destructor("halide_device_free_as_destructor", downy.buffer)
  let downy.s0.y.y_o.loop_extent.s = (max(downy.s0.y.max.s, 0) - max(downy.s0.y.min.s, 1))
  produce downy {
    consume cost_confidence {
      consume diff {
        let halide_device_malloc_result$11 = halide_device_malloc(downy.buffer, halide_cuda_device_interface())
        assert((halide_device_malloc_result$11 == 0), halide_device_malloc_result$11)
        let t105082 = (2 - min(slices, 2))
        let t106367 = ((diff.x.extent_realized.s.s - diff.x.min_realized) + -128)
        let t106355 = max(downy.s0.y.max.s, 0)
        let t106351 = ((slices + 1)/2)
        let t106352 = ((downy.s0.y.y_o.loop_extent.s + 15)/14)
        let t106364 = (int64(diff.stride.3)*(int64)2)
        let t106366 = (max(slices, 2)*downy.stride.2)
        let t106363 = ((diff.y.extent_realized.s - diff.y.min_realized)*t106367)
        let t106362 = (4 - diff.z.min_realized.s)
        let t106358 = (-27 - diff.y.min_realized)
        let t106360 = (-27 - cost_confidence.y.min_realized)
        let t106356 = (max(downy.s0.y.min.s, 1) + 12)
        let t106353 = (((downy.s0.x.max.s - downy.s0.x.min)/16) + -3)
        let t106365 = ((downy.x.extent_realized.s.s - downy.x.min_realized) + -63)
        let t106361 = ((cost_confidence.x.extent_realized.s.s - cost_confidence.x.min_realized) + -125)
        let t106354 = (slices + -2)
        let t106357 = (downy.s0.x.max.s + -79)
        gpu_block<CUDA> (downy.s0._0._0_o.__block_id_z, 0, t106351) {
          gpu_block<CUDA> (downy.s0.y.y_o.__block_id_y, 0, t106352) {
            gpu_block<CUDA> (downy.s0.x.x_o.__block_id_x, 0, t106353) {
              allocate __shared[uint8 * 7680] in GPUShared
              gpu_thread<CUDA> (.__thread_id_z, 0, 2) {
                gpu_thread<CUDA> (.__thread_id_y, 0, 30) {
                  gpu_thread<CUDA> (.__thread_id_x, 0, 16) {
                    let downy.s0._0._0_i.base = min((downy.s0._0._0_o.__block_id_z*2), t106354)
                    let downy.s0.y.y_i.base.s = min(((downy.s0.y.y_o.__block_id_y*14) + t106356), t106355)
                    let downy.s0.x.x_i.base = min(((downy.s0.x.x_o.__block_id_x*16) + downy.s0.x.min), t106357)
                    produce downx {
                      let t105090 = (int64((((downy.s0.y.y_i.base.s*2) + t106358) + .__thread_id_y))*int64(t106367))
                      let t105087 = (int64((((downy.s0.y.y_i.base.s*2) + t106360) + .__thread_id_y))*int64(t106361))
                      let t105089 = (int64(((downy.s0._0._0_i.base + t106362) + .__thread_id_z))*int64(t106363))
                      let t105094 = ((((int64(.__thread_id_z)*(int64)30) + int64(.__thread_id_y))*(int64)16) + int64(.__thread_id_x))
                      let t106372 = ((t105089 + t106364) + t105090)
                      let t106374 = ((t105089 + int64(diff.stride.3)) + t105090)
                      let t106373 = (t105089 + t105090)
                      let t106368 = (.__thread_id_x + downy.s0.x.x_i.base)
                      for (downx.s0._1, 0, 2) {
                        __shared[((int64(downx.s0._1)*(int64)960) + t105094)] = (let t106055 = cost_confidence[((t105087 + int64(((t106368*2) - cost_confidence.x.min_realized))) + (int64)-1)] in (let t106056 = (downx.s0._1 == 0) in (let t106057 = cost_confidence[(t105087 + int64(((t106368*2) - cost_confidence.x.min_realized)))] in (let t106058 = cost_confidence[((t105087 + int64(((t106368*2) - cost_confidence.x.min_realized))) + (int64)1)] in (let t106059 = cost_confidence[((t105087 + int64(((t106368*2) - cost_confidence.x.min_realized))) + (int64)2)] in (let t106064.s = diff[((t106372 + int64(((t106368*2) - diff.x.min_realized))) + (int64)2)] in (let t106065.s = diff[((t106373 + int64(((t106368*2) - diff.x.min_realized))) + (int64)2)] in (let t106066.s = diff[((t106374 + int64(((t106368*2) - diff.x.min_realized))) + (int64)2)] in (let t106067.s = diff[((t106372 + int64(((t106368*2) - diff.x.min_realized))) + (int64)-1)] in (let t106068.s = diff[((t106373 + int64(((t106368*2) - diff.x.min_realized))) + (int64)-1)] in (let t106069.s = diff[((t106374 + int64(((t106368*2) - diff.x.min_realized))) + (int64)-1)] in (let t106070.s = diff[(t106372 + int64(((t106368*2) - diff.x.min_realized)))] in (let t106071.s = diff[(t106373 + int64(((t106368*2) - diff.x.min_realized)))] in (let t106072.s = diff[(t106374 + int64(((t106368*2) - diff.x.min_realized)))] in (let t106073.s = diff[((t106372 + int64(((t106368*2) - diff.x.min_realized))) + (int64)1)] in (let t106074.s = diff[((t106373 + int64(((t106368*2) - diff.x.min_realized))) + (int64)1)] in (let t106075.s = diff[((t106374 + int64(((t106368*2) - diff.x.min_realized))) + (int64)1)] in ((select(t106056, ((((float32(t106064.s)*float32(t106064.s)) + ((float32(t106065.s)*float32(t106065.s)) + (float32(t106066.s)*float32(t106066.s))))*t106059) + (((float32(t106067.s)*float32(t106067.s)) + ((float32(t106068.s)*float32(t106068.s)) + (float32(t106069.s)*float32(t106069.s))))*t106055)), (t106055 + t106059)) + (select(t106056, ((((float32(t106070.s)*float32(t106070.s)) + ((float32(t106071.s)*float32(t106071.s)) + (float32(t106072.s)*float32(t106072.s))))*t106057) + (((float32(t106073.s)*float32(t106073.s)) + ((float32(t106074.s)*float32(t106074.s)) + (float32(t106075.s)*float32(t106075.s))))*t106058)), (t106057 + t106058))*3.000000f))*0.125000f))))))))))))))))))
                      }
                    }
                    gpu_thread_barrier()
                    consume downx {
                      if ((.__thread_id_y < 14)) {
                        let t105102 = ((((int64(.__thread_id_z)*(int64)30) + int64(((.__thread_id_y*2) + 1)))*(int64)16) + int64(.__thread_id_x))
                        let t105101 = (((int64(((downy.s0._0._0_i.base + t105082) + .__thread_id_z))*int64(downy.stride.2)) + (int64(((downy.s0.y.y_i.base.s - downy.y.min_realized.s) + .__thread_id_y))*int64(t106365))) + int64(((downy.s0.x.x_i.base - downy.x.min_realized) + .__thread_id_x)))
                        for (downy.s0._1, 0, 2) {
                          downy[((int64(downy.s0._1)*int64(t106366)) + t105101)] = ((__shared[(((int64(downy.s0._1)*(int64)960) + t105102) + (int64)32)] + (__shared[(((int64(downy.s0._1)*(int64)960) + t105102) + (int64)-16)] + ((__shared[((int64(downy.s0._1)*(int64)960) + t105102)] + __shared[(((int64(downy.s0._1)*(int64)960) + t105102) + (int64)16)])*3.000000f)))*0.125000f)
                        }
                      }
                    }
                  }
                }
              }
              free __shared
            }
          }
        }
        _halide_buffer_set_device_dirty(downy.buffer, (uint1)1)
      }
    }
  }
  let downy$1.y.min_realized = min(max(downy$1.s0.y.min.s, 0), min(min(max(((min(min((argmin.s1.y.min + 49), ((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1)), (left_im.extent.1 + 51)) + -55)/4), 0), (max(min((left_im.extent.1/4), (min(max(downy$2.s0.y.min.s, 0), (max(downy$2.s0.y.max.s, 0) + -13))*2)), 1) + -1)), (max(downy$1.s0.y.max.s, 0) + -13)))
  let downy$1.y.extent_realized.s.s = max(max(min(min(((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 5)/4), (((argmin.s1.y.min + 54)/4) + (((((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 5)/4) - ((argmin.s1.y.min + -6)/4))/16)*16))), ((left_im.extent.1/4) + -1)), (max(min((left_im.extent.1/4), ((min(max(downy$2.s0.y.max.s, 0), ((max(downy$2.s0.y.min.s, 0) + (((max(downy$2.s0.y.max.s, 0) - max(downy$2.s0.y.min.s, 0))/14)*14)) + 13))*2) + 3)), 1) + -1)), min(max(downy$1.s0.y.max.s, 0), ((max(downy$1.s0.y.min.s, 0) + (((max(downy$1.s0.y.max.s, 0) - max(downy$1.s0.y.min.s, 0))/14)*14)) + 13)))
  let downy$1.x.min_realized = (let t106081 = min((downy$2.s0.x.max.s + -23), downy$2.s0.x.min) in min(min(min(max(((min(min((argmin.s1.x.min + 49), ((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0)), (left_im.extent.0 + 51)) + -55)/4), 0), min(max(min((t106081*2), ((left_im.extent.0/4) + -1)), 0), (max(min((left_im.extent.0/4), (t106081*2)), 1) + -1))), (downy$1.s0.x.max.s + -39)), downy$1.s0.x.min))
  let downy$1.x.extent_realized.s.s = (let t106082 = min((((((downy$2.s0.x.max.s - downy$2.s0.x.min)/8)*8) + downy$2.s0.x.min) + 7), downy$2.s0.x.max.s) in max(min(min(((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 5)/4), (((argmin.s1.x.min + 54)/4) + (((((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 5)/4) - ((argmin.s1.x.min + -6)/4))/16)*16))), ((left_im.extent.0/4) + -1)), (max(max(min((t106082*2), ((left_im.extent.0/4) + 31)), (max(min((left_im.extent.0/4), ((t106082*2) + -29)), 1) + 31)), min((((((downy$1.s0.x.max.s - downy$1.s0.x.min)/8)*8) + downy$1.s0.x.min) + 7), downy$1.s0.x.max.s)) + -32)))
  let downy$1.stride.2 = (((downy$1.x.extent_realized.s.s - downy$1.x.min_realized) + 1)*((downy$1.y.extent_realized.s.s - downy$1.y.min_realized) + 1))
  allocate downy$1[float32 * ((downy$1.x.extent_realized.s.s - downy$1.x.min_realized) + 1) * ((downy$1.y.extent_realized.s.s - downy$1.y.min_realized) + 1) * max(slices, 2) * 2] if (uint1)0
  let downy$1.buffer = _halide_buffer_init(alloca(size_of_halide_buffer_t()), make_struct((halide_dimension_t *), downy$1.x.min_realized, ((downy$1.x.extent_realized.s.s - downy$1.x.min_realized) + 1), 1, 0, downy$1.y.min_realized, ((downy$1.y.extent_realized.s.s - downy$1.y.min_realized) + 1), ((downy$1.x.extent_realized.s.s - downy$1.x.min_realized) + 1), 0, (min(slices, 2) + -2), max(slices, 2), downy$1.stride.2, 0, 0, 2, (max(slices, 2)*downy$1.stride.2), 0), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 4, make_struct((halide_dimension_t *), downy$1.x.min_realized, ((downy$1.x.extent_realized.s.s - downy$1.x.min_realized) + 1), 1, 0, downy$1.y.min_realized, ((downy$1.y.extent_realized.s.s - downy$1.y.min_realized) + 1), ((downy$1.x.extent_realized.s.s - downy$1.x.min_realized) + 1), 0, (min(slices, 2) + -2), max(slices, 2), downy$1.stride.2, 0, 0, 2, (max(slices, 2)*downy$1.stride.2), 0), (uint64)0)
  register_destructor("halide_device_free_as_destructor", downy$1.buffer)
  let downy$1.s0.y.y_o.loop_extent.s = (max(downy$1.s0.y.max.s, 0) - max(downy$1.s0.y.min.s, 0))
  produce downy$1 {
    consume downy {
      let halide_device_malloc_result$10 = halide_device_malloc(downy$1.buffer, halide_cuda_device_interface())
      assert((halide_device_malloc_result$10 == 0), halide_device_malloc_result$10)
      let t105110 = (2 - min(slices, 2))
      let t106394 = (left_im.extent.0/2)
      let t106395 = max(slices, 2)
      let t106382 = max(downy$1.s0.y.min.s, 0)
      let t106378 = ((slices + 1)/2)
      let t106386 = (left_im.extent.1/2)
      let t106388 = (downy.stride.2*t106395)
      let t106393 = (downy$1.stride.2*t106395)
      let t106385 = (12 - downy.y.min_realized.s)
      let t106383 = (max(downy$1.s0.y.max.s, 0) + -13)
      let t106380 = (((downy$1.s0.x.max.s - downy$1.s0.x.min)/8) + -3)
      let t106379 = ((downy$1.s0.y.y_o.loop_extent.s/14) + 1)
      let t106387 = ((downy.x.extent_realized.s.s - downy.x.min_realized) + -63)
      let t106392 = ((downy$1.x.extent_realized.s.s - downy$1.x.min_realized) + 1)
      let t106381 = (slices + -2)
      let t106384 = (downy$1.s0.x.max.s + -39)
      gpu_block<CUDA> (downy$1.s0._0._0_o.__block_id_z, 0, t106378) {
        gpu_block<CUDA> (downy$1.s0.y.y_o.__block_id_y, 0, t106379) {
          gpu_block<CUDA> (downy$1.s0.x.x_o.__block_id_x, 0, t106380) {
            allocate __shared[uint8 * 3840] in GPUShared
            gpu_thread<CUDA> (.__thread_id_z, 0, 2) {
              gpu_thread<CUDA> (.__thread_id_y, 0, 30) {
                gpu_thread<CUDA> (.__thread_id_x, 0, 8) {
                  let downy$1.s0._0._0_i.base = min((downy$1.s0._0._0_o.__block_id_z*2), t106381)
                  let downy$1.s0.y.y_i.base = min(((downy$1.s0.y.y_o.__block_id_y*14) + t106382), t106383)
                  let downy$1.s0.x.x_i.base = min(((downy$1.s0.x.x_o.__block_id_x*8) + downy$1.s0.x.min), t106384)
                  produce downx$1 {
                    let t105126 = ((((int64(.__thread_id_z)*(int64)30) + int64(.__thread_id_y))*(int64)8) + int64(.__thread_id_x))
                    let t105122 = ((int64(((downy$1.s0._0._0_i.base + t105110) + .__thread_id_z))*int64(downy.stride.2)) + (int64((max(min(((downy$1.s0.y.y_i.base*2) + .__thread_id_y), t106386), 1) + t106385))*int64(t106387)))
                    let t106396 = (.__thread_id_x + downy$1.s0.x.x_i.base)
                    for (downx$1.s0._1, 0, 2) {
                      __shared[((int64(downx$1.s0._1)*(int64)480) + t105126)] = (let t106089 = (int64(downx$1.s0._1)*int64(t106388)) in ((downy[((t105122 + int64(((max(min(((t106396*2) + 3), t106394), 1) - downy.x.min_realized) + -1))) + t106089)] + (downy[((t105122 + int64(((max(min((t106396*2), t106394), 1) - downy.x.min_realized) + -1))) + t106089)] + ((downy[((t105122 + int64((max(min((t106396*2), (t106394 + -1)), 0) - downy.x.min_realized))) + t106089)] + downy[((t105122 + int64(((max(min(((t106396*2) + 2), t106394), 1) - downy.x.min_realized) + -1))) + t106089)])*3.000000f)))*0.125000f))
                    }
                  }
                  gpu_thread_barrier()
                  consume downx$1 {
                    if ((.__thread_id_y < 14)) {
                      let t105132 = ((((int64(.__thread_id_z)*(int64)30) + int64(((.__thread_id_y*2) + 1)))*(int64)8) + int64(.__thread_id_x))
                      let t105131 = (((int64(((downy$1.s0._0._0_i.base + t105110) + .__thread_id_z))*int64(downy$1.stride.2)) + (int64(((downy$1.s0.y.y_i.base - downy$1.y.min_realized) + .__thread_id_y))*int64(t106392))) + int64(((downy$1.s0.x.x_i.base - downy$1.x.min_realized) + .__thread_id_x)))
                      for (downy$1.s0._1, 0, 2) {
                        downy$1[((int64(downy$1.s0._1)*int64(t106393)) + t105131)] = ((__shared[(((int64(downy$1.s0._1)*(int64)480) + t105132) + (int64)16)] + (__shared[(((int64(downy$1.s0._1)*(int64)480) + t105132) + (int64)-8)] + ((__shared[((int64(downy$1.s0._1)*(int64)480) + t105132)] + __shared[(((int64(downy$1.s0._1)*(int64)480) + t105132) + (int64)8)])*3.000000f)))*0.125000f)
                      }
                    }
                  }
                }
              }
            }
            free __shared
          }
        }
      }
      _halide_buffer_set_device_dirty(downy$1.buffer, (uint1)1)
    }
  }
  let downy$2.y.min_realized = min(min(max(downy$2.s0.y.min.s, 0), (max(downy$2.s0.y.max.s, 0) + -13)), (max(min(min(((min((argmin.s1.y.min + 49), ((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1)) + -55)/8), (min(max(downy$3.s0.y.min.s, 0), (max(downy$3.s0.y.max.s, 0) + -13))*2)), (left_im.extent.1/8)), 1) + -1))
  let downy$2.y.extent_realized.s.s = max(min(max(downy$2.s0.y.max.s, 0), ((max(downy$2.s0.y.min.s, 0) + (((max(downy$2.s0.y.max.s, 0) - max(downy$2.s0.y.min.s, 0))/14)*14)) + 13)), (max(min((left_im.extent.1/8), (max((min(((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 5)/4), (((argmin.s1.y.min + 54)/4) + (((((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 5)/4) - ((argmin.s1.y.min + -6)/4))/16)*16)))/2), ((min(max(downy$3.s0.y.max.s, 0), ((max(downy$3.s0.y.min.s, 0) + (((max(downy$3.s0.y.max.s, 0) - max(downy$3.s0.y.min.s, 0))/14)*14)) + 13))*2) + 1)) + 2)), 1) + -1))
  let downy$2.x.min_realized = (let t106096 = min((downy$3.s0.x.max.s + -15), downy$3.s0.x.min) in min(min(min(max(min((t106096*2), ((left_im.extent.0/8) + -1)), 0), (max(min(min(((min((argmin.s1.x.min + 49), ((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0)) + -55)/8), (t106096*2)), (left_im.extent.0/8)), 1) + -1)), (downy$2.s0.x.max.s + -23)), downy$2.s0.x.min))
  let downy$2.x.extent_realized.s.s = (let t106097 = min((((((downy$3.s0.x.max.s - downy$3.s0.x.min)/8)*8) + downy$3.s0.x.min) + 7), downy$3.s0.x.max.s) in max(max(min((t106097*2), ((left_im.extent.0/8) + 15)), (max(min((left_im.extent.0/8), (max((min(((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 5)/4), (((argmin.s1.x.min + 54)/4) + (((((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 5)/4) - ((argmin.s1.x.min + -6)/4))/16)*16)))/2), ((t106097*2) + -15)) + 2)), 1) + 15)), min((((((downy$2.s0.x.max.s - downy$2.s0.x.min)/8)*8) + downy$2.s0.x.min) + 7), downy$2.s0.x.max.s)))
  let downy$2.stride.2 = (((downy$2.x.extent_realized.s.s - downy$2.x.min_realized) + -15)*((downy$2.y.extent_realized.s.s - downy$2.y.min_realized) + 1))
  allocate downy$2[float32 * ((downy$2.x.extent_realized.s.s - downy$2.x.min_realized) + -15) * ((downy$2.y.extent_realized.s.s - downy$2.y.min_realized) + 1) * max(slices, 2) * 2] if (uint1)0
  let downy$2.buffer = _halide_buffer_init(alloca(size_of_halide_buffer_t()), make_struct((halide_dimension_t *), downy$2.x.min_realized, ((downy$2.x.extent_realized.s.s - downy$2.x.min_realized) + -15), 1, 0, downy$2.y.min_realized, ((downy$2.y.extent_realized.s.s - downy$2.y.min_realized) + 1), ((downy$2.x.extent_realized.s.s - downy$2.x.min_realized) + -15), 0, (min(slices, 2) + -2), max(slices, 2), downy$2.stride.2, 0, 0, 2, (max(slices, 2)*downy$2.stride.2), 0), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 4, make_struct((halide_dimension_t *), downy$2.x.min_realized, ((downy$2.x.extent_realized.s.s - downy$2.x.min_realized) + -15), 1, 0, downy$2.y.min_realized, ((downy$2.y.extent_realized.s.s - downy$2.y.min_realized) + 1), ((downy$2.x.extent_realized.s.s - downy$2.x.min_realized) + -15), 0, (min(slices, 2) + -2), max(slices, 2), downy$2.stride.2, 0, 0, 2, (max(slices, 2)*downy$2.stride.2), 0), (uint64)0)
  register_destructor("halide_device_free_as_destructor", downy$2.buffer)
  let downy$2.s0.y.y_o.loop_extent.s = (max(downy$2.s0.y.max.s, 0) - max(downy$2.s0.y.min.s, 0))
  produce downy$2 {
    consume downy$1 {
      let halide_device_malloc_result$9 = halide_device_malloc(downy$2.buffer, halide_cuda_device_interface())
      assert((halide_device_malloc_result$9 == 0), halide_device_malloc_result$9)
      let t105140 = (2 - min(slices, 2))
      let t106418 = (left_im.extent.0/4)
      let t106419 = max(slices, 2)
      let t106406 = max(downy$2.s0.y.min.s, 0)
      let t106402 = ((slices + 1)/2)
      let t106410 = (left_im.extent.1/4)
      let t106417 = (downy$2.stride.2*t106419)
      let t106412 = (downy$1.stride.2*t106419)
      let t106409 = (-1 - downy$1.y.min_realized)
      let t106407 = (max(downy$2.s0.y.max.s, 0) + -13)
      let t106404 = (((downy$2.s0.x.max.s - downy$2.s0.x.min)/8) + -1)
      let t106403 = ((downy$2.s0.y.y_o.loop_extent.s/14) + 1)
      let t106416 = ((downy$2.x.extent_realized.s.s - downy$2.x.min_realized) + -15)
      let t106411 = ((downy$1.x.extent_realized.s.s - downy$1.x.min_realized) + 1)
      let t106405 = (slices + -2)
      let t106408 = (downy$2.s0.x.max.s + -23)
      gpu_block<CUDA> (downy$2.s0._0._0_o.__block_id_z, 0, t106402) {
        gpu_block<CUDA> (downy$2.s0.y.y_o.__block_id_y, 0, t106403) {
          gpu_block<CUDA> (downy$2.s0.x.x_o.__block_id_x, 0, t106404) {
            allocate __shared[uint8 * 3840] in GPUShared
            gpu_thread<CUDA> (.__thread_id_z, 0, 2) {
              gpu_thread<CUDA> (.__thread_id_y, 0, 30) {
                gpu_thread<CUDA> (.__thread_id_x, 0, 8) {
                  let downy$2.s0._0._0_i.base = min((downy$2.s0._0._0_o.__block_id_z*2), t106405)
                  let downy$2.s0.y.y_i.base = min(((downy$2.s0.y.y_o.__block_id_y*14) + t106406), t106407)
                  let downy$2.s0.x.x_i.base = min(((downy$2.s0.x.x_o.__block_id_x*8) + downy$2.s0.x.min), t106408)
                  produce downx$2 {
                    let t105156 = ((((int64(.__thread_id_z)*(int64)30) + int64(.__thread_id_y))*(int64)8) + int64(.__thread_id_x))
                    let t105152 = ((int64(((downy$2.s0._0._0_i.base + t105140) + .__thread_id_z))*int64(downy$1.stride.2)) + (int64((max(min(((downy$2.s0.y.y_i.base*2) + .__thread_id_y), t106410), 1) + t106409))*int64(t106411)))
                    let t106420 = (.__thread_id_x + downy$2.s0.x.x_i.base)
                    for (downx$2.s0._1, 0, 2) {
                      __shared[((int64(downx$2.s0._1)*(int64)480) + t105156)] = (let t106104 = (int64(downx$2.s0._1)*int64(t106412)) in ((downy$1[((t105152 + int64(((max(min(((t106420*2) + 3), t106418), 1) - downy$1.x.min_realized) + -1))) + t106104)] + (downy$1[((t105152 + int64(((max(min((t106420*2), t106418), 1) - downy$1.x.min_realized) + -1))) + t106104)] + ((downy$1[((t105152 + int64((max(min((t106420*2), (t106418 + -1)), 0) - downy$1.x.min_realized))) + t106104)] + downy$1[((t105152 + int64(((max(min(((t106420*2) + 2), t106418), 1) - downy$1.x.min_realized) + -1))) + t106104)])*3.000000f)))*0.125000f))
                    }
                  }
                  gpu_thread_barrier()
                  consume downx$2 {
                    if ((.__thread_id_y < 14)) {
                      let t105162 = ((((int64(.__thread_id_z)*(int64)30) + int64(((.__thread_id_y*2) + 1)))*(int64)8) + int64(.__thread_id_x))
                      let t105161 = (((int64(((downy$2.s0._0._0_i.base + t105140) + .__thread_id_z))*int64(downy$2.stride.2)) + (int64(((downy$2.s0.y.y_i.base - downy$2.y.min_realized) + .__thread_id_y))*int64(t106416))) + int64(((downy$2.s0.x.x_i.base - downy$2.x.min_realized) + .__thread_id_x)))
                      for (downy$2.s0._1, 0, 2) {
                        downy$2[((int64(downy$2.s0._1)*int64(t106417)) + t105161)] = ((__shared[(((int64(downy$2.s0._1)*(int64)480) + t105162) + (int64)16)] + (__shared[(((int64(downy$2.s0._1)*(int64)480) + t105162) + (int64)-8)] + ((__shared[((int64(downy$2.s0._1)*(int64)480) + t105162)] + __shared[(((int64(downy$2.s0._1)*(int64)480) + t105162) + (int64)8)])*3.000000f)))*0.125000f)
                      }
                    }
                  }
                }
              }
            }
            free __shared
          }
        }
      }
      _halide_buffer_set_device_dirty(downy$2.buffer, (uint1)1)
    }
  }
  let downy$3.y.min_realized = min(max(downy$3.s0.y.min.s, 0), min(min(max(((min(min((argmin.s1.y.min + 49), ((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1)), (left_im.extent.1 + 63)) + -79)/16), 0), (max(min((left_im.extent.1/16), (min(max(downy$4.s0.y.min.s, 0), (max(downy$4.s0.y.max.s, 0) + -13))*2)), 1) + -1)), (max(downy$3.s0.y.max.s, 0) + -13)))
  let downy$3.y.extent_realized.s.s = max(max(min(((min(((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 5)/4), (((argmin.s1.y.min + 54)/4) + (((((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 5)/4) - ((argmin.s1.y.min + -6)/4))/16)*16))) + 6)/4), ((left_im.extent.1/16) + -1)), (max(min((left_im.extent.1/16), ((min(max(downy$4.s0.y.max.s, 0), ((max(downy$4.s0.y.min.s, 0) + (((max(downy$4.s0.y.max.s, 0) - max(downy$4.s0.y.min.s, 0))/14)*14)) + 13))*2) + 3)), 1) + -1)), min(max(downy$3.s0.y.max.s, 0), ((max(downy$3.s0.y.min.s, 0) + (((max(downy$3.s0.y.max.s, 0) - max(downy$3.s0.y.min.s, 0))/14)*14)) + 13)))
  let downy$3.x.min_realized = (let t106111 = min((downy$4.s0.x.max.s + -11), downy$4.s0.x.min) in min(min(min(max(((min(min((argmin.s1.x.min + 49), ((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0)), (left_im.extent.0 + 63)) + -79)/16), 0), min(max(min((t106111*2), ((left_im.extent.0/16) + -1)), 0), (max(min((left_im.extent.0/16), (t106111*2)), 1) + -1))), (downy$3.s0.x.max.s + -15)), downy$3.s0.x.min))
  let downy$3.x.extent_realized.s.s = (let t106112 = min(((((((downy$4.s0.x.max.s - downy$4.s0.x.min) + -4)/8)*8) + downy$4.s0.x.min) + 11), downy$4.s0.x.max.s) in max(min(((min(((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 5)/4), (((argmin.s1.x.min + 54)/4) + (((((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 5)/4) - ((argmin.s1.x.min + -6)/4))/16)*16))) + 6)/4), ((left_im.extent.0/16) + -1)), (max(max(min((t106112*2), ((left_im.extent.0/16) + 7)), (max(min((left_im.extent.0/16), ((t106112*2) + -5)), 1) + 7)), min((((((downy$3.s0.x.max.s - downy$3.s0.x.min)/8)*8) + downy$3.s0.x.min) + 7), downy$3.s0.x.max.s)) + -8)))
  let downy$3.stride.2 = (((downy$3.x.extent_realized.s.s - downy$3.x.min_realized) + 1)*((downy$3.y.extent_realized.s.s - downy$3.y.min_realized) + 1))
  allocate downy$3[float32 * ((downy$3.x.extent_realized.s.s - downy$3.x.min_realized) + 1) * ((downy$3.y.extent_realized.s.s - downy$3.y.min_realized) + 1) * max(slices, 2) * 2] if (uint1)0
  let downy$3.buffer = _halide_buffer_init(alloca(size_of_halide_buffer_t()), make_struct((halide_dimension_t *), downy$3.x.min_realized, ((downy$3.x.extent_realized.s.s - downy$3.x.min_realized) + 1), 1, 0, downy$3.y.min_realized, ((downy$3.y.extent_realized.s.s - downy$3.y.min_realized) + 1), ((downy$3.x.extent_realized.s.s - downy$3.x.min_realized) + 1), 0, (min(slices, 2) + -2), max(slices, 2), downy$3.stride.2, 0, 0, 2, (max(slices, 2)*downy$3.stride.2), 0), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 4, make_struct((halide_dimension_t *), downy$3.x.min_realized, ((downy$3.x.extent_realized.s.s - downy$3.x.min_realized) + 1), 1, 0, downy$3.y.min_realized, ((downy$3.y.extent_realized.s.s - downy$3.y.min_realized) + 1), ((downy$3.x.extent_realized.s.s - downy$3.x.min_realized) + 1), 0, (min(slices, 2) + -2), max(slices, 2), downy$3.stride.2, 0, 0, 2, (max(slices, 2)*downy$3.stride.2), 0), (uint64)0)
  register_destructor("halide_device_free_as_destructor", downy$3.buffer)
  let downy$3.s0.y.y_o.loop_extent.s = (max(downy$3.s0.y.max.s, 0) - max(downy$3.s0.y.min.s, 0))
  produce downy$3 {
    consume downy$2 {
      let halide_device_malloc_result$8 = halide_device_malloc(downy$3.buffer, halide_cuda_device_interface())
      assert((halide_device_malloc_result$8 == 0), halide_device_malloc_result$8)
      let t105170 = (2 - min(slices, 2))
      let t106442 = (left_im.extent.0/8)
      let t106443 = max(slices, 2)
      let t106430 = max(downy$3.s0.y.min.s, 0)
      let t106428 = ((downy$3.s0.x.max.s - downy$3.s0.x.min)/8)
      let t106426 = ((slices + 1)/2)
      let t106434 = (left_im.extent.1/8)
      let t106441 = (downy$3.stride.2*t106443)
      let t106436 = (downy$2.stride.2*t106443)
      let t106433 = (-1 - downy$2.y.min_realized)
      let t106431 = (max(downy$3.s0.y.max.s, 0) + -13)
      let t106427 = ((downy$3.s0.y.y_o.loop_extent.s/14) + 1)
      let t106440 = ((downy$3.x.extent_realized.s.s - downy$3.x.min_realized) + 1)
      let t106435 = ((downy$2.x.extent_realized.s.s - downy$2.x.min_realized) + -15)
      let t106429 = (slices + -2)
      let t106432 = (downy$3.s0.x.max.s + -15)
      gpu_block<CUDA> (downy$3.s0._0._0_o.__block_id_z, 0, t106426) {
        gpu_block<CUDA> (downy$3.s0.y.y_o.__block_id_y, 0, t106427) {
          gpu_block<CUDA> (downy$3.s0.x.x_o.__block_id_x, 0, t106428) {
            allocate __shared[uint8 * 3840] in GPUShared
            gpu_thread<CUDA> (.__thread_id_z, 0, 2) {
              gpu_thread<CUDA> (.__thread_id_y, 0, 30) {
                gpu_thread<CUDA> (.__thread_id_x, 0, 8) {
                  let downy$3.s0._0._0_i.base = min((downy$3.s0._0._0_o.__block_id_z*2), t106429)
                  let downy$3.s0.y.y_i.base = min(((downy$3.s0.y.y_o.__block_id_y*14) + t106430), t106431)
                  let downy$3.s0.x.x_i.base = min(((downy$3.s0.x.x_o.__block_id_x*8) + downy$3.s0.x.min), t106432)
                  produce downx$3 {
                    let t105186 = ((((int64(.__thread_id_z)*(int64)30) + int64(.__thread_id_y))*(int64)8) + int64(.__thread_id_x))
                    let t105182 = ((int64(((downy$3.s0._0._0_i.base + t105170) + .__thread_id_z))*int64(downy$2.stride.2)) + (int64((max(min(((downy$3.s0.y.y_i.base*2) + .__thread_id_y), t106434), 1) + t106433))*int64(t106435)))
                    let t106444 = (.__thread_id_x + downy$3.s0.x.x_i.base)
                    for (downx$3.s0._1, 0, 2) {
                      __shared[((int64(downx$3.s0._1)*(int64)480) + t105186)] = (let t106119 = (int64(downx$3.s0._1)*int64(t106436)) in ((downy$2[((t105182 + int64(((max(min(((t106444*2) + 3), t106442), 1) - downy$2.x.min_realized) + -1))) + t106119)] + (downy$2[((t105182 + int64(((max(min((t106444*2), t106442), 1) - downy$2.x.min_realized) + -1))) + t106119)] + ((downy$2[((t105182 + int64((max(min((t106444*2), (t106442 + -1)), 0) - downy$2.x.min_realized))) + t106119)] + downy$2[((t105182 + int64(((max(min(((t106444*2) + 2), t106442), 1) - downy$2.x.min_realized) + -1))) + t106119)])*3.000000f)))*0.125000f))
                    }
                  }
                  gpu_thread_barrier()
                  consume downx$3 {
                    if ((.__thread_id_y < 14)) {
                      let t105192 = ((((int64(.__thread_id_z)*(int64)30) + int64(((.__thread_id_y*2) + 1)))*(int64)8) + int64(.__thread_id_x))
                      let t105191 = (((int64(((downy$3.s0._0._0_i.base + t105170) + .__thread_id_z))*int64(downy$3.stride.2)) + (int64(((downy$3.s0.y.y_i.base - downy$3.y.min_realized) + .__thread_id_y))*int64(t106440))) + int64(((downy$3.s0.x.x_i.base - downy$3.x.min_realized) + .__thread_id_x)))
                      for (downy$3.s0._1, 0, 2) {
                        downy$3[((int64(downy$3.s0._1)*int64(t106441)) + t105191)] = ((__shared[(((int64(downy$3.s0._1)*(int64)480) + t105192) + (int64)16)] + (__shared[(((int64(downy$3.s0._1)*(int64)480) + t105192) + (int64)-8)] + ((__shared[((int64(downy$3.s0._1)*(int64)480) + t105192)] + __shared[(((int64(downy$3.s0._1)*(int64)480) + t105192) + (int64)8)])*3.000000f)))*0.125000f)
                      }
                    }
                  }
                }
              }
            }
            free __shared
          }
        }
      }
      _halide_buffer_set_device_dirty(downy$3.buffer, (uint1)1)
    }
  }
  let downy$4.y.min_realized = min(max(downy$4.s0.y.min.s, 0), min(min(max(((min(min((argmin.s1.y.min + 101), ((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1)), (left_im.extent.1 + 131)) + -163)/32), 0), (max(min((left_im.extent.1/32), ((min(max(downy$5.s0.y.min.s, 1), downy$5.s0.y.max)*2) + -2)), 1) + -1)), (max(downy$4.s0.y.max.s, 0) + -13)))
  let downy$4.y.extent_realized.s.s = max(max(min(min(((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 61)/32), (((argmin.s1.y.min + 162)/32) + (((((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 61)/32) - ((argmin.s1.y.min + -62)/32))/8)*8))), ((left_im.extent.1/32) + -1)), (max(min((left_im.extent.1/32), ((min((max(downy$5.s0.y.min.s, 1) + ((((downy$5.s0.y.max - max(downy$5.s0.y.min.s, 1)) + 1)/2)*2)), downy$5.s0.y.max)*2) + 3)), 1) + -1)), min(max(downy$4.s0.y.max.s, 0), ((max(downy$4.s0.y.min.s, 0) + (((max(downy$4.s0.y.max.s, 0) - max(downy$4.s0.y.min.s, 0))/14)*14)) + 13)))
  let downy$4.x.min_realized = min((min((min(max(min((downy$5.s0.x.min.s*2), ((left_im.extent.0/32) + 3)), 4), (max(min(min(((min((argmin.s1.x.min + 53), ((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0)) + -83)/32), ((downy$5.s0.x.min.s*2) + -4)), (left_im.extent.0/32)), 1) + 3)) + 7), downy$4.s0.x.max.s) + -11), downy$4.s0.x.min)
  let downy$4.x.extent_realized.s.s = max(max(min((downy$5.s0.x.max.s*2), ((left_im.extent.0/32) + 3)), (max(min((left_im.extent.0/32), (max((min(((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 29)/16), (((argmin.s1.x.min + 82)/16) + (((((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 29)/16) - ((argmin.s1.x.min + -30)/16))/8)*8)))/2), ((downy$5.s0.x.max.s*2) + -3)) + 2)), 1) + 3)), min(((((((downy$4.s0.x.max.s - downy$4.s0.x.min) + -4)/8)*8) + downy$4.s0.x.min) + 11), downy$4.s0.x.max.s))
  let downy$4.stride.2 = (((downy$4.x.extent_realized.s.s - downy$4.x.min_realized) + -3)*((downy$4.y.extent_realized.s.s - downy$4.y.min_realized) + 1))
  allocate downy$4[float32 * ((downy$4.x.extent_realized.s.s - downy$4.x.min_realized) + -3) * ((downy$4.y.extent_realized.s.s - downy$4.y.min_realized) + 1) * max(slices, 2) * 2] if (uint1)0
  let downy$4.buffer = _halide_buffer_init(alloca(size_of_halide_buffer_t()), make_struct((halide_dimension_t *), downy$4.x.min_realized, ((downy$4.x.extent_realized.s.s - downy$4.x.min_realized) + -3), 1, 0, downy$4.y.min_realized, ((downy$4.y.extent_realized.s.s - downy$4.y.min_realized) + 1), ((downy$4.x.extent_realized.s.s - downy$4.x.min_realized) + -3), 0, (min(slices, 2) + -2), max(slices, 2), downy$4.stride.2, 0, 0, 2, (max(slices, 2)*downy$4.stride.2), 0), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 4, make_struct((halide_dimension_t *), downy$4.x.min_realized, ((downy$4.x.extent_realized.s.s - downy$4.x.min_realized) + -3), 1, 0, downy$4.y.min_realized, ((downy$4.y.extent_realized.s.s - downy$4.y.min_realized) + 1), ((downy$4.x.extent_realized.s.s - downy$4.x.min_realized) + -3), 0, (min(slices, 2) + -2), max(slices, 2), downy$4.stride.2, 0, 0, 2, (max(slices, 2)*downy$4.stride.2), 0), (uint64)0)
  register_destructor("halide_device_free_as_destructor", downy$4.buffer)
  let downy$4.s0.y.y_o.loop_extent.s = (max(downy$4.s0.y.max.s, 0) - max(downy$4.s0.y.min.s, 0))
  produce downy$4 {
    consume downy$3 {
      let halide_device_malloc_result$7 = halide_device_malloc(downy$4.buffer, halide_cuda_device_interface())
      assert((halide_device_malloc_result$7 == 0), halide_device_malloc_result$7)
      let t105200 = (2 - min(slices, 2))
      let t106466 = (left_im.extent.0/16)
      let t106467 = max(slices, 2)
      let t106454 = max(downy$4.s0.y.min.s, 0)
      let t106452 = (((downy$4.s0.x.max.s - downy$4.s0.x.min) + 4)/8)
      let t106450 = ((slices + 1)/2)
      let t106458 = (left_im.extent.1/16)
      let t106465 = (downy$4.stride.2*t106467)
      let t106460 = (downy$3.stride.2*t106467)
      let t106457 = (-1 - downy$3.y.min_realized)
      let t106455 = (max(downy$4.s0.y.max.s, 0) + -13)
      let t106451 = ((downy$4.s0.y.y_o.loop_extent.s/14) + 1)
      let t106464 = ((downy$4.x.extent_realized.s.s - downy$4.x.min_realized) + -3)
      let t106459 = ((downy$3.x.extent_realized.s.s - downy$3.x.min_realized) + 1)
      let t106453 = (slices + -2)
      let t106456 = (downy$4.s0.x.max.s + -11)
      gpu_block<CUDA> (downy$4.s0._0._0_o.__block_id_z, 0, t106450) {
        gpu_block<CUDA> (downy$4.s0.y.y_o.__block_id_y, 0, t106451) {
          gpu_block<CUDA> (downy$4.s0.x.x_o.__block_id_x, 0, t106452) {
            allocate __shared[uint8 * 3840] in GPUShared
            gpu_thread<CUDA> (.__thread_id_z, 0, 2) {
              gpu_thread<CUDA> (.__thread_id_y, 0, 30) {
                gpu_thread<CUDA> (.__thread_id_x, 0, 8) {
                  let downy$4.s0._0._0_i.base = min((downy$4.s0._0._0_o.__block_id_z*2), t106453)
                  let downy$4.s0.y.y_i.base = min(((downy$4.s0.y.y_o.__block_id_y*14) + t106454), t106455)
                  let downy$4.s0.x.x_i.base = min(((downy$4.s0.x.x_o.__block_id_x*8) + downy$4.s0.x.min), t106456)
                  produce downx$4 {
                    let t105216 = ((((int64(.__thread_id_z)*(int64)30) + int64(.__thread_id_y))*(int64)8) + int64(.__thread_id_x))
                    let t105212 = ((int64(((downy$4.s0._0._0_i.base + t105200) + .__thread_id_z))*int64(downy$3.stride.2)) + (int64((max(min(((downy$4.s0.y.y_i.base*2) + .__thread_id_y), t106458), 1) + t106457))*int64(t106459)))
                    let t106468 = (.__thread_id_x + downy$4.s0.x.x_i.base)
                    for (downx$4.s0._1, 0, 2) {
                      __shared[((int64(downx$4.s0._1)*(int64)480) + t105216)] = (let t106131 = (int64(downx$4.s0._1)*int64(t106460)) in ((downy$3[((t105212 + int64(((max(min(((t106468*2) + 3), t106466), 1) - downy$3.x.min_realized) + -1))) + t106131)] + (downy$3[((t105212 + int64(((max(min((t106468*2), t106466), 1) - downy$3.x.min_realized) + -1))) + t106131)] + ((downy$3[((t105212 + int64((max(min((t106468*2), (t106466 + -1)), 0) - downy$3.x.min_realized))) + t106131)] + downy$3[((t105212 + int64(((max(min(((t106468*2) + 2), t106466), 1) - downy$3.x.min_realized) + -1))) + t106131)])*3.000000f)))*0.125000f))
                    }
                  }
                  gpu_thread_barrier()
                  consume downx$4 {
                    if ((.__thread_id_y < 14)) {
                      let t105222 = ((((int64(.__thread_id_z)*(int64)30) + int64(((.__thread_id_y*2) + 1)))*(int64)8) + int64(.__thread_id_x))
                      let t105221 = (((int64(((downy$4.s0._0._0_i.base + t105200) + .__thread_id_z))*int64(downy$4.stride.2)) + (int64(((downy$4.s0.y.y_i.base - downy$4.y.min_realized) + .__thread_id_y))*int64(t106464))) + int64(((downy$4.s0.x.x_i.base - downy$4.x.min_realized) + .__thread_id_x)))
                      for (downy$4.s0._1, 0, 2) {
                        downy$4[((int64(downy$4.s0._1)*int64(t106465)) + t105221)] = ((__shared[(((int64(downy$4.s0._1)*(int64)480) + t105222) + (int64)16)] + (__shared[(((int64(downy$4.s0._1)*(int64)480) + t105222) + (int64)-8)] + ((__shared[((int64(downy$4.s0._1)*(int64)480) + t105222)] + __shared[(((int64(downy$4.s0._1)*(int64)480) + t105222) + (int64)8)])*3.000000f)))*0.125000f)
                      }
                    }
                  }
                }
              }
            }
            free __shared
          }
        }
      }
      _halide_buffer_set_device_dirty(downy$4.buffer, (uint1)1)
    }
  }
  let downy$5.y.min_realized = (let t106133 = min((argmin.s1.y.min + 101), ((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1)) in min(max(((min((left_im.extent.1 + 99), t106133) + -163)/64), 0), (min(max(downy$5.s0.y.min.s, 1), min(max(min(min(((t106133 + -163)/64), (min(max(((downy$6.s0.y.min.s + -254)/128), 0), (max((downy$6.s0.y.max.s/128), 1) + -3))*2)), (left_im.extent.1/64)), 1), downy$5.s0.y.max)) + -1)))
  let downy$5.y.extent_realized.s.s = (let t106135 = min(((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 61)/32), (((argmin.s1.y.min + 162)/32) + (((((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 61)/32) - ((argmin.s1.y.min + -62)/32))/8)*8))) in max(max(min((t106135/2), ((left_im.extent.1/64) + -1)), (max(min((left_im.extent.1/64), (max((t106135/2), ((min(max((downy$6.s0.y.max.s/128), 1), ((max(((downy$6.s0.y.min.s + -254)/128), 0) + ((((max((downy$6.s0.y.max.s/128), 1) - max(((downy$6.s0.y.min.s + -254)/128), 0)) + -1)/3)*3)) + 3))*2) + -1)) + 2)), 1) + -1)), min((max(downy$5.s0.y.min.s, 1) + ((((downy$5.s0.y.max - max(downy$5.s0.y.min.s, 1)) + 1)/2)*2)), downy$5.s0.y.max)))
  let downy$5.x.min_realized = (let t106139 = min((argmin.s1.x.min + 53), ((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0)) in (let t106140 = min(max((downy$6.s0.x.max.s/128), 1), (max((downy$6.s0.x.min.s/128), 1) + 2)) in (let t106141.s = min((left_im.extent.0 + 51), t106139) in (let t106142.s = min((left_im.extent.0 + 115), t106139) in min(min(max(((t106141.s + -115)/64), 0), min(max(((t106142.s + -179)/64), 0), min(max(((t106141.s + -115)/64), 0), min(max(((t106142.s + -179)/64), 0), (min(max(min((t106140*2), ((left_im.extent.0/64) + 5)), 6), (max(min((left_im.extent.0/64), ((t106140*2) + -6)), 1) + 5)) + -6))))), (downy$5.s0.x.min.s + -2))))))
  let downy$5.x.extent_realized.s.s = (let t106144 = min(((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 29)/16), (((argmin.s1.x.min + 82)/16) + (((((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 29)/16) - ((argmin.s1.x.min + -30)/16))/8)*8))) in (let t106147 = min(max((downy$6.s0.x.max.s/128), 1), ((max((downy$6.s0.x.min.s/128), 1) + (((max((downy$6.s0.x.max.s/128), 1) - max((downy$6.s0.x.min.s/128), 1))/3)*3)) + 2)) in max(max(max(min(((t106144 + 6)/4), ((left_im.extent.0/64) + -1)), (max(min((t106147*2), ((left_im.extent.0/64) + 1)), (max(min((left_im.extent.0/64), ((t106147*2) + 1)), 1) + 1)) + -2)), min(((t106144 + 2)/4), ((left_im.extent.0/64) + -1))), (downy$5.s0.x.max.s + -2))))
  let downy$5.stride.2 = (((downy$5.x.extent_realized.s.s - downy$5.x.min_realized) + 1)*((downy$5.y.extent_realized.s.s - downy$5.y.min_realized) + 1))
  allocate downy$5[float32 * ((downy$5.x.extent_realized.s.s - downy$5.x.min_realized) + 1) * ((downy$5.y.extent_realized.s.s - downy$5.y.min_realized) + 1) * max(slices, 4) * 2] if (uint1)0
  let downy$5.buffer = _halide_buffer_init(alloca(size_of_halide_buffer_t()), make_struct((halide_dimension_t *), downy$5.x.min_realized, ((downy$5.x.extent_realized.s.s - downy$5.x.min_realized) + 1), 1, 0, downy$5.y.min_realized, ((downy$5.y.extent_realized.s.s - downy$5.y.min_realized) + 1), ((downy$5.x.extent_realized.s.s - downy$5.x.min_realized) + 1), 0, (min(slices, 4) + -4), max(slices, 4), downy$5.stride.2, 0, 0, 2, (max(slices, 4)*downy$5.stride.2), 0), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 4, make_struct((halide_dimension_t *), downy$5.x.min_realized, ((downy$5.x.extent_realized.s.s - downy$5.x.min_realized) + 1), 1, 0, downy$5.y.min_realized, ((downy$5.y.extent_realized.s.s - downy$5.y.min_realized) + 1), ((downy$5.x.extent_realized.s.s - downy$5.x.min_realized) + 1), 0, (min(slices, 4) + -4), max(slices, 4), downy$5.stride.2, 0, 0, 2, (max(slices, 4)*downy$5.stride.2), 0), (uint64)0)
  register_destructor("halide_device_free_as_destructor", downy$5.buffer)
  let downy$5.s0.y.y_o.loop_extent.s = (downy$5.s0.y.max - max(downy$5.s0.y.min.s, 1))
  produce downy$5 {
    consume downy$4 {
      let halide_device_malloc_result$6 = halide_device_malloc(downy$5.buffer, halide_cuda_device_interface())
      assert((halide_device_malloc_result$6 == 0), halide_device_malloc_result$6)
      let t105237 = (4 - min(slices, 4))
      let t105229 = (2 - min(slices, 2))
      let t106490 = (left_im.extent.0/32)
      let t106477 = max(downy$5.s0.y.min.s, 1)
      let t106474 = ((slices + 1)/2)
      let t106475 = ((downy$5.s0.y.y_o.loop_extent.s + 3)/2)
      let t106489 = (max(slices, 4)*downy$5.stride.2)
      let t106487 = (max(slices, 2)*downy$4.stride.2)
      let t106478 = (-1 - downy$5.y.min_realized)
      let t106480 = (-3 - downy$4.y.min_realized)
      let t106481 = ((left_im.extent.1/32) + 2)
      let t106479 = ((downy$5.x.extent_realized.s.s - downy$5.x.min_realized) + 1)
      let t106484 = ((downy$5.s0.x.max.s - downy$5.s0.x.min.s) + 1)
      let t106482 = ((downy$4.x.extent_realized.s.s - downy$4.x.min_realized) + -3)
      let t106476 = (slices + -2)
      let t106483 = (downy$5.s0.x.min.s + -2)
      gpu_block<CUDA> (downy$5.s0._0._0_o.__block_id_y, 0, t106474) {
        gpu_block<CUDA> (downy$5.s0.y.y_o.__block_id_x, 0, t106475) {
          allocate __shared[uint8 * 96] in GPUShared
          gpu_thread<CUDA> (.__thread_id_y, 0, 2) {
            gpu_thread<CUDA> (.__thread_id_x, 0, 6) {
              let downy$5.s0._0._0_i.base = min((downy$5.s0._0._0_o.__block_id_y*2), t106476)
              let downy$5.s0.y.y_i.base.s = min(((downy$5.s0.y.y_o.__block_id_x*2) + t106477), downy$5.s0.y.max)
              let t105253 = ((int64(.__thread_id_y)*(int64)6) + int64(((.__thread_id_x*2) + 1)))
              let t105246 = (.__thread_id_x < 2)
              let t105251 = ((int64(((downy$5.s0._0._0_i.base + t105237) + .__thread_id_y))*int64(downy$5.stride.2)) + (int64(((downy$5.s0.y.y_i.base.s + t106478) + .__thread_id_x))*int64(t106479)))
              let t105242 = ((int64(((downy$5.s0._0._0_i.base + t105229) + .__thread_id_y))*int64(downy$4.stride.2)) + (int64((max(min(((downy$5.s0.y.y_i.base.s*2) + .__thread_id_x), t106481), 3) + t106480))*int64(t106482)))
              let t105245 = ((int64(.__thread_id_y)*(int64)6) + int64(.__thread_id_x))
              for (downy$5.s0.x, t106483, t106484) {
                produce downx$5 {
                  let t105256.s = min((downy$5.s0.x*2), (t106490 + -1))
                  let t105255.s = min((downy$5.s0.x*2), t106490)
                  let t105254.s = min(((downy$5.s0.x*2) + 3), t106490)
                  let t105257.s = min(((downy$5.s0.x*2) + 2), t106490)
                  let t106498 = (t105242 + int64((max(t105256.s, 0) - downy$4.x.min_realized)))
                  let t106499 = (t105242 + int64(((max(t105257.s, 1) - downy$4.x.min_realized) + -1)))
                  let t106497 = (t105242 + int64(((max(t105255.s, 1) - downy$4.x.min_realized) + -1)))
                  let t106496 = (t105242 + int64(((max(t105254.s, 1) - downy$4.x.min_realized) + -1)))
                  for (downx$5.s0._1, 0, 2) {
                    __shared[((int64(downx$5.s0._1)*(int64)12) + t105245)] = (let t106153 = (int64(downx$5.s0._1)*int64(t106487)) in ((downy$4[(t106153 + t106496)] + (downy$4[(t106153 + t106497)] + ((downy$4[(t106153 + t106498)] + downy$4[(t106153 + t106499)])*3.000000f)))*0.125000f))
                  }
                }
                gpu_thread_barrier()
                consume downx$5 {
                  if (t105246) {
                    let t106503 = (t105251 + int64((downy$5.s0.x - downy$5.x.min_realized)))
                    for (downy$5.s0._1, 0, 2) {
                      downy$5[((int64(downy$5.s0._1)*int64(t106489)) + t106503)] = ((__shared[(((int64(downy$5.s0._1)*(int64)12) + t105253) + (int64)2)] + (__shared[(((int64(downy$5.s0._1)*(int64)12) + t105253) + (int64)-1)] + ((__shared[((int64(downy$5.s0._1)*(int64)12) + t105253)] + __shared[(((int64(downy$5.s0._1)*(int64)12) + t105253) + (int64)1)])*3.000000f)))*0.125000f)
                    }
                  }
                }
                gpu_thread_barrier()
              }
            }
          }
          free __shared
        }
      }
      _halide_buffer_set_device_dirty(downy$5.buffer, (uint1)1)
    }
  }
  let downy$6.y.min_realized = min(max(((min(min((argmin.s1.y.min + 101), ((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1)), (left_im.extent.1 + 227)) + -355)/128), 0), min(max(((downy$6.s0.y.min.s + -254)/128), 0), (max((downy$6.s0.y.max.s/128), 1) + -3)))
  let downy$6.y.extent_realized.s.s = max(min(((min(((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 61)/32), (((argmin.s1.y.min + 162)/32) + (((((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 61)/32) - ((argmin.s1.y.min + -62)/32))/8)*8))) + 6)/4), ((left_im.extent.1/128) + -1)), (min(max((downy$6.s0.y.max.s/128), 1), ((max(((downy$6.s0.y.min.s + -254)/128), 0) + ((((max((downy$6.s0.y.max.s/128), 1) - max(((downy$6.s0.y.min.s + -254)/128), 0)) + -1)/3)*3)) + 3)) + -1))
  let downy$6.x.min_realized = min(max(((min(min((argmin.s1.x.min + 53), ((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0)), (left_im.extent.0 + 179)) + -307)/128), 0), (min(max((downy$6.s0.x.max.s/128), 1), (max((downy$6.s0.x.min.s/128), 1) + 2)) + -3))
  let downy$6.x.extent_realized.s.s = max(min(((min(((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 29)/16), (((argmin.s1.x.min + 82)/16) + (((((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 29)/16) - ((argmin.s1.x.min + -30)/16))/8)*8))) + 14)/8), ((left_im.extent.0/128) + -1)), (min(max((downy$6.s0.x.max.s/128), 1), ((max((downy$6.s0.x.min.s/128), 1) + (((max((downy$6.s0.x.max.s/128), 1) - max((downy$6.s0.x.min.s/128), 1))/3)*3)) + 2)) + -1))
  let downy$6.stride.2 = (((max(downy$6.x.extent_realized.s.s, 0) - downy$6.x.min_realized) + 1)*((max(downy$6.y.extent_realized.s.s, 0) - downy$6.y.min_realized) + 1))
  allocate downy$6[float32 * ((max(downy$6.x.extent_realized.s.s, 0) - downy$6.x.min_realized) + 1) * ((max(downy$6.y.extent_realized.s.s, 0) - downy$6.y.min_realized) + 1) * max(slices, 4) * 2] if (uint1)0
  let downy$6.buffer = _halide_buffer_init(alloca(size_of_halide_buffer_t()), make_struct((halide_dimension_t *), downy$6.x.min_realized, ((max(downy$6.x.extent_realized.s.s, 0) - downy$6.x.min_realized) + 1), 1, 0, downy$6.y.min_realized, ((max(downy$6.y.extent_realized.s.s, 0) - downy$6.y.min_realized) + 1), ((max(downy$6.x.extent_realized.s.s, 0) - downy$6.x.min_realized) + 1), 0, (diff.z.min_realized.s + -4), max(slices, 4), downy$6.stride.2, 0, 0, 2, (max(slices, 4)*downy$6.stride.2), 0), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 4, make_struct((halide_dimension_t *), downy$6.x.min_realized, ((max(downy$6.x.extent_realized.s.s, 0) - downy$6.x.min_realized) + 1), 1, 0, downy$6.y.min_realized, ((max(downy$6.y.extent_realized.s.s, 0) - downy$6.y.min_realized) + 1), ((max(downy$6.x.extent_realized.s.s, 0) - downy$6.x.min_realized) + 1), 0, (diff.z.min_realized.s + -4), max(slices, 4), downy$6.stride.2, 0, 0, 2, (max(slices, 4)*downy$6.stride.2), 0), (uint64)0)
  register_destructor("halide_device_free_as_destructor", downy$6.buffer)
  let downy$6.s0.x.x_o.loop_extent.s = (max((downy$6.s0.x.max.s/128), 1) - max((downy$6.s0.x.min.s/128), 1))
  let downy$6.s0.y.y_o.loop_extent.s = (max((downy$6.s0.y.max.s/128), 1) - max(((downy$6.s0.y.min.s + -254)/128), 0))
  produce downy$6 {
    consume downy$5 {
      let halide_device_malloc_result$5 = halide_device_malloc(downy$6.buffer, halide_cuda_device_interface())
      assert((halide_device_malloc_result$5 == 0), halide_device_malloc_result$5)
      let t105271 = (4 - min(slices, 4))
      let t106528 = (left_im.extent.0/64)
      let t106529 = max(slices, 4)
      let t106508 = max(((downy$6.s0.y.min.s + -254)/128), 0)
      let t106510 = max((downy$6.s0.x.max.s/128), 1)
      let t106504 = ((slices + 3)/4)
      let t106505 = ((downy$6.s0.y.y_o.loop_extent.s + 2)/3)
      let t106513 = (left_im.extent.1/64)
      let t106527 = (downy$6.stride.2*t106529)
      let t106515 = (downy$5.stride.2*t106529)
      let t106524 = (4 - diff.z.min_realized.s)
      let t106512 = (-1 - downy$5.y.min_realized)
      let t106526 = (-3 - downy$6.x.min_realized)
      let t106516 = (-4 - downy$5.x.min_realized)
      let t106522 = (-5 - downy$5.x.min_realized)
      let t106520 = (-6 - downy$5.x.min_realized)
      let t106518 = (-7 - downy$5.x.min_realized)
      let t106509 = (max((downy$6.s0.y.max.s/128), 1) + -3)
      let t106511 = (max((downy$6.s0.x.min.s/128), 1) + 2)
      let t106519 = (t106528 + 6)
      let t106521 = (t106528 + 5)
      let t106523 = (t106528 + 4)
      let t106517 = (t106528 + 3)
      let t106506 = ((downy$6.s0.x.x_o.loop_extent.s/3) + 1)
      let t106525 = ((max(downy$6.x.extent_realized.s.s, 0) - downy$6.x.min_realized) + 1)
      let t106514 = ((downy$5.x.extent_realized.s.s - downy$5.x.min_realized) + 1)
      let t106507 = (slices + -4)
      gpu_block<CUDA> (downy$6.s0._0._0_o.__block_id_z, 0, t106504) {
        gpu_block<CUDA> (downy$6.s0.y.y_o.__block_id_y, 0, t106505) {
          gpu_block<CUDA> (downy$6.s0.x.x_o.__block_id_x, 0, t106506) {
            allocate __shared[uint8 * 768] in GPUShared
            gpu_thread<CUDA> (.__thread_id_z, 0, 4) {
              gpu_thread<CUDA> (.__thread_id_y, 0, 8) {
                gpu_thread<CUDA> (.__thread_id_x, 0, 3) {
                  let downy$6.s0._0._0_i.base = min((downy$6.s0._0._0_o.__block_id_z*4), t106507)
                  let downy$6.s0.y.y_i.base = min(((downy$6.s0.y.y_o.__block_id_y*3) + t106508), t106509)
                  let downy$6.s0.x.x_i.base.s = min(((downy$6.s0.x.x_o.__block_id_x*3) + t106511), t106510)
                  produce downx$6 {
                    let t105292 = ((((int64(.__thread_id_z)*(int64)8) + int64(.__thread_id_y))*(int64)3) + int64(.__thread_id_x))
                    let t105290 = ((int64(((downy$6.s0._0._0_i.base + t105271) + .__thread_id_z))*int64(downy$5.stride.2)) + (int64((max(min(((downy$6.s0.y.y_i.base*2) + .__thread_id_y), t106513), 1) + t106512))*int64(t106514)))
                    let t106530 = (.__thread_id_x + downy$6.s0.x.x_i.base.s)
                    for (downx$6.s0._1, 0, 2) {
                      __shared[((int64(downx$6.s0._1)*(int64)96) + t105292)] = (let t106164 = (int64(downx$6.s0._1)*int64(t106515)) in ((downy$5[((t105290 + int64((max(min((t106530*2), t106517), 4) + t106516))) + t106164)] + (downy$5[((t105290 + int64((max(min((t106530*2), t106519), 7) + t106518))) + t106164)] + ((downy$5[((t105290 + int64((max(min((t106530*2), t106521), 6) + t106520))) + t106164)] + downy$5[((t105290 + int64((max(min((t106530*2), t106523), 5) + t106522))) + t106164)])*3.000000f)))*0.125000f))
                    }
                  }
                  gpu_thread_barrier()
                  consume downx$6 {
                    if ((.__thread_id_y < 3)) {
                      let t105298 = ((((int64(.__thread_id_z)*(int64)8) + int64(((.__thread_id_y*2) + 1)))*(int64)3) + int64(.__thread_id_x))
                      let t105297 = (((int64(((downy$6.s0._0._0_i.base + t106524) + .__thread_id_z))*int64(downy$6.stride.2)) + (int64(((downy$6.s0.y.y_i.base - downy$6.y.min_realized) + .__thread_id_y))*int64(t106525))) + int64(((downy$6.s0.x.x_i.base.s + t106526) + .__thread_id_x)))
                      for (downy$6.s0._1, 0, 2) {
                        downy$6[((int64(downy$6.s0._1)*int64(t106527)) + t105297)] = ((__shared[(((int64(downy$6.s0._1)*(int64)96) + t105298) + (int64)6)] + (__shared[(((int64(downy$6.s0._1)*(int64)96) + t105298) + (int64)-3)] + ((__shared[((int64(downy$6.s0._1)*(int64)96) + t105298)] + __shared[(((int64(downy$6.s0._1)*(int64)96) + t105298) + (int64)3)])*3.000000f)))*0.125000f)
                      }
                    }
                  }
                }
              }
            }
            free __shared
          }
        }
      }
      _halide_buffer_set_device_dirty(downy$6.buffer, (uint1)1)
    }
  }
  let upx$2.y.min_realized.s = min(min((argmin.s1.y.min + 101), ((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1)), (min((argmin.s1.y.min + 49), ((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1)) + 52))
  let upx$2.y.extent_realized.s = (max(min(((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 61)/32), (((argmin.s1.y.min + 162)/32) + (((((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 61)/32) - ((argmin.s1.y.min + -62)/32))/8)*8))), ((min(((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 5)/4), (((argmin.s1.y.min + 54)/4) + (((((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 5)/4) - ((argmin.s1.y.min + -6)/4))/16)*16))) + 14)/8)) - ((upx$2.y.min_realized.s + -163)/32))
  let upx$2.x.min_realized.s = min(min((argmin.s1.x.min + 53), ((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0)), (min((argmin.s1.x.min + 49), ((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0)) + 4))
  let upx$2.x.extent_realized.s = (max(min(((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 29)/16), (((argmin.s1.x.min + 82)/16) + (((((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 29)/16) - ((argmin.s1.x.min + -30)/16))/8)*8))), ((min(((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 5)/4), (((argmin.s1.x.min + 54)/4) + (((((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 5)/4) - ((argmin.s1.x.min + -6)/4))/16)*16))) + 6)/4)) - ((upx$2.x.min_realized.s + -83)/16))
  let upx$2.stride.2 = ((upx$2.x.extent_realized.s + 1)*(upx$2.y.extent_realized.s + 1))
  allocate upx$2[float32 * (upx$2.x.extent_realized.s + 1) * (upx$2.y.extent_realized.s + 1) * max(slices, 2) * 2] if (uint1)0
  let upx$2.buffer = _halide_buffer_init(alloca(size_of_halide_buffer_t()), make_struct((halide_dimension_t *), ((upx$2.x.min_realized.s + -83)/16), (upx$2.x.extent_realized.s + 1), 1, 0, ((upx$2.y.min_realized.s + -163)/32), (upx$2.y.extent_realized.s + 1), (upx$2.x.extent_realized.s + 1), 0, (min(slices, 2) + -2), max(slices, 2), upx$2.stride.2, 0, 0, 2, (max(slices, 2)*upx$2.stride.2), 0), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 4, make_struct((halide_dimension_t *), ((upx$2.x.min_realized.s + -83)/16), (upx$2.x.extent_realized.s + 1), 1, 0, ((upx$2.y.min_realized.s + -163)/32), (upx$2.y.extent_realized.s + 1), (upx$2.x.extent_realized.s + 1), 0, (min(slices, 2) + -2), max(slices, 2), upx$2.stride.2, 0, 0, 2, (max(slices, 2)*upx$2.stride.2), 0), (uint64)0)
  register_destructor("halide_device_free_as_destructor", upx$2.buffer)
  let upx$2.s0.x.x_o.loop_extent.s = (((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 29)/16) - ((argmin.s1.x.min + -30)/16))
  let upx$2.s0.y.y_o.loop_extent.s = (((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 61)/32) - ((argmin.s1.y.min + -62)/32))
  produce upx$2 {
    consume downy$6 {
      consume downy$5 {
        consume downy$4 {
          let halide_device_malloc_result$4 = halide_device_malloc(upx$2.buffer, halide_cuda_device_interface())
          assert((halide_device_malloc_result$4 == 0), halide_device_malloc_result$4)
          allocate upx.shared_size[int32 * 1] in Stack
          upx.shared_size[0] = 0
          allocate cost_pyramid_pull[5].shared_size[int32 * 1] in Stack
          cost_pyramid_pull[5].shared_size[0] = 0
          let t106536 = ((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + -163)/32)
          let t106539 = ((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + -83)/16)
          let t106534 = ((slices + 1)/2)
          let t106537 = ((argmin.s1.y.min + -62)/32)
          let t106540 = ((argmin.s1.x.min + -30)/16)
          let t106535 = ((upx$2.s0.y.y_o.loop_extent.s/8) + 1)
          let t106538 = ((upx$2.s0.x.x_o.loop_extent.s/8) + 1)
          for (t104148, 0, t106534) {
            for (t104147, 0, t106535) {
              let upx$2.s0.y.y_i.base = min(((t104147*8) + t106537), t106536)
              let t106541 = ((((upx$2.s0.y.y_i.base + 2) % 4) + 23)/4)
              for (t104146, 0, t106538) {
                cost_pyramid_pull[5].shared_size[0] = max(cost_pyramid_pull[5].shared_size[0], (((min(((t104146*8) + t106540), t106539) % 2)*32) + 192))
                upx.shared_size[0] = max(upx.shared_size[0], ((((((min(((t104146*8) + t106540), t106539) + 2) % 4) + 23)/4)*t106541)*4))
              }
            }
          }
          let upx.shared_size_var = upx.shared_size[0]
          let cost_pyramid_pull[5].shared_size_var = cost_pyramid_pull[5].shared_size[0]
          let t105327 = (4 - min(slices, 4))
          let t105336 = (2 - min(slices, 2))
          let t106575 = (left_im.extent.0/64)
          let t106576 = (left_im.extent.0/128)
          let t106577 = (left_im.extent.1/64)
          let t106578 = max(slices, 2)
          let t106579 = max(slices, 4)
          let t106547 = ((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + -163)/32)
          let t106549 = ((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + -83)/16)
          let t106571 = ((upx$2.y.min_realized.s + -163)/32)
          let t106573 = ((upx$2.x.min_realized.s + -83)/16)
          let t106542 = ((slices + 1)/2)
          let t106548 = ((argmin.s1.y.min + -62)/32)
          let t106550 = ((argmin.s1.x.min + -30)/16)
          let t106558 = (left_im.extent.0/32)
          let t106554 = (downy$6.stride.2*t106579)
          let t106565 = (downy$5.stride.2*t106579)
          let t106574 = (t106578*upx$2.stride.2)
          let t106570 = (downy$4.stride.2*t106578)
          let t106545 = ((cost_pyramid_pull[5].shared_size_var + upx.shared_size_var)*4)
          let t106551 = (4 - diff.z.min_realized.s)
          let t106564 = (-1 - downy$4.x.min_realized)
          let t106543 = ((upx$2.s0.y.y_o.loop_extent.s/8) + 1)
          let t106544 = ((upx$2.s0.x.x_o.loop_extent.s/8) + 1)
          let t106552 = ((left_im.extent.1/128) + -1)
          let t106562 = ((left_im.extent.1/32) + -1)
          let t106553 = ((max(downy$6.x.extent_realized.s.s, 0) - downy$6.x.min_realized) + 1)
          let t106560 = ((downy$5.x.extent_realized.s.s - downy$5.x.min_realized) + 1)
          let t106563 = ((downy$4.x.extent_realized.s.s - downy$4.x.min_realized) + -3)
          let t106572 = (upx$2.x.extent_realized.s + 1)
          let t106546 = (slices + -2)
          gpu_block<CUDA> (upx$2.s0._0._0_o.__block_id_z, 0, t106542) {
            gpu_block<CUDA> (upx$2.s0.y.y_o.__block_id_y, 0, t106543) {
              gpu_block<CUDA> (upx$2.s0.x.x_o.__block_id_x, 0, t106544) {
                allocate __shared[uint8 * t106545] in GPUShared
                gpu_thread<CUDA> (.__thread_id_z, 0, 2) {
                  gpu_thread<CUDA> (.__thread_id_y, 0, 8) {
                    gpu_thread<CUDA> (.__thread_id_x, 0, 8) {
                      let upx$2.s0._0._0_i.base = min((upx$2.s0._0._0_o.__block_id_z*2), t106546)
                      let upx$2.s0.y.y_i.base = min(((upx$2.s0.y.y_o.__block_id_y*8) + t106548), t106547)
                      let upx$2.s0.x.x_i.base = min(((upx$2.s0.x.x_o.__block_id_x*8) + t106550), t106549)
                      let upx.stride.2 = (((((upx$2.s0.x.x_i.base + 2) % 4) + 23)/4)*((((upx$2.s0.y.y_i.base + 2) % 4) + 23)/4))
                      let upx.s0.y.__thread_id_y.loop_extent.s = min(((upx$2.s0.y.y_o.__block_id_y*8) + t106548), t106547)
                      let upx.s0.x.__thread_id_x.loop_extent.s = min(((upx$2.s0.x.x_o.__block_id_x*8) + t106550), t106549)
                      produce upx {
                        if ((.__thread_id_y < ((((upx.s0.y.__thread_id_y.loop_extent.s + 2) % 4) + 23)/4))) {
                          if ((.__thread_id_x < ((((upx.s0.x.__thread_id_x.loop_extent.s + 2) % 4) + 23)/4))) {
                            let t105348 = ((int64(((t106551 + upx$2.s0._0._0_i.base) + .__thread_id_z))*int64(downy$6.stride.2)) + (int64((max(min((((upx$2.s0.y.y_i.base + -6)/4) + .__thread_id_y), t106552), 0) - downy$6.y.min_realized))*int64(t106553)))
                            let t105352 = (((int64(.__thread_id_z)*int64(upx.stride.2)) + (int64(.__thread_id_y)*int64(((((upx$2.s0.x.x_i.base + 2) % 4) + 23)/4)))) + int64(.__thread_id_x))
                            let t106583 = (upx.stride.2*2)
                            let t106580 = (((upx$2.s0.x.x_i.base + -6)/4) + .__thread_id_x)
                            for (upx.s0._1, 0, 2) {
                              __shared[((int64(upx.s0._1)*int64(t106583)) + t105352)] = (let t106173 = (int64(upx.s0._1)*int64(t106554)) in ((downy$6[((t105348 + int64(((max(min(((t106580/2) + ((t106580 % 2)*2)), t106576), 1) - downy$6.x.min_realized) + -1))) + t106173)] + (downy$6[((t105348 + int64((max(min((t106580/2), (t106576 + -1)), 0) - downy$6.x.min_realized))) + t106173)]*3.000000f))*0.250000f))
                            }
                          }
                        }
                      }
                      gpu_thread_barrier()
                      if ((.__thread_id_z < 1)) {
                        let cost_pyramid_pull[5].s0.x.__thread_id_x.loop_extent.s = min(((upx$2.s0.x.x_o.__block_id_x*8) + t106550), t106549)
                        produce cost_pyramid_pull[5] {
                          consume upx {
                            if ((.__thread_id_x < ((cost_pyramid_pull[5].s0.x.__thread_id_x.loop_extent.s % 2) + 6))) {
                              let t105366.s = min(((upx$2.s0.x.x_i.base/2) + .__thread_id_x), t106558)
                              let t106601 = (upx$2.s0.x.x_i.base % 2)
                              let t106602 = (.__thread_id_y + upx$2.s0.y.y_i.base)
                              let t106603 = (t106602/2)
                              let t106604 = ((upx$2.s0.x.x_i.base/2) + .__thread_id_x)
                              let t106605 = ((t106604 + -1)/2)
                              let t106606 = ((upx$2.s0.x.x_i.base + -6)/4)
                              let t106607 = ((upx$2.s0.x.x_i.base + 2) % 4)
                              let t106608 = int64(((t106607 + 23)/4))
                              let t106609 = ((upx$2.s0.y.y_i.base + -6)/4)
                              let t106610 = ((t106602/4) - t106609)
                              let t106588 = min((t106575 + -1), t106605)
                              let t106585 = (t106608*int64(t106610))
                              let t106586 = (t106608*int64((((t106603 % 2)*2) + t106610)))
                              let t106584 = (int64((max(min((t106577 + -1), t106603), 0) - downy$5.y.min_realized))*int64(t106560))
                              let t106587 = ((int64)-1 - t106608)
                              let t106589 = (t106605 - t106606)
                              let t106597 = (-1 - downy$5.y.min_realized)
                              let t106591 = ((int64((max(min(t106562, t106602), 0) - downy$4.y.min_realized))*int64(t106563)) + int64((max(t105366.s, 1) + t106564)))
                              let t106592 = ((((t106604 + 1) % 2)*2) + t106605)
                              let t106593 = (((t106602 % 2)*2) + t106603)
                              let t106600 = ((t106601*16) + 96)
                              for (cost_pyramid_pull[5].s0.z, upx$2.s0._0._0_i.base, 2) {
                                let t105372 = (int64((cost_pyramid_pull[5].s0.z - upx$2.s0._0._0_i.base))*int64(upx.stride.2))
                                let t105377 = (int64((cost_pyramid_pull[5].s0.z + t105327))*int64(downy$5.stride.2))
                                let t105384 = ((int64((cost_pyramid_pull[5].s0.z - upx$2.s0._0._0_i.base))*int64(((t106601*8) + 48))) + (((int64(.__thread_id_y)*int64((t106601 + 6))) + int64(upx.shared_size_var)) + int64(.__thread_id_x)))
                                let t105383 = ((int64((cost_pyramid_pull[5].s0.z + t105336))*int64(downy$4.stride.2)) + t106591)
                                let t106622 = int64(t106589)
                                let t106623 = int64(((t106607 + 23)/4))
                                let t106613 = (t106623*int64((((t106593 + -1)/2) - t106609)))
                                let t106614 = (int64((max(min(t106577, t106593), 1) + t106597))*int64(t106560))
                                let t106612 = (t106623*int64(((((t106593 + 1) % 2)*2) + (((t106593 + -3)/2) - t106609))))
                                let t106611 = (upx.stride.2*2)
                                let t106617 = (max(t106588, 0) - downy$5.x.min_realized)
                                let t106615 = (t106592 - t106606)
                                let t106620 = (((t106586 - t106623) + t106622) + t105372)
                                let t106621 = ((t106585 + t106622) + t105372)
                                let t106618 = (t106586 + t106587)
                                let t106619 = (t106585 + (int64)-1)
                                let t106616 = ((max(min(t106575, t106592), 1) - downy$5.x.min_realized) + -1)
                                for (cost_pyramid_pull[5].s0.c, 0, 2) {
                                  __shared[((int64(cost_pyramid_pull[5].s0.c)*int64(t106600)) + t105384)] = (let t106178 = (int64(cost_pyramid_pull[5].s0.c)*int64(t106611)) in (let t106179 = (int64(cost_pyramid_pull[5].s0.c)*int64(t106565)) in lerp(((((lerp(((__shared[(((t106618 + int64(t106615)) + t105372) + t106178)] + (__shared[(((t106619 + int64(t106615)) + t105372) + t106178)]*3.000000f))*0.250000f), downy$5[(((t106584 + int64(t106616)) + t105377) + t106179)], 0.500000f) + (lerp(((__shared[(t106178 + t106620)] + (__shared[(t106178 + t106621)]*3.000000f))*0.250000f), downy$5[(((t106584 + int64(t106617)) + t105377) + t106179)], 0.500000f)*3.000000f))*3.000000f) + (lerp(((__shared[((((t106612 + int64(t106615)) + t105372) + t106178) + (int64)-1)] + (__shared[((((t106613 + int64(t106615)) + t105372) + t106178) + (int64)-1)]*3.000000f))*0.250000f), downy$5[(((t106614 + int64(t106616)) + t105377) + t106179)], 0.500000f) + (lerp(((__shared[(((t106612 + int64(t106589)) + t105372) + t106178)] + (__shared[(((t106613 + int64(t106589)) + t105372) + t106178)]*3.000000f))*0.250000f), downy$5[(((t106614 + int64(t106617)) + t105377) + t106179)], 0.500000f)*3.000000f)))*0.062500f), downy$4[((int64(cost_pyramid_pull[5].s0.c)*int64(t106570)) + t105383)], 0.500000f)))
                                }
                              }
                            }
                          }
                        }
                      }
                      gpu_thread_barrier()
                      consume cost_pyramid_pull[5] {
                        let t105394 = (1 - (upx$2.s0.x.x_i.base/2))
                        let t105395 = (((int64(((t105336 + upx$2.s0._0._0_i.base) + .__thread_id_z))*int64(upx$2.stride.2)) + (int64(((upx$2.s0.y.y_i.base - t106571) + .__thread_id_y))*int64(t106572))) + int64(((upx$2.s0.x.x_i.base - t106573) + .__thread_id_x)))
                        let t106624 = (upx$2.s0.x.x_i.base % 2)
                        let t106625 = (.__thread_id_x + upx$2.s0.x.x_i.base)
                        for (upx$2.s0._1, 0, 2) {
                          upx$2[((int64(upx$2.s0._1)*int64(t106574)) + t105395)] = (let t106188 = (int64(upx$2.s0._1)*int64(((t106624*16) + 96))) in (let t106189 = ((int64(.__thread_id_y)*int64((t106624 + 6))) + ((int64(.__thread_id_z)*int64(((t106624*8) + 48))) + int64(upx.shared_size_var))) in ((__shared[(((t106189 + int64(((t106625/2) + (((t106625 % 2)*2) + t105394)))) + t106188) + (int64)-1)] + (__shared[((t106189 + int64(((t106625/2) + t105394))) + t106188)]*3.000000f))*0.250000f)))
                        }
                      }
                    }
                  }
                }
                free __shared
              }
            }
          }
          free upx.shared_size
          free cost_pyramid_pull[5].shared_size
          let halide_device_free_result$7 = halide_device_free(downy$4.buffer)
          assert((halide_device_free_result$7 == 0), halide_device_free_result$7)
          free downy$4
          let halide_device_free_result$6 = halide_device_free(downy$5.buffer)
          assert((halide_device_free_result$6 == 0), halide_device_free_result$6)
          free downy$5
          let halide_device_free_result$5 = halide_device_free(downy$6.buffer)
          assert((halide_device_free_result$5 == 0), halide_device_free_result$5)
          free downy$6
          _halide_buffer_set_device_dirty(upx$2.buffer, (uint1)1)
        }
      }
    }
  }
  let cost_pyramid_pull[2].y.min_realized.s = min((min((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + -16), argmin.s1.y.min) + 49), ((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1))
  let cost_pyramid_pull[2].y.extent_realized.s = (max(min(((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 5)/4), (((argmin.s1.y.min + 54)/4) + (((((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 5)/4) - ((argmin.s1.y.min + -6)/4))/16)*16))), ((min(((((((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) - argmin.s1.y.min) + -1)/16)*16) + argmin.s1.y.min) + 16), ((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1)) + 5)/4)) - ((cost_pyramid_pull[2].y.min_realized.s + -55)/4))
  let cost_pyramid_pull[2].x.min_realized.s = min((min((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + -16), argmin.s1.x.min) + 49), ((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0))
  let cost_pyramid_pull[2].x.extent_realized.s = (max(min(((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 5)/4), (((argmin.s1.x.min + 54)/4) + (((((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 5)/4) - ((argmin.s1.x.min + -6)/4))/16)*16))), ((min(((((((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) - argmin.s1.x.min) + -1)/16)*16) + argmin.s1.x.min) + 16), ((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0)) + 5)/4)) - ((cost_pyramid_pull[2].x.min_realized.s + -55)/4))
  let cost_pyramid_pull[2].stride.2 = ((cost_pyramid_pull[2].x.extent_realized.s + 1)*(cost_pyramid_pull[2].y.extent_realized.s + 1))
  allocate cost_pyramid_pull[2][float32 * (cost_pyramid_pull[2].x.extent_realized.s + 1) * (cost_pyramid_pull[2].y.extent_realized.s + 1) * max(slices, 2) * 2] if (uint1)0
  let cost_pyramid_pull[2].buffer = _halide_buffer_init(alloca(size_of_halide_buffer_t()), make_struct((halide_dimension_t *), ((cost_pyramid_pull[2].x.min_realized.s + -55)/4), (cost_pyramid_pull[2].x.extent_realized.s + 1), 1, 0, ((cost_pyramid_pull[2].y.min_realized.s + -55)/4), (cost_pyramid_pull[2].y.extent_realized.s + 1), (cost_pyramid_pull[2].x.extent_realized.s + 1), 0, (min(slices, 2) + -2), max(slices, 2), cost_pyramid_pull[2].stride.2, 0, 0, 2, (max(slices, 2)*cost_pyramid_pull[2].stride.2), 0), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 4, make_struct((halide_dimension_t *), ((cost_pyramid_pull[2].x.min_realized.s + -55)/4), (cost_pyramid_pull[2].x.extent_realized.s + 1), 1, 0, ((cost_pyramid_pull[2].y.min_realized.s + -55)/4), (cost_pyramid_pull[2].y.extent_realized.s + 1), (cost_pyramid_pull[2].x.extent_realized.s + 1), 0, (min(slices, 2) + -2), max(slices, 2), cost_pyramid_pull[2].stride.2, 0, 0, 2, (max(slices, 2)*cost_pyramid_pull[2].stride.2), 0), (uint64)0)
  register_destructor("halide_device_free_as_destructor", cost_pyramid_pull[2].buffer)
  let cost_pyramid_pull[2].s0.x.x_o.loop_extent.s = (((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + 5)/4) - ((argmin.s1.x.min + -6)/4))
  let cost_pyramid_pull[2].s0.y.y_o.loop_extent.s = (((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + 5)/4) - ((argmin.s1.y.min + -6)/4))
  produce cost_pyramid_pull[2] {
    consume upx$2 {
      consume downy$3 {
        consume downy$2 {
          consume downy$1 {
            let halide_device_malloc_result$3 = halide_device_malloc(cost_pyramid_pull[2].buffer, halide_cuda_device_interface())
            assert((halide_device_malloc_result$3 == 0), halide_device_malloc_result$3)
            allocate cost_pyramid_pull[4].shared_size[int32 * 1] in Stack
            cost_pyramid_pull[4].shared_size[0] = 0
            allocate upx$3.shared_size[int32 * 1] in Stack
            upx$3.shared_size[0] = 0
            allocate cost_pyramid_pull[3].shared_size[int32 * 1] in Stack
            cost_pyramid_pull[3].shared_size[0] = 0
            allocate upx$4.shared_size[int32 * 1] in Stack
            upx$4.shared_size[0] = 0
            let t106628 = ((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + -55)/4)
            let t106631 = ((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + -55)/4)
            let t106626 = ((slices + 1)/2)
            let t106629 = ((argmin.s1.y.min + -6)/4)
            let t106632 = ((argmin.s1.x.min + -6)/4)
            let t106627 = ((cost_pyramid_pull[2].s0.y.y_o.loop_extent.s/16) + 1)
            let t106630 = ((cost_pyramid_pull[2].s0.x.x_o.loop_extent.s/16) + 1)
            for (t104157, 0, t106626) {
              for (t104156, 0, t106627) {
                let cost_pyramid_pull[2].s0.y.y_i.base = min(((t104156*16) + t106629), t106628)
                let t106634 = ((((cost_pyramid_pull[2].s0.y.y_i.base + 2) % 4) + 31)/4)
                let t106633 = (cost_pyramid_pull[2].s0.y.y_i.base % 2)
                for (t104155, 0, t106630) {
                  cost_pyramid_pull[3].shared_size[0] = max(cost_pyramid_pull[3].shared_size[0], ((((min(((t104155*16) + t106632), t106631) % 2)*((t106633*4) + 40)) + (t106633*40)) + 400))
                  upx$3.shared_size[0] = max(upx$3.shared_size[0], ((((min(((t104155*16) + t106632), t106631) % 2) + 10)*t106634)*4))
                  cost_pyramid_pull[4].shared_size[0] = max(cost_pyramid_pull[4].shared_size[0], ((((((min(((t104155*16) + t106632), t106631) + 2) % 4) + 31)/4)*t106634)*4))
                }
                upx$4.shared_size[0] = max(upx$4.shared_size[0], (((min(((t104156*16) + t106629), t106628) % 2)*64) + 640))
              }
            }
            let cost_pyramid_pull[4].shared_size_var = cost_pyramid_pull[4].shared_size[0]
            let upx$3.shared_size_var = upx$3.shared_size[0]
            let cost_pyramid_pull[3].shared_size_var = cost_pyramid_pull[3].shared_size[0]
            let upx$4.shared_size_var = upx$4.shared_size[0]
            let t104188 = max(cost_pyramid_pull[3].shared_size_var, cost_pyramid_pull[4].shared_size_var)
            let t104189 = max(upx$3.shared_size_var, upx$4.shared_size_var)
            let t105414 = (2 - min(slices, 2))
            let t106665 = max(slices, 2)
            let t106640 = ((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + -55)/4)
            let t106642 = ((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + -55)/4)
            let t106647 = ((upx$2.y.min_realized.s + -163)/32)
            let t106645 = ((upx$2.x.min_realized.s + -83)/16)
            let t106635 = ((slices + 1)/2)
            let t106658 = ((cost_pyramid_pull[2].y.min_realized.s + -55)/4)
            let t106660 = ((cost_pyramid_pull[2].x.min_realized.s + -55)/4)
            let t106641 = ((argmin.s1.y.min + -6)/4)
            let t106643 = ((argmin.s1.x.min + -6)/4)
            let t106652 = (left_im.extent.1/8)
            let t106655 = (left_im.extent.0/8)
            let t106638 = ((t104188 + t104189)*4)
            let t106651 = (-1 - downy$2.y.min_realized)
            let t106654 = (-1 - downy$2.x.min_realized)
            let t106649 = ((left_im.extent.1/16) + -1)
            let t106661 = ((left_im.extent.1/4) + -1)
            let t106644 = ((left_im.extent.0/16) + -1)
            let t106657 = ((left_im.extent.0/4) + -1)
            let t106636 = ((cost_pyramid_pull[2].s0.y.y_o.loop_extent.s/16) + 1)
            let t106637 = ((cost_pyramid_pull[2].s0.x.x_o.loop_extent.s/16) + 1)
            let t106650 = ((downy$3.x.extent_realized.s.s - downy$3.x.min_realized) + 1)
            let t106653 = ((downy$2.x.extent_realized.s.s - downy$2.x.min_realized) + -15)
            let t106662 = ((downy$1.x.extent_realized.s.s - downy$1.x.min_realized) + 1)
            let t106648 = (upx$2.x.extent_realized.s + 1)
            let t106639 = (slices + -2)
            let t106659 = (cost_pyramid_pull[2].x.extent_realized.s + 1)
            gpu_block<CUDA> (cost_pyramid_pull[2].s0.z.z_o.__block_id_z, 0, t106635) {
              gpu_block<CUDA> (cost_pyramid_pull[2].s0.y.y_o.__block_id_y, 0, t106636) {
                gpu_block<CUDA> (cost_pyramid_pull[2].s0.x.x_o.__block_id_x, 0, t106637) {
                  allocate __shared[uint8 * t106638] in GPUShared
                  gpu_thread<CUDA> (.__thread_id_z, 0, 2) {
                    gpu_thread<CUDA> (.__thread_id_y, 0, 16) {
                      gpu_thread<CUDA> (.__thread_id_x, 0, 16) {
                        let cost_pyramid_pull[2].s0.z.z_i.base = min((cost_pyramid_pull[2].s0.z.z_o.__block_id_z*2), t106639)
                        let cost_pyramid_pull[2].s0.y.y_i.base = min(((cost_pyramid_pull[2].s0.y.y_o.__block_id_y*16) + t106641), t106640)
                        let cost_pyramid_pull[2].s0.x.x_i.base = min(((cost_pyramid_pull[2].s0.x.x_o.__block_id_x*16) + t106643), t106642)
                        let cost_pyramid_pull[4].stride.2 = (((((cost_pyramid_pull[2].s0.x.x_i.base + 2) % 4) + 31)/4)*((((cost_pyramid_pull[2].s0.y.y_i.base + 2) % 4) + 31)/4))
                        let cost_pyramid_pull[4].s0.y.__thread_id_y.loop_extent.s = min(((cost_pyramid_pull[2].s0.y.y_o.__block_id_y*16) + t106641), t106640)
                        let cost_pyramid_pull[4].s0.x.__thread_id_x.loop_extent.s = min(((cost_pyramid_pull[2].s0.x.x_o.__block_id_x*16) + t106643), t106642)
                        produce cost_pyramid_pull[4] {
                          if ((.__thread_id_y < ((((cost_pyramid_pull[4].s0.y.__thread_id_y.loop_extent.s + 2) % 4) + 31)/4))) {
                            if ((.__thread_id_x < ((((cost_pyramid_pull[4].s0.x.__thread_id_x.loop_extent.s + 2) % 4) + 31)/4))) {
                              let t105442.s = min((((cost_pyramid_pull[2].s0.x.x_i.base + -6)/4) + .__thread_id_x), t106644)
                              let t105444 = (((int64(.__thread_id_z)*int64(cost_pyramid_pull[4].stride.2)) + (int64(.__thread_id_y)*int64(((((cost_pyramid_pull[2].s0.x.x_i.base + 2) % 4) + 31)/4)))) + int64(.__thread_id_x))
                              let t105440.s = (((cost_pyramid_pull[2].s0.x.x_i.base + -6)/4) - t106645)
                              let t106667 = (t106665*upx$2.stride.2)
                              let t106671 = (downy$3.stride.2*t106665)
                              let t106672 = (cost_pyramid_pull[4].stride.2*2)
                              let t106670 = (max(t105442.s, 0) - downy$3.x.min_realized)
                              let t106668 = (((cost_pyramid_pull[2].s0.y.y_i.base + -6)/4) + .__thread_id_y)
                              let t106666 = ((cost_pyramid_pull[2].s0.z.z_i.base + t105414) + .__thread_id_z)
                              let t106669 = (.__thread_id_x + t105440.s)
                              for (cost_pyramid_pull[4].s0.c, 0, 2) {
                                __shared[((int64(cost_pyramid_pull[4].s0.c)*int64(t106672)) + t105444)] = (let t106200 = (int64(t106666)*int64(upx$2.stride.2)) in (let t106202 = (int64(cost_pyramid_pull[4].s0.c)*int64(t106667)) in lerp(((upx$2[((((int64((((t106668 % 2)*2) + ((t106668/2) - t106647)))*int64(t106648)) + (t106200 - int64(t106648))) + int64(t106669)) + t106202)] + (upx$2[((((int64(((t106668/2) - t106647))*int64(t106648)) + t106200) + int64(t106669)) + t106202)]*3.000000f))*0.250000f), downy$3[((int64(cost_pyramid_pull[4].s0.c)*int64(t106671)) + (((int64(t106666)*int64(downy$3.stride.2)) + (int64((max(min(t106649, t106668), 0) - downy$3.y.min_realized))*int64(t106650))) + int64(t106670)))], 0.500000f)))
                              }
                            }
                          }
                        }
                        gpu_thread_barrier()
                        let upx$3.stride.2 = (((((cost_pyramid_pull[2].s0.y.y_i.base + 2) % 4) + 31)/4)*((cost_pyramid_pull[2].s0.x.x_i.base % 2) + 10))
                        if ((.__thread_id_z < 1)) {
                          let upx$3.s0.y.__thread_id_y.loop_extent.s = min(((cost_pyramid_pull[2].s0.y.y_o.__block_id_y*16) + t106641), t106640)
                          let upx$3.s0.x.__thread_id_x.loop_extent.s = min(((cost_pyramid_pull[2].s0.x.x_o.__block_id_x*16) + t106643), t106642)
                          produce upx$3 {
                            consume cost_pyramid_pull[4] {
                              if ((.__thread_id_y < ((((upx$3.s0.y.__thread_id_y.loop_extent.s + 2) % 4) + 31)/4))) {
                                if ((.__thread_id_x < ((upx$3.s0.x.__thread_id_x.loop_extent.s % 2) + 10))) {
                                  let t105447 = (int64(.__thread_id_y)*int64(((((cost_pyramid_pull[2].s0.x.x_i.base + 2) % 4) + 31)/4)))
                                  let t105448 = (((((cost_pyramid_pull[2].s0.x.x_i.base/2) + .__thread_id_x) + -1)/2) - ((cost_pyramid_pull[2].s0.x.x_i.base + -6)/4))
                                  let t105451 = (((int64(.__thread_id_y)*int64(((cost_pyramid_pull[2].s0.x.x_i.base % 2) + 10))) + int64(t104188)) + int64(.__thread_id_x))
                                  let t106674 = ((t105447 + int64(((((((cost_pyramid_pull[2].s0.x.x_i.base/2) + .__thread_id_x) + 1) % 2)*2) + t105448))) + (int64)-1)
                                  let t106675 = (t105447 + int64(t105448))
                                  for (upx$3.s0._0, cost_pyramid_pull[2].s0.z.z_i.base, 2) {
                                    let t105455 = (int64((upx$3.s0._0 - cost_pyramid_pull[2].s0.z.z_i.base))*int64(cost_pyramid_pull[4].stride.2))
                                    let t105459.s = (int64((upx$3.s0._0 - cost_pyramid_pull[2].s0.z.z_i.base))*int64(upx$3.stride.2))
                                    let t106681 = (upx$3.stride.2*2)
                                    let t106677 = (cost_pyramid_pull[4].stride.2*2)
                                    let t106679 = (t105455 + t106675)
                                    let t106678 = (t105455 + t106674)
                                    let t106680 = (t105451 + t105459.s)
                                    for (upx$3.s0._1, 0, 2) {
                                      __shared[((int64(upx$3.s0._1)*int64(t106681)) + t106680)] = (let t106206 = (int64(upx$3.s0._1)*int64(t106677)) in ((__shared[(t106206 + t106678)] + (__shared[(t106206 + t106679)]*3.000000f))*0.250000f))
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                        gpu_thread_barrier()
                        let cost_pyramid_pull[3].stride.2 = (((cost_pyramid_pull[2].s0.x.x_i.base % 2) + 10)*((cost_pyramid_pull[2].s0.y.y_i.base % 2) + 10))
                        let cost_pyramid_pull[3].s0.y.__thread_id_y.loop_extent.s = min(((cost_pyramid_pull[2].s0.y.y_o.__block_id_y*16) + t106641), t106640)
                        let cost_pyramid_pull[3].s0.x.__thread_id_x.loop_extent.s = min(((cost_pyramid_pull[2].s0.x.x_o.__block_id_x*16) + t106643), t106642)
                        produce cost_pyramid_pull[3] {
                          consume upx$3 {
                            if ((.__thread_id_y < ((cost_pyramid_pull[3].s0.y.__thread_id_y.loop_extent.s % 2) + 10))) {
                              if ((.__thread_id_x < ((cost_pyramid_pull[3].s0.x.__thread_id_x.loop_extent.s % 2) + 10))) {
                                let t105463 = (int64(.__thread_id_z)*int64(upx$3.stride.2))
                                let t105464 = (((((cost_pyramid_pull[2].s0.y.y_i.base/2) + .__thread_id_y) + -1)/2) - ((cost_pyramid_pull[2].s0.y.y_i.base + -6)/4))
                                let t105467 = (((int64(((cost_pyramid_pull[2].s0.z.z_i.base + t105414) + .__thread_id_z))*int64(downy$2.stride.2)) + (int64((max(min(((cost_pyramid_pull[2].s0.y.y_i.base/2) + .__thread_id_y), t106652), 1) + t106651))*int64(t106653))) + int64((max(min(((cost_pyramid_pull[2].s0.x.x_i.base/2) + .__thread_id_x), t106655), 1) + t106654)))
                                let t105469 = (((int64(.__thread_id_z)*int64(cost_pyramid_pull[3].stride.2)) + (int64(.__thread_id_y)*int64(((cost_pyramid_pull[2].s0.x.x_i.base % 2) + 10)))) + int64(.__thread_id_x))
                                let t106682 = (upx$3.stride.2*2)
                                let t106686 = (downy$2.stride.2*t106665)
                                let t106687 = (cost_pyramid_pull[3].stride.2*2)
                                let t106683 = (cost_pyramid_pull[2].s0.x.x_i.base % 2)
                                let t106685 = (t105463 + int64(t104188))
                                let t106684 = ((((((cost_pyramid_pull[2].s0.y.y_i.base/2) + .__thread_id_y) + 1) % 2)*2) + t105464)
                                for (cost_pyramid_pull[3].s0.c, 0, 2) {
                                  __shared[((int64(cost_pyramid_pull[3].s0.c)*int64(t106687)) + t105469)] = (let t106207 = (int64(cost_pyramid_pull[3].s0.c)*int64(t106682)) in lerp(((__shared[((((int64(t106684)*int64((t106683 + 10))) + ((int64(t104188) - int64((t106683 + 10))) + t105463)) + int64(.__thread_id_x)) + t106207)] + (__shared[((((int64(t105464)*int64((t106683 + 10))) + t106685) + int64(.__thread_id_x)) + t106207)]*3.000000f))*0.250000f), downy$2[((int64(cost_pyramid_pull[3].s0.c)*int64(t106686)) + t105467)], 0.500000f))
                                }
                              }
                            }
                          }
                        }
                        gpu_thread_barrier()
                        if ((.__thread_id_z < 1)) {
                          let upx$4.s0.y.__thread_id_y.loop_extent.s = min(((cost_pyramid_pull[2].s0.y.y_o.__block_id_y*16) + t106641), t106640)
                          produce upx$4 {
                            consume cost_pyramid_pull[3] {
                              if ((.__thread_id_y < ((upx$4.s0.y.__thread_id_y.loop_extent.s % 2) + 10))) {
                                let t105477 = (1 - (cost_pyramid_pull[2].s0.x.x_i.base/2))
                                let t105479 = (((int64(.__thread_id_y)*(int64)16) + int64(t104188)) + int64(.__thread_id_x))
                                let t106694 = (cost_pyramid_pull[2].s0.y.y_i.base % 2)
                                let t106695 = (.__thread_id_x + cost_pyramid_pull[2].s0.x.x_i.base)
                                let t106696 = (cost_pyramid_pull[2].s0.x.x_i.base % 2)
                                let t106688 = (int64(.__thread_id_y)*int64((t106696 + 10)))
                                let t106692 = (((.__thread_id_x + t106696)/2) + 1)
                                let t106690 = ((t106695/2) + (((t106695 % 2)*2) + t105477))
                                let t106693 = ((t106694*32) + 320)
                                let t106689 = ((t106694*16) + 160)
                                for (upx$4.s0._0, cost_pyramid_pull[2].s0.z.z_i.base, 2) {
                                  let t105481 = (int64((upx$4.s0._0 - cost_pyramid_pull[2].s0.z.z_i.base))*int64(cost_pyramid_pull[3].stride.2))
                                  let t105485.s = (int64((upx$4.s0._0 - cost_pyramid_pull[2].s0.z.z_i.base))*int64(t106689))
                                  let t106697 = (cost_pyramid_pull[3].stride.2*2)
                                  let t106698 = (((t106688 + int64(t106690)) + t105481) + (int64)-1)
                                  let t106699 = ((t106688 + int64(t106692)) + t105481)
                                  let t106700 = (t105479 + t105485.s)
                                  for (upx$4.s0._1, 0, 2) {
                                    __shared[((int64(upx$4.s0._1)*int64(t106693)) + t106700)] = (let t106210 = (int64(upx$4.s0._1)*int64(t106697)) in ((__shared[(t106210 + t106698)] + (__shared[(t106210 + t106699)]*3.000000f))*0.250000f))
                                  }
                                }
                              }
                            }
                          }
                        }
                        gpu_thread_barrier()
                        consume upx$4 {
                          let t105491 = (int64(((cost_pyramid_pull[2].s0.z.z_i.base + t105414) + .__thread_id_z))*int64(downy$1.stride.2))
                          let t105492.s = min((.__thread_id_x + cost_pyramid_pull[2].s0.x.x_i.base), t106657)
                          let t105490 = (1 - (cost_pyramid_pull[2].s0.y.y_i.base/2))
                          let t105494 = (((int64(((cost_pyramid_pull[2].s0.z.z_i.base + t105414) + .__thread_id_z))*int64(cost_pyramid_pull[2].stride.2)) + (int64(((cost_pyramid_pull[2].s0.y.y_i.base - t106658) + .__thread_id_y))*int64(t106659))) + int64(((cost_pyramid_pull[2].s0.x.x_i.base - t106660) + .__thread_id_x)))
                          let t106704 = (downy$1.stride.2*t106665)
                          let t106705 = (cost_pyramid_pull[2].stride.2*t106665)
                          let t106701 = (cost_pyramid_pull[2].s0.y.y_i.base % 2)
                          let t106703 = (max(t105492.s, 0) - downy$1.x.min_realized)
                          let t106702 = (.__thread_id_y + cost_pyramid_pull[2].s0.y.y_i.base)
                          for (cost_pyramid_pull[2].s0.c, 0, 2) {
                            cost_pyramid_pull[2][((int64(cost_pyramid_pull[2].s0.c)*int64(t106705)) + t105494)] = (let t106212 = (int64(cost_pyramid_pull[2].s0.c)*int64(((t106701*32) + 320))) in (let t106213 = ((int64(.__thread_id_z)*int64(((t106701*16) + 160))) + int64(t104188)) in lerp(((__shared[(((((int64(((t106702/2) + (((t106702 % 2)*2) + t105490)))*(int64)16) + t106213) + int64(.__thread_id_x)) + t106212) + (int64)-16)] + (__shared[((((int64(((t106702/2) + t105490))*(int64)16) + t106213) + int64(.__thread_id_x)) + t106212)]*3.000000f))*0.250000f), downy$1[((int64(cost_pyramid_pull[2].s0.c)*int64(t106704)) + (((int64((max(min(t106661, t106702), 0) - downy$1.y.min_realized))*int64(t106662)) + t105491) + int64(t106703)))], 0.500000f)))
                          }
                        }
                      }
                    }
                  }
                  free __shared
                }
              }
            }
            free cost_pyramid_pull[4].shared_size
            free upx$3.shared_size
            free cost_pyramid_pull[3].shared_size
            free upx$4.shared_size
            let halide_device_free_result$10 = halide_device_free(downy$1.buffer)
            assert((halide_device_free_result$10 == 0), halide_device_free_result$10)
            free downy$1
            let halide_device_free_result$9 = halide_device_free(downy$2.buffer)
            assert((halide_device_free_result$9 == 0), halide_device_free_result$9)
            free downy$2
            let halide_device_free_result$8 = halide_device_free(downy$3.buffer)
            assert((halide_device_free_result$8 == 0), halide_device_free_result$8)
            free downy$3
            let halide_device_free_result$4 = halide_device_free(upx$2.buffer)
            assert((halide_device_free_result$4 == 0), halide_device_free_result$4)
            free upx$2
            _halide_buffer_set_device_dirty(cost_pyramid_pull[2].buffer, (uint1)1)
          }
        }
      }
    }
  }
  let filtered_cost.y.min_realized = min((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + -16), argmin.s1.y.min)
  let filtered_cost.y.extent_realized.s = max(min(((((((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) - argmin.s1.y.min) + -1)/16)*16) + argmin.s1.y.min) + 16), ((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1)), ((((((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) - argmin.s1.y.min) + -1)/8)*8) + argmin.s1.y.min) + 8))
  let filtered_cost.x.min_realized = min((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + -16), argmin.s1.x.min)
  allocate filtered_cost[float32 * (((((((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) - argmin.s1.x.min) + -1)/16)*16) + argmin.s1.x.min) - filtered_cost.x.min_realized) + 16) * (filtered_cost.y.extent_realized.s - filtered_cost.y.min_realized) * max(slices, 2)] if (uint1)0
  let filtered_cost.buffer = (let t106219 = ((filtered_cost.y.extent_realized.s - filtered_cost.y.min_realized)*(((((((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) - argmin.s1.x.min) + -1)/16)*16) + argmin.s1.x.min) - filtered_cost.x.min_realized) + 16)) in _halide_buffer_init(alloca(size_of_halide_buffer_t()), make_struct((halide_dimension_t *), filtered_cost.x.min_realized, (((((((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) - argmin.s1.x.min) + -1)/16)*16) + argmin.s1.x.min) - filtered_cost.x.min_realized) + 16), 1, 0, filtered_cost.y.min_realized, (filtered_cost.y.extent_realized.s - filtered_cost.y.min_realized), (((((((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) - argmin.s1.x.min) + -1)/16)*16) + argmin.s1.x.min) - filtered_cost.x.min_realized) + 16), 0, (min(slices, 2) + -2), max(slices, 2), t106219, 0), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 3, make_struct((halide_dimension_t *), filtered_cost.x.min_realized, (((((((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) - argmin.s1.x.min) + -1)/16)*16) + argmin.s1.x.min) - filtered_cost.x.min_realized) + 16), 1, 0, filtered_cost.y.min_realized, (filtered_cost.y.extent_realized.s - filtered_cost.y.min_realized), (((((((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) - argmin.s1.x.min) + -1)/16)*16) + argmin.s1.x.min) - filtered_cost.x.min_realized) + 16), 0, (min(slices, 2) + -2), max(slices, 2), t106219, 0), (uint64)0))
  register_destructor("halide_device_free_as_destructor", filtered_cost.buffer)
  produce filtered_cost {
    consume cost_pyramid_pull[2] {
      consume downy {
        consume cost_confidence {
          consume diff {
            let halide_device_malloc_result$2 = halide_device_malloc(filtered_cost.buffer, halide_cuda_device_interface())
            assert((halide_device_malloc_result$2 == 0), halide_device_malloc_result$2)
            allocate upx$5.shared_size[int32 * 1] in Stack
            upx$5.shared_size[0] = 0
            allocate cost_pyramid_pull[1].shared_size[int32 * 1] in Stack
            cost_pyramid_pull[1].shared_size[0] = 0
            allocate upx$6.shared_size[int32 * 1] in Stack
            upx$6.shared_size[0] = 0
            let t106711 = ((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0)
            let t106712 = ((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1)
            let t106707 = (((t106712 - argmin.s1.y.min) + 15)/16)
            let t106709 = (((t106711 - argmin.s1.x.min) + 15)/16)
            let t106706 = ((slices + 1)/2)
            let t106708 = (t106712 + -16)
            let t106710 = (t106711 + -16)
            for (t104164, 0, t106706) {
              for (t104163, 0, t106707) {
                let filtered_cost.s0.y.y_i.base = min(((t104163*16) + argmin.s1.y.min), t106708)
                let t106714 = ((((filtered_cost.s0.y.y_i.base + 2) % 4) + 31)/4)
                let t106713 = (filtered_cost.s0.y.y_i.base % 2)
                for (t104162, 0, t106709) {
                  cost_pyramid_pull[1].shared_size[0] = max(cost_pyramid_pull[1].shared_size[0], ((((min(((t104162*16) + argmin.s1.x.min), t106710) % 2)*((t106713*4) + 40)) + (t106713*40)) + 400))
                  upx$5.shared_size[0] = max(upx$5.shared_size[0], ((((min(((t104162*16) + argmin.s1.x.min), t106710) % 2) + 10)*t106714)*4))
                }
                upx$6.shared_size[0] = max(upx$6.shared_size[0], (((min(((t104163*16) + argmin.s1.y.min), t106708) % 2)*64) + 640))
              }
            }
            let upx$5.shared_size_var = upx$5.shared_size[0]
            let cost_pyramid_pull[1].shared_size_var = cost_pyramid_pull[1].shared_size[0]
            let upx$6.shared_size_var = upx$6.shared_size[0]
            let t104190 = max(upx$5.shared_size_var, upx$6.shared_size_var)
            let t105514 = (2 - min(slices, 2))
            let t106740 = ((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0)
            let t106741 = ((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1)
            let t106742 = (t106740 - argmin.s1.x.min)
            let t106743 = max(slices, 2)
            let t106716 = (((t106741 - argmin.s1.y.min) + 15)/16)
            let t106717 = ((t106742 + 15)/16)
            let t106715 = ((slices + 1)/2)
            let t106722 = ((cost_pyramid_pull[2].y.min_realized.s + -55)/4)
            let t106724 = ((cost_pyramid_pull[2].x.min_realized.s + -55)/4)
            let t106727 = (left_im.extent.1/2)
            let t106730 = (left_im.extent.0/2)
            let t106737 = (int64(diff.stride.3)*(int64)2)
            let t106731 = (downy.stride.2*t106743)
            let t106725 = (cost_pyramid_pull[2].stride.2*t106743)
            let t106718 = ((cost_pyramid_pull[1].shared_size_var + t104190)*4)
            let t106738 = (((((t106742 + -1)/16)*16) + argmin.s1.x.min) - filtered_cost.x.min_realized)
            let t106739 = (filtered_cost.y.extent_realized.s - filtered_cost.y.min_realized)
            let t106736 = (diff.y.extent_realized.s - diff.y.min_realized)
            let t106734 = (diff.x.extent_realized.s.s - diff.x.min_realized)
            let t106726 = (12 - downy.y.min_realized.s)
            let t106735 = (4 - diff.z.min_realized.s)
            let t106729 = (-1 - downy.x.min_realized)
            let t106732 = (int64(t104190) + (int64)-1)
            let t106728 = ((downy.x.extent_realized.s.s - downy.x.min_realized) + -63)
            let t106733 = ((cost_confidence.x.extent_realized.s.s - cost_confidence.x.min_realized) + -125)
            let t106720 = (t106741 + -16)
            let t106721 = (t106740 + -16)
            let t106719 = (slices + -2)
            let t106723 = (cost_pyramid_pull[2].x.extent_realized.s + 1)
            gpu_block<CUDA> (filtered_cost.s0.z.z_o.__block_id_z, 0, t106715) {
              gpu_block<CUDA> (filtered_cost.s0.y.y_o.__block_id_y, 0, t106716) {
                gpu_block<CUDA> (filtered_cost.s0.x.x_o.__block_id_x, 0, t106717) {
                  allocate __shared[uint8 * t106718] in GPUShared
                  gpu_thread<CUDA> (.__thread_id_z, 0, 2) {
                    gpu_thread<CUDA> (.__thread_id_y, 0, 16) {
                      gpu_thread<CUDA> (.__thread_id_x, 0, 16) {
                        let filtered_cost.s0.z.z_i.base = min((filtered_cost.s0.z.z_o.__block_id_z*2), t106719)
                        let filtered_cost.s0.y.y_i.base = min(((filtered_cost.s0.y.y_o.__block_id_y*16) + argmin.s1.y.min), t106720)
                        let filtered_cost.s0.x.x_i.base = min(((filtered_cost.s0.x.x_o.__block_id_x*16) + argmin.s1.x.min), t106721)
                        let upx$5.stride.2 = (((((filtered_cost.s0.y.y_i.base + 2) % 4) + 31)/4)*((filtered_cost.s0.x.x_i.base % 2) + 10))
                        if ((.__thread_id_z < 1)) {
                          let upx$5.s0.y.__thread_id_y.loop_extent.s = min(((filtered_cost.s0.y.y_o.__block_id_y*16) + argmin.s1.y.min), t106720)
                          let upx$5.s0.x.__thread_id_x.loop_extent.s = min(((filtered_cost.s0.x.x_o.__block_id_x*16) + argmin.s1.x.min), t106721)
                          produce upx$5 {
                            if ((.__thread_id_y < ((((upx$5.s0.y.__thread_id_y.loop_extent.s + 2) % 4) + 31)/4))) {
                              if ((.__thread_id_x < ((upx$5.s0.x.__thread_id_x.loop_extent.s % 2) + 10))) {
                                let t105532 = (int64(((((filtered_cost.s0.y.y_i.base + -6)/4) - t106722) + .__thread_id_y))*int64(t106723))
                                let t105533 = (((((filtered_cost.s0.x.x_i.base/2) + .__thread_id_x) + -1)/2) - t106724)
                                let t105535 = ((int64(.__thread_id_y)*int64(((filtered_cost.s0.x.x_i.base % 2) + 10))) + int64(.__thread_id_x))
                                let t106744 = ((t105532 + int64(((((((filtered_cost.s0.x.x_i.base/2) + .__thread_id_x) + 1) % 2)*2) + t105533))) + (int64)-1)
                                let t106745 = (t105532 + int64(t105533))
                                for (upx$5.s0._0, filtered_cost.s0.z.z_i.base, 2) {
                                  let t105538 = (int64((t105514 + upx$5.s0._0))*int64(cost_pyramid_pull[2].stride.2))
                                  let t105541.s = (int64((upx$5.s0._0 - filtered_cost.s0.z.z_i.base))*int64(upx$5.stride.2))
                                  let t106750 = (upx$5.stride.2*2)
                                  let t106748 = (t105538 + t106745)
                                  let t106747 = (t105538 + t106744)
                                  let t106749 = (t105535 + t105541.s)
                                  for (upx$5.s0._1, 0, 2) {
                                    __shared[((int64(upx$5.s0._1)*int64(t106750)) + t106749)] = (let t106223 = (int64(upx$5.s0._1)*int64(t106725)) in ((cost_pyramid_pull[2][(t106223 + t106747)] + (cost_pyramid_pull[2][(t106223 + t106748)]*3.000000f))*0.250000f))
                                  }
                                }
                              }
                            }
                          }
                        }
                        gpu_thread_barrier()
                        let cost_pyramid_pull[1].stride.2 = (((filtered_cost.s0.x.x_i.base % 2) + 10)*((filtered_cost.s0.y.y_i.base % 2) + 10))
                        let cost_pyramid_pull[1].s0.y.__thread_id_y.loop_extent.s = min(((filtered_cost.s0.y.y_o.__block_id_y*16) + argmin.s1.y.min), t106720)
                        let cost_pyramid_pull[1].s0.x.__thread_id_x.loop_extent.s = min(((filtered_cost.s0.x.x_o.__block_id_x*16) + argmin.s1.x.min), t106721)
                        produce cost_pyramid_pull[1] {
                          consume upx$5 {
                            if ((.__thread_id_y < ((cost_pyramid_pull[1].s0.y.__thread_id_y.loop_extent.s % 2) + 10))) {
                              if ((.__thread_id_x < ((cost_pyramid_pull[1].s0.x.__thread_id_x.loop_extent.s % 2) + 10))) {
                                let t105543 = (int64(.__thread_id_z)*int64(upx$5.stride.2))
                                let t105545 = (((((filtered_cost.s0.y.y_i.base/2) + .__thread_id_y) + -1)/2) - ((filtered_cost.s0.y.y_i.base + -6)/4))
                                let t105548 = (((int64(((filtered_cost.s0.z.z_i.base + t105514) + .__thread_id_z))*int64(downy.stride.2)) + (int64((max(min(((filtered_cost.s0.y.y_i.base/2) + .__thread_id_y), t106727), 1) + t106726))*int64(t106728))) + int64((max(min(((filtered_cost.s0.x.x_i.base/2) + .__thread_id_x), t106730), 1) + t106729)))
                                let t105549 = (((int64(.__thread_id_y)*int64(((filtered_cost.s0.x.x_i.base % 2) + 10))) + ((int64(.__thread_id_z)*int64(cost_pyramid_pull[1].stride.2)) + int64(t104190))) + int64(.__thread_id_x))
                                let t106751 = (upx$5.stride.2*2)
                                let t106754 = (cost_pyramid_pull[1].stride.2*2)
                                let t106752 = (filtered_cost.s0.x.x_i.base % 2)
                                let t106753 = ((((((filtered_cost.s0.y.y_i.base/2) + .__thread_id_y) + 1) % 2)*2) + t105545)
                                for (cost_pyramid_pull[1].s0.c, 0, 2) {
                                  __shared[((int64(cost_pyramid_pull[1].s0.c)*int64(t106754)) + t105549)] = (let t106224 = (int64(cost_pyramid_pull[1].s0.c)*int64(t106751)) in lerp(((__shared[((((int64(t106753)*int64((t106752 + 10))) + (t105543 - int64((t106752 + 10)))) + int64(.__thread_id_x)) + t106224)] + (__shared[((((int64(t105545)*int64((t106752 + 10))) + t105543) + int64(.__thread_id_x)) + t106224)]*3.000000f))*0.250000f), downy[((int64(cost_pyramid_pull[1].s0.c)*int64(t106731)) + t105548)], 0.500000f))
                                }
                              }
                            }
                          }
                        }
                        gpu_thread_barrier()
                        if ((.__thread_id_z < 1)) {
                          let upx$6.s0.y.__thread_id_y.loop_extent.s = min(((filtered_cost.s0.y.y_o.__block_id_y*16) + argmin.s1.y.min), t106720)
                          produce upx$6 {
                            consume cost_pyramid_pull[1] {
                              if ((.__thread_id_y < ((upx$6.s0.y.__thread_id_y.loop_extent.s % 2) + 10))) {
                                let t105557 = (1 - (filtered_cost.s0.x.x_i.base/2))
                                let t105559 = ((int64(.__thread_id_y)*(int64)16) + int64(.__thread_id_x))
                                let t106761 = (filtered_cost.s0.y.y_i.base % 2)
                                let t106762 = (.__thread_id_x + filtered_cost.s0.x.x_i.base)
                                let t106763 = (filtered_cost.s0.x.x_i.base % 2)
                                let t106755 = (int64(.__thread_id_y)*int64((t106763 + 10)))
                                let t106759 = (((.__thread_id_x + t106763)/2) + 1)
                                let t106757 = ((t106762/2) + (((t106762 % 2)*2) + t105557))
                                let t106760 = ((t106761*32) + 320)
                                let t106756 = ((t106761*16) + 160)
                                for (upx$6.s0._0, filtered_cost.s0.z.z_i.base, 2) {
                                  let t105561 = (int64((upx$6.s0._0 - filtered_cost.s0.z.z_i.base))*int64(cost_pyramid_pull[1].stride.2))
                                  let t105565.s = (int64((upx$6.s0._0 - filtered_cost.s0.z.z_i.base))*int64(t106756))
                                  let t106764 = (cost_pyramid_pull[1].stride.2*2)
                                  let t106766 = (((t106755 + int64(t104190)) + int64(t106759)) + t105561)
                                  let t106765 = (((t106732 + t106755) + int64(t106757)) + t105561)
                                  let t106767 = (t105559 + t105565.s)
                                  for (upx$6.s0._1, 0, 2) {
                                    __shared[((int64(upx$6.s0._1)*int64(t106760)) + t106767)] = (let t106227 = (int64(upx$6.s0._1)*int64(t106764)) in ((__shared[(t106227 + t106765)] + (__shared[(t106227 + t106766)]*3.000000f))*0.250000f))
                                  }
                                }
                              }
                            }
                          }
                        }
                        gpu_thread_barrier()
                        consume upx$6 {
                          filtered_cost[(((int64(((filtered_cost.s0.z.z_i.base + t105514) + .__thread_id_z))*int64(((t106738 + 16)*t106739))) + (int64(((filtered_cost.s0.y.y_i.base - filtered_cost.y.min_realized) + .__thread_id_y))*int64((t106738 + 16)))) + int64(((filtered_cost.s0.x.x_i.base - filtered_cost.x.min_realized) + .__thread_id_x)))] = (let t106228 = cost_confidence[((int64(((filtered_cost.s0.y.y_i.base - cost_confidence.y.min_realized) + .__thread_id_y))*int64(t106733)) + int64(((filtered_cost.s0.x.x_i.base - cost_confidence.x.min_realized) + .__thread_id_x)))] in (let t106230 = (int64(((filtered_cost.s0.z.z_i.base + t106735) + .__thread_id_z))*int64(((t106734 + -128)*t106736))) in (let t106231 = (int64(((filtered_cost.s0.y.y_i.base - diff.y.min_realized) + .__thread_id_y))*int64((t106734 + -128))) in (let t106233 = (int64(.__thread_id_z)*int64((((filtered_cost.s0.y.y_i.base % 2)*16) + 160))) in (let t106235 = (((.__thread_id_y + filtered_cost.s0.y.y_i.base)/2) - (filtered_cost.s0.y.y_i.base/2)) in (let t106238.s = diff[(((t106230 + t106737) + t106231) + int64(((filtered_cost.s0.x.x_i.base - diff.x.min_realized) + .__thread_id_x)))] in (let t106239.s = diff[((t106230 + t106231) + int64(((filtered_cost.s0.x.x_i.base - diff.x.min_realized) + .__thread_id_x)))] in (let t106240.s = diff[(((t106230 + int64(diff.stride.3)) + t106231) + int64(((filtered_cost.s0.x.x_i.base - diff.x.min_realized) + .__thread_id_x)))] in (lerp(((__shared[((((int64((((((.__thread_id_y + filtered_cost.s0.y.y_i.base) % 2)*2) + t106235) + 1))*(int64)16) + t106233) + int64(.__thread_id_x)) + (int64)-16)] + (__shared[(((int64((t106235 + 1))*(int64)16) + t106233) + int64(.__thread_id_x))]*3.000000f))*0.250000f), (((float32(t106238.s)*float32(t106238.s)) + ((float32(t106239.s)*float32(t106239.s)) + (float32(t106240.s)*float32(t106240.s))))*t106228), 0.500000f)/lerp(((__shared[((((int64((((((.__thread_id_y + filtered_cost.s0.y.y_i.base) % 2)*2) + t106235) + 1))*(int64)16) + (t106233 + int64((((filtered_cost.s0.y.y_i.base % 2)*32) + 320)))) + int64(.__thread_id_x)) + (int64)-16)] + (__shared[(((int64((t106235 + 1))*(int64)16) + (t106233 + int64((((filtered_cost.s0.y.y_i.base % 2)*32) + 320)))) + int64(.__thread_id_x))]*3.000000f))*0.250000f), t106228, 0.500000f))))))))))
                        }
                      }
                    }
                  }
                  free __shared
                }
              }
            }
            free upx$5.shared_size
            free cost_pyramid_pull[1].shared_size
            free upx$6.shared_size
            let halide_device_free_result$13 = halide_device_free(diff.buffer)
            assert((halide_device_free_result$13 == 0), halide_device_free_result$13)
            free diff
            let halide_device_free_result$12 = halide_device_free(cost_confidence.buffer)
            assert((halide_device_free_result$12 == 0), halide_device_free_result$12)
            free cost_confidence
            let halide_device_free_result$11 = halide_device_free(downy.buffer)
            assert((halide_device_free_result$11 == 0), halide_device_free_result$11)
            free downy
            let halide_device_free_result$3 = halide_device_free(cost_pyramid_pull[2].buffer)
            assert((halide_device_free_result$3 == 0), halide_device_free_result$3)
            free cost_pyramid_pull[2]
            _halide_buffer_set_device_dirty(filtered_cost.buffer, (uint1)1)
          }
        }
      }
    }
  }
  let argmin.y.min_realized = min(min(min(min(min(min((final.min.1 - maximum$1.s1.r$2$x.max), argmin.s1.y.min), ((final.extent.1 + final.min.1) + -8)), final.min.1), (final.min.1 - int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(max((slices - focus_depth), focus_depth)))))), (((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + -8)), argmin.s1.y.min)
  let argmin.y.extent_realized = (let t106242 = int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(max((slices - focus_depth), focus_depth)))) in (max(max(max(((((((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) - argmin.s1.y.min) + -1)/8)*8) + argmin.s1.y.min) + 8), ((final.extent.1 + final.min.1) + maximum$1.s1.r$2$x.max)), ((max(max((0 - t106242), t106242), 0) + final.extent.1) + final.min.1)), min(((((((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) - argmin.s1.y.min) + -1)/8)*8) + argmin.s1.y.min) + 8), ((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1))) - min(min(min(min(min(min((final.min.1 - maximum$1.s1.r$2$x.max), argmin.s1.y.min), ((final.extent.1 + final.min.1) + -8)), final.min.1), (final.min.1 - t106242)), (((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) + -8)), argmin.s1.y.min)))
  let argmin.x.min_realized = min(min(min(min(min(min((final.min.0 - maximum$1.s1.r$2$x.max), argmin.s1.x.min), ((final.extent.0 + final.min.0) + -10)), final.min.0), (final.min.0 - int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(max((slices - focus_depth), focus_depth)))))), (((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + -8)), argmin.s1.x.min)
  let argmin.x.extent_realized = (let t106246 = int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*float32(max((slices - focus_depth), focus_depth)))) in (max(max(max(((((((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) - argmin.s1.x.min) + -1)/16)*16) + argmin.s1.x.min) + 16), ((final.extent.0 + final.min.0) + maximum$1.s1.r$2$x.max)), ((max(max((0 - t106246), t106246), 0) + final.extent.0) + final.min.0)), min(((((((((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) - argmin.s1.x.min) + -1)/8)*8) + argmin.s1.x.min) + 8), ((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0))) - min(min(min(min(min(min((final.min.0 - maximum$1.s1.r$2$x.max), argmin.s1.x.min), ((final.extent.0 + final.min.0) + -10)), final.min.0), (final.min.0 - t106246)), (((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) + -8)), argmin.s1.x.min)))
  allocate argmin.0[int32 * argmin.x.extent_realized * argmin.y.extent_realized] if (uint1)0
  let argmin.0.buffer = _halide_buffer_init(alloca(size_of_halide_buffer_t()), make_struct((halide_dimension_t *), argmin.x.min_realized, argmin.x.extent_realized, 1, 0, argmin.y.min_realized, argmin.y.extent_realized, argmin.x.extent_realized, 0), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 0, 32, 2, make_struct((halide_dimension_t *), argmin.x.min_realized, argmin.x.extent_realized, 1, 0, argmin.y.min_realized, argmin.y.extent_realized, argmin.x.extent_realized, 0), (uint64)0)
  register_destructor("halide_device_free_as_destructor", argmin.0.buffer)
  allocate argmin.1[float32 * argmin.x.extent_realized * argmin.y.extent_realized] if (uint1)0
  let argmin.1.buffer = _halide_buffer_init(alloca(size_of_halide_buffer_t()), make_struct((halide_dimension_t *), argmin.x.min_realized, argmin.x.extent_realized, 1, 0, argmin.y.min_realized, argmin.y.extent_realized, argmin.x.extent_realized, 0), reinterpret((void *), (uint64)0), (uint64)0, reinterpret((halide_device_interface_t *), (uint64)0), 2, 32, 2, make_struct((halide_dimension_t *), argmin.x.min_realized, argmin.x.extent_realized, 1, 0, argmin.y.min_realized, argmin.y.extent_realized, argmin.x.extent_realized, 0), (uint64)0)
  register_destructor("halide_device_free_as_destructor", argmin.1.buffer)
  produce argmin {
    let halide_device_malloc_result = halide_device_malloc(argmin.1.buffer, halide_cuda_device_interface())
    assert((halide_device_malloc_result == 0), halide_device_malloc_result)
    let halide_device_malloc_result$1 = halide_device_malloc(argmin.0.buffer, halide_cuda_device_interface())
    assert((halide_device_malloc_result$1 == 0), halide_device_malloc_result$1)
    let t106774 = ((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1)
    let t106775 = ((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0)
    let t106776 = (t106775 - argmin.s1.x.min)
    let t106771 = max((t106776/8), 0)
    let t106768 = (((t106774 - argmin.s1.y.min) + 7)/8)
    let t106769 = ((t106776 + 7)/8)
    let t106772 = (argmin.s1.x.min - argmin.x.min_realized)
    let t106773 = ((t106775 - argmin.x.min_realized) + -8)
    let t106770 = (t106774 + -8)
    gpu_block<CUDA> (argmin.s0.y.y_o.__block_id_y, 0, t106768) {
      gpu_block<CUDA> (argmin.s0.x.x_o.__block_id_x, 0, t106769) {
        gpu_thread<CUDA> (.__thread_id_y, 0, 8) {
          gpu_thread<CUDA> (.__thread_id_x, 0, 8) {
            let argmin.s0.y.y_i.base = min(((argmin.s0.y.y_o.__block_id_y*8) + argmin.s1.y.min), t106770)
            if ((argmin.s0.x.x_o.__block_id_x < t106771)) {
              argmin.0[((int64(((argmin.s0.y.y_i.base - argmin.y.min_realized) + .__thread_id_y))*int64(argmin.x.extent_realized)) + int64((((argmin.s0.x.x_o.__block_id_x*8) + t106772) + .__thread_id_x)))] = 0
              argmin.1[((int64(((argmin.s0.y.y_i.base - argmin.y.min_realized) + .__thread_id_y))*int64(argmin.x.extent_realized)) + int64((((argmin.s0.x.x_o.__block_id_x*8) + t106772) + .__thread_id_x)))] = inff
            } else {
              argmin.0[((int64(((argmin.s0.y.y_i.base - argmin.y.min_realized) + .__thread_id_y))*int64(argmin.x.extent_realized)) + int64((.__thread_id_x + t106773)))] = 0
              argmin.1[((int64(((argmin.s0.y.y_i.base - argmin.y.min_realized) + .__thread_id_y))*int64(argmin.x.extent_realized)) + int64((.__thread_id_x + t106773)))] = inff
            }
          }
        }
      }
    }
    _halide_buffer_set_device_dirty(argmin.0.buffer, (uint1)1)
    _halide_buffer_set_device_dirty(argmin.1.buffer, (uint1)1)
    consume filtered_cost {
      let t105582 = (2 - min(slices, 2))
      let t106785 = (((max(argmin.s1.x.max.s.s, 0) + final.extent.0) + final.min.0) - argmin.s1.x.min)
      let t106786 = ((((((t106785 + -1)/16)*16) + argmin.s1.x.min) - filtered_cost.x.min_realized) + 16)
      let t106777 = (((((max(argmin.s1.y.max.s.s, 0) + final.extent.1) + final.min.1) - argmin.s1.y.min) + 7)/8)
      let t106778 = ((t106785 + 15)/16)
      let t106779 = ((filtered_cost.y.extent_realized.s - filtered_cost.y.min_realized)*t106786)
      let t106780 = (argmin.s1.y.min - filtered_cost.y.min_realized)
      let t106783 = (argmin.s1.y.min - argmin.y.min_realized)
      let t106782 = (argmin.s1.x.min - filtered_cost.x.min_realized)
      let t106784 = (argmin.s1.x.min - argmin.x.min_realized)
      gpu_block<CUDA> (argmin.s1.y.y_o.__block_id_y, 0, t106777) {
        gpu_block<CUDA> (argmin.s1.x.x_o.__block_id_x, 0, t106778) {
          gpu_thread<CUDA> (.__thread_id_y, 0, 8) {
            gpu_thread<CUDA> (.__thread_id_x, 0, 16) {
              let t105586 = ((int64((((argmin.s1.y.y_o.__block_id_y*8) + t106780) + .__thread_id_y))*int64(t106786)) + int64((((argmin.s1.x.x_o.__block_id_x*16) + t106782) + .__thread_id_x)))
              let t105585 = ((int64((((argmin.s1.y.y_o.__block_id_y*8) + t106783) + .__thread_id_y))*int64(argmin.x.extent_realized)) + int64((((argmin.s1.x.x_o.__block_id_x*16) + t106784) + .__thread_id_x)))
              for (argmin.s1.r$1$x, 0, slices) {
                let argmin.0.value = select((filtered_cost[((int64((argmin.s1.r$1$x + t105582))*int64(t106779)) + t105586)] < argmin.1[t105585]), argmin.s1.r$1$x, argmin.0[t105585])
                let argmin.1.value = min(filtered_cost[((int64((argmin.s1.r$1$x + t105582))*int64(t106779)) + t105586)], argmin.1[t105585])
                argmin.0[t105585] = argmin.0.value
                argmin.1[t105585] = argmin.1.value
              }
            }
          }
        }
      }
      let halide_device_free_result$2 = halide_device_free(filtered_cost.buffer)
      assert((halide_device_free_result$2 == 0), halide_device_free_result$2)
      free filtered_cost
      let halide_device_free_result = halide_device_free(argmin.1.buffer)
      assert((halide_device_free_result == 0), halide_device_free_result)
      free argmin.1
    }
  }
  assert(((0 <= final.min.2) && ((final.extent.2 + final.min.2) <= 3)), halide_error_explicit_bounds_too_small("c", "final", 0, 2, final.min.2, ((final.extent.2 + final.min.2) + -1)))
  produce final {
    consume argmin {
      consume repeat_edge {
        let halide_copy_to_device_result = halide_copy_to_device(final.buffer, halide_cuda_device_interface())
        assert((halide_copy_to_device_result == 0), halide_copy_to_device_result)
        let t104195 = max((aperture_samples*320), ((maximum$1.s1.r$2$x.max*64) + 320))
        let t105620 = float32(max((slices - focus_depth), focus_depth))
        let t105625 = (int64(final.min.1)*int64(final.stride.1))
        let t105618 = (((int64(final.stride.2)*(int64)2) - t105625) - int64(final.min.0))
        let t105617 = ((int64(final.stride.2) - t105625) - int64(final.min.0))
        let t105615 = int32((max(min(blur_radius_scale, 1.000000f), 0.000000f)*t105620))
        let t106812 = max(min(blur_radius_scale, 1.000000f), 0.000000f)
        let t106813 = (maximum$1.s1.r$2$x.max*2)
        let t106814 = ((t104195 + 3)/4)
        let t106815 = ((t104195 + 323)/4)
        let t106816 = int64(t106815)
        let t106787 = ((final.extent.1 + 7)/8)
        let t106788 = ((final.extent.0 + 9)/10)
        let t106807 = (int64(repeat_edge.stride.2)*(int64)2)
        let t106797 = ((final.min.0 - maximum$1.s1.r$2$x.max) - argmin.x.min_realized)
        let t106802 = (final.min.1 - repeat_edge._1.min_realized)
        let t106798 = (final.min.1 - argmin.y.min_realized)
        let t106804 = (final.min.0 - repeat_edge._0.min_realized)
        let t106801 = (final.min.0 - argmin.x.min_realized)
        let t106811 = (t105625 + int64(final.min.0))
        let t106809 = (t106816 + (int64)240)
        let t106808 = (t106816 + (int64)160)
        let t106806 = (t106816 + (int64)80)
        let t106790 = ((max(maximum$1.s1.r$2$x.max, 0)*2) + 10)
        let t106789 = ((t106814*4) + 1600)
        let t106793 = (t106813 + 10)
        let t106795 = (t106813 + 1)
        let t106803 = ((repeat_edge._0.extent_realized.s.s - repeat_edge._0.min_realized) + 1)
        let t106791 = (final.extent.1 + -8)
        let t106792 = (final.extent.0 + -10)
        let t106800 = int32((t105620*t106812))
        gpu_block<CUDA> (final.s0.y.y_o.__block_id_y, 0, t106787) {
          gpu_block<CUDA> (final.s0.x.x_o.__block_id_x, 0, t106788) {
            allocate __shared[uint8 * t106789] in GPUShared
            gpu_thread<CUDA> (.__thread_id_y, 0, 8) {
              gpu_thread<CUDA> (.__thread_id_x, 0, t106790) {
                let final.s0.y.y_i.base.s = min((final.s0.y.y_o.__block_id_y*8), t106791)
                let final.s0.x.x_i.base.s = min((final.s0.x.x_o.__block_id_x*10), t106792)
                produce maximum {
                  if ((.__thread_id_x < t106793)) {
                    __shared[((int64(.__thread_id_y)*int64(t106793)) + int64(.__thread_id_x))] = -inff
                  }
                  gpu_thread_barrier()
                  if ((.__thread_id_x < t106793)) {
                    let t105629 = ((int64(.__thread_id_y)*int64(t106793)) + int64(.__thread_id_x))
                    let t106817 = (0 - maximum$1.s1.r$2$x.max)
                    let t106819 = ((final.s0.y.y_i.base.s + t106798) + .__thread_id_y)
                    let t106818 = ((final.s0.x.x_i.base.s + t106797) + .__thread_id_x)
                    for (maximum.s1.r$2$x, t106817, t106795) {
                      __shared[t105629] = max(__shared[t105629], (t106812*float32(abs((argmin.0[((int64((maximum.s1.r$2$x + t106819))*int64(argmin.x.extent_realized)) + int64(t106818))] - focus_depth)))))
                    }
                  }
                }
                gpu_thread_barrier()
                produce maximum$1 {
                  if ((.__thread_id_x < 10)) {
                    __shared[(((int64(.__thread_id_y)*(int64)10) + int64(t106814)) + int64(.__thread_id_x))] = -inff
                  }
                  gpu_thread_barrier()
                  consume maximum {
                    if ((.__thread_id_x < 10)) {
                      let t105633 = (int64(.__thread_id_y)*int64(t106793))
                      let t105635 = (((int64(.__thread_id_y)*(int64)10) + int64(t106814)) + int64(.__thread_id_x))
                      let t106820 = (0 - maximum$1.s1.r$2$x.max)
                      let t106821 = (.__thread_id_x + maximum$1.s1.r$2$x.max)
                      for (maximum$1.s1.r$2$x, t106820, t106795) {
                        __shared[t105635] = max(__shared[(t105633 + int64((maximum$1.s1.r$2$x + t106821)))], __shared[t105635])
                      }
                    }
                  }
                }
                gpu_thread_barrier()
                produce sample_weight {
                  consume maximum$1 {
                    if ((.__thread_id_x < 10)) {
                      let t105643 = ((int64(.__thread_id_y)*(int64)10) + int64(.__thread_id_x))
                      let t105640 = (((int64(.__thread_id_y)*(int64)10) + int64(t106814)) + int64(.__thread_id_x))
                      let t105639 = uint32(((final.min.1 + final.s0.y.y_i.base.s) + .__thread_id_y))
                      let t105638 = uint32(((final.min.0 + final.s0.x.x_i.base.s) + .__thread_id_x))
                      let t106828 = (t105638*(uint32)1040796640)
                      let t106825 = ((t106828 + (uint32)2753653065)*(t105638 + (uint32)475272354))
                      let t106822 = ((t106828 + (uint32)1527534985)*(t105638 + (uint32)3392003200))
                      let t106826 = ((final.s0.y.y_i.base.s + t106798) + .__thread_id_y)
                      let t106827 = ((final.s0.x.x_i.base.s + t106801) + .__thread_id_x)
                      for (sample_weight.s0.z, 0, aperture_samples) {
                        __shared[((int64(sample_weight.s0.z)*(int64)80) + t105643)] = (let t106251 = (((((t105639 + t106822)*(uint32)1040796640) + (uint32)1337891305)*((t105639 + t106822) + (uint32)576942909)) + uint32(sample_weight.s0.z)) in (let t106252 = __shared[t105640] in (let t106253 = max(min(t106800, int32((((max(min(reinterpret(float32, bitwise_or(1065353216, reinterpret(int32, (((((t106251*(uint32)1040796640) + (uint32)1337891305)*(t106251 + (uint32)576942909)) + (uint32)576942909)/(uint32)512)))), 2.000000f), 1.000000f)*2.000000f) + -3.000000f)*t106252))), (0 - t106800)) in (let t106255 = (((((t105639 + t106825)*(uint32)1040796640) + (uint32)1337891305)*((t105639 + t106825) + (uint32)576942909)) + uint32(sample_weight.s0.z)) in (let t106256 = max(min(t106800, int32((((max(min(reinterpret(float32, bitwise_or(1065353216, reinterpret(int32, (((((t106255*(uint32)1040796640) + (uint32)1337891305)*(t106255 + (uint32)576942909)) + (uint32)576942909)/(uint32)512)))), 2.000000f), 1.000000f)*2.000000f) + -3.000000f)*t106252))), (0 - t106800)) in (let t106257 = float32(((t106253*t106253) + (t106256*t106256))) in (let t106260 = argmin.0[((int64(t106826)*int64(argmin.x.extent_realized)) + int64(t106827))] in (let t106262 = (t106812*float32(abs((t106260 - focus_depth)))) in (let t106263 = argmin.0[((int64((t106256 + t106826))*int64(argmin.x.extent_realized)) + int64((t106253 + t106827)))] in (let t106264 = (t106812*float32(abs((t106263 - focus_depth)))) in select((((t106257 < (t106262*t106262)) || (t106263 < t106260)) && (t106257 < (t106264*t106264))), 1.000000f, 0.000000f)))))))))))
                      }
                    }
                  }
                }
                gpu_thread_barrier()
                produce output {
                  if ((.__thread_id_x < 10)) {
                    __shared[(((int64(.__thread_id_y)*(int64)10) + int64(t106815)) + int64(.__thread_id_x))] = float32(repeat_edge[((int64(((final.s0.y.y_i.base.s + t106802) + .__thread_id_y))*int64(t106803)) + int64(((final.s0.x.x_i.base.s + t106804) + .__thread_id_x)))])
                    __shared[(((int64(.__thread_id_y)*(int64)10) + t106806) + int64(.__thread_id_x))] = float32(repeat_edge[(((int64(((final.s0.y.y_i.base.s + t106802) + .__thread_id_y))*int64(t106803)) + int64(repeat_edge.stride.2)) + int64(((final.s0.x.x_i.base.s + t106804) + .__thread_id_x)))])
                    __shared[(((int64(.__thread_id_y)*(int64)10) + t106808) + int64(.__thread_id_x))] = float32(repeat_edge[(((int64(((final.s0.y.y_i.base.s + t106802) + .__thread_id_y))*int64(t106803)) + t106807) + int64(((final.s0.x.x_i.base.s + t106804) + .__thread_id_x)))])
                    __shared[(((int64(.__thread_id_y)*(int64)10) + t106809) + int64(.__thread_id_x))] = 255.000000f
                  }
                  gpu_thread_barrier()
                  consume sample_weight {
                    consume maximum$1 {
                      if ((.__thread_id_x < 10)) {
                        let t105650 = ((int64(.__thread_id_y)*(int64)10) + int64(.__thread_id_x))
                        let t105656.s = (((int64(.__thread_id_y)*(int64)10) + int64(t106815)) + int64(.__thread_id_x))
                        let t105655.s = (((int64(.__thread_id_y)*(int64)10) + int64(t106815)) + int64(.__thread_id_x))
                        let t105654.s = (((int64(.__thread_id_y)*(int64)10) + int64(t106815)) + int64(.__thread_id_x))
                        let t105649 = (((int64(.__thread_id_y)*(int64)10) + int64(t106815)) + int64(.__thread_id_x))
                        let t105648 = (((int64(.__thread_id_y)*(int64)10) + int64(t106814)) + int64(.__thread_id_x))
                        let t105647 = uint32(((final.min.1 + final.s0.y.y_i.base.s) + .__thread_id_y))
                        let t105646 = uint32(((final.min.0 + final.s0.x.x_i.base.s) + .__thread_id_x))
                        let t106838 = (t105646*(uint32)1040796640)
                        let t106831 = ((t106838 + (uint32)2753653065)*(t105646 + (uint32)475272354))
                        let t106829 = ((t106838 + (uint32)1527534985)*(t105646 + (uint32)3392003200))
                        let t106837 = (t105656.s + (int64)240)
                        let t106836 = (t105655.s + (int64)160)
                        let t106835 = (t105654.s + (int64)80)
                        let t106832 = ((final.s0.y.y_i.base.s + t106802) + .__thread_id_y)
                        let t106834 = ((final.s0.x.x_i.base.s + t106804) + .__thread_id_x)
                        for (output.s1.s$x, 0, aperture_samples) {
                          __shared[t105649] = (let t106266 = (((((t105647 + t106829)*(uint32)1040796640) + (uint32)1337891305)*((t105647 + t106829) + (uint32)576942909)) + uint32(output.s1.s$x)) in (let t106267 = __shared[t105648] in (let t106269 = (((((t105647 + t106831)*(uint32)1040796640) + (uint32)1337891305)*((t105647 + t106831) + (uint32)576942909)) + uint32(output.s1.s$x)) in (__shared[t105649] + (__shared[((int64(output.s1.s$x)*(int64)80) + t105650)]*float32(repeat_edge[((int64((max(min(t105615, int32((((max(min(reinterpret(float32, bitwise_or(1065353216, reinterpret(int32, (((((t106269*(uint32)1040796640) + (uint32)1337891305)*(t106269 + (uint32)576942909)) + (uint32)576942909)/(uint32)512)))), 2.000000f), 1.000000f)*2.000000f) + -3.000000f)*t106267))), (0 - t105615)) + t106832))*int64(t106803)) + int64((max(min(t105615, int32((((max(min(reinterpret(float32, bitwise_or(1065353216, reinterpret(int32, (((((t106266*(uint32)1040796640) + (uint32)1337891305)*(t106266 + (uint32)576942909)) + (uint32)576942909)/(uint32)512)))), 2.000000f), 1.000000f)*2.000000f) + -3.000000f)*t106267))), (0 - t105615)) + t106834)))]))))))
                          __shared[t106835] = (let t106271 = (((((t105647 + t106829)*(uint32)1040796640) + (uint32)1337891305)*((t105647 + t106829) + (uint32)576942909)) + uint32(output.s1.s$x)) in (let t106272 = __shared[t105648] in (let t106274 = (((((t105647 + t106831)*(uint32)1040796640) + (uint32)1337891305)*((t105647 + t106831) + (uint32)576942909)) + uint32(output.s1.s$x)) in (__shared[t106835] + (__shared[((int64(output.s1.s$x)*(int64)80) + t105650)]*float32(repeat_edge[(((int64((max(min(t105615, int32((((max(min(reinterpret(float32, bitwise_or(1065353216, reinterpret(int32, (((((t106274*(uint32)1040796640) + (uint32)1337891305)*(t106274 + (uint32)576942909)) + (uint32)576942909)/(uint32)512)))), 2.000000f), 1.000000f)*2.000000f) + -3.000000f)*t106272))), (0 - t105615)) + t106832))*int64(t106803)) + int64(repeat_edge.stride.2)) + int64((max(min(t105615, int32((((max(min(reinterpret(float32, bitwise_or(1065353216, reinterpret(int32, (((((t106271*(uint32)1040796640) + (uint32)1337891305)*(t106271 + (uint32)576942909)) + (uint32)576942909)/(uint32)512)))), 2.000000f), 1.000000f)*2.000000f) + -3.000000f)*t106272))), (0 - t105615)) + t106834)))]))))))
                          __shared[t106836] = (let t106276 = (((((t105647 + t106829)*(uint32)1040796640) + (uint32)1337891305)*((t105647 + t106829) + (uint32)576942909)) + uint32(output.s1.s$x)) in (let t106277 = __shared[t105648] in (let t106279 = (((((t105647 + t106831)*(uint32)1040796640) + (uint32)1337891305)*((t105647 + t106831) + (uint32)576942909)) + uint32(output.s1.s$x)) in (__shared[t106836] + (__shared[((int64(output.s1.s$x)*(int64)80) + t105650)]*float32(repeat_edge[(((int64((max(min(t105615, int32((((max(min(reinterpret(float32, bitwise_or(1065353216, reinterpret(int32, (((((t106279*(uint32)1040796640) + (uint32)1337891305)*(t106279 + (uint32)576942909)) + (uint32)576942909)/(uint32)512)))), 2.000000f), 1.000000f)*2.000000f) + -3.000000f)*t106277))), (0 - t105615)) + t106832))*int64(t106803)) + t106807) + int64((max(min(t105615, int32((((max(min(reinterpret(float32, bitwise_or(1065353216, reinterpret(int32, (((((t106276*(uint32)1040796640) + (uint32)1337891305)*(t106276 + (uint32)576942909)) + (uint32)576942909)/(uint32)512)))), 2.000000f), 1.000000f)*2.000000f) + -3.000000f)*t106277))), (0 - t105615)) + t106834)))]))))))
                          __shared[t106837] = (__shared[t106837] + (__shared[((int64(output.s1.s$x)*(int64)80) + t105650)]*255.000000f))
                        }
                      }
                    }
                  }
                }
                gpu_thread_barrier()
                consume output {
                  if ((.__thread_id_x < 10)) {
                    final[(((int64(((final.min.1 + final.s0.y.y_i.base.s) + .__thread_id_y))*int64(final.stride.1)) - t106811) + int64(((final.min.0 + final.s0.x.x_i.base.s) + .__thread_id_x)))] = (let t106280 = (((int64(.__thread_id_y)*(int64)10) + int64(t106815)) + int64(.__thread_id_x)) in (__shared[t106280]/__shared[(t106280 + (int64)240)]))
                    final[(((int64(((final.min.1 + final.s0.y.y_i.base.s) + .__thread_id_y))*int64(final.stride.1)) + t105617) + int64(((final.min.0 + final.s0.x.x_i.base.s) + .__thread_id_x)))] = (let t106281 = (((int64(.__thread_id_y)*(int64)10) + int64(t106815)) + int64(.__thread_id_x)) in (__shared[(t106281 + (int64)80)]/__shared[(t106281 + (int64)240)]))
                    final[(((int64(((final.min.1 + final.s0.y.y_i.base.s) + .__thread_id_y))*int64(final.stride.1)) + t105618) + int64(((final.min.0 + final.s0.x.x_i.base.s) + .__thread_id_x)))] = (let t106282 = (((int64(.__thread_id_y)*(int64)10) + int64(t106815)) + int64(.__thread_id_x)) in (__shared[(t106282 + (int64)160)]/__shared[(t106282 + (int64)240)]))
                  }
                }
              }
            }
            free __shared
          }
        }
        _halide_buffer_set_device_dirty(final.buffer, (uint1)1)
        let halide_device_free_result$15 = halide_device_free(repeat_edge.buffer)
        assert((halide_device_free_result$15 == 0), halide_device_free_result$15)
        free repeat_edge
        let halide_device_free_result$1 = halide_device_free(argmin.0.buffer)
        assert((halide_device_free_result$1 == 0), halide_device_free_result$1)
        free argmin.0
      }
    }
  }
}


Skipping Hexagon offload...
Module.compile(): stmt_name ./bin/lens_blur_auto_schedule.stmt
Constructing CUDA device codegen
Target triple of initial module: x86_64--linux-gnu
Generating llvm bitcode...
Generating llvm bitcode prolog for function lens_blur_auto_schedule...
Generating llvm bitcode for function lens_blur_auto_schedule...
Generating llvm bitcode for kernel...
Generating llvm bitcode for kernel...
Generating llvm bitcode for kernel...
Generating llvm bitcode for kernel...
Generating llvm bitcode for kernel...
Generating llvm bitcode for kernel...
Generating llvm bitcode for kernel...
Generating llvm bitcode for kernel...
Generating llvm bitcode for kernel...
Generating llvm bitcode for kernel...
Generating llvm bitcode for kernel...
Generating llvm bitcode for kernel...
Generating llvm bitcode for kernel...
Generating llvm bitcode for kernel...
Generating llvm bitcode for kernel...
Generating llvm bitcode for kernel...
Generating llvm bitcode for kernel...
PTX kernel:
//
// Generated by LLVM NVPTX Back-End
//

.version 5.0
.target sm_61
.address_size 64

	// .globl	kernel_repeat_edge_s0__1__1_o___block_id_y // -- Begin function kernel_repeat_edge_s0__1__1_o___block_id_y
                                        // @kernel_repeat_edge_s0__1__1_o___block_id_y
.visible .entry kernel_repeat_edge_s0__1__1_o___block_id_y(
	.param .u64 kernel_repeat_edge_s0__1__1_o___block_id_y_param_0,
	.param .u32 kernel_repeat_edge_s0__1__1_o___block_id_y_param_1,
	.param .u32 kernel_repeat_edge_s0__1__1_o___block_id_y_param_2,
	.param .u32 kernel_repeat_edge_s0__1__1_o___block_id_y_param_3,
	.param .u32 kernel_repeat_edge_s0__1__1_o___block_id_y_param_4,
	.param .u32 kernel_repeat_edge_s0__1__1_o___block_id_y_param_5,
	.param .u32 kernel_repeat_edge_s0__1__1_o___block_id_y_param_6,
	.param .u32 kernel_repeat_edge_s0__1__1_o___block_id_y_param_7,
	.param .u32 kernel_repeat_edge_s0__1__1_o___block_id_y_param_8,
	.param .u32 kernel_repeat_edge_s0__1__1_o___block_id_y_param_9,
	.param .u32 kernel_repeat_edge_s0__1__1_o___block_id_y_param_10,
	.param .u32 kernel_repeat_edge_s0__1__1_o___block_id_y_param_11,
	.param .u32 kernel_repeat_edge_s0__1__1_o___block_id_y_param_12,
	.param .u32 kernel_repeat_edge_s0__1__1_o___block_id_y_param_13,
	.param .u32 kernel_repeat_edge_s0__1__1_o___block_id_y_param_14,
	.param .u32 kernel_repeat_edge_s0__1__1_o___block_id_y_param_15,
	.param .u32 kernel_repeat_edge_s0__1__1_o___block_id_y_param_16,
	.param .u32 kernel_repeat_edge_s0__1__1_o___block_id_y_param_17,
	.param .u32 kernel_repeat_edge_s0__1__1_o___block_id_y_param_18,
	.param .u32 kernel_repeat_edge_s0__1__1_o___block_id_y_param_19,
	.param .u32 kernel_repeat_edge_s0__1__1_o___block_id_y_param_20,
	.param .u32 kernel_repeat_edge_s0__1__1_o___block_id_y_param_21,
	.param .u32 kernel_repeat_edge_s0__1__1_o___block_id_y_param_22,
	.param .u64 kernel_repeat_edge_s0__1__1_o___block_id_y_param_23,
	.param .u64 kernel_repeat_edge_s0__1__1_o___block_id_y_param_24
)
{
	.reg .pred 	%p<26>;
	.reg .b16 	%rs<43>;
	.reg .b32 	%r<144>;
	.reg .b64 	%rd<235>;

// %bb.0:                               // %entry
	ld.param.u32 	%r56, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_22];
	ld.param.u32 	%r55, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_21];
	ld.param.u32 	%r54, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_20];
	ld.param.u32 	%r53, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_19];
	ld.param.u32 	%r52, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_18];
	ld.param.u32 	%r51, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_17];
	ld.param.u32 	%r50, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_16];
	ld.param.u32 	%r49, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_12];
	ld.param.u32 	%r46, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_8];
	ld.param.u32 	%r45, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_7];
	ld.param.u32 	%r44, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_6];
	ld.param.u32 	%r43, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_5];
	ld.param.u64 	%rd73, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_0];
	ld.param.u64 	%rd74, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_24];
	cvta.to.global.u64 	%rd1, %rd74;
	ld.param.u64 	%rd75, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_23];
	cvta.to.global.u64 	%rd2, %rd75;
	mov.u32 	%r57, %ctaid.y;
	mov.u32 	%r1, %ctaid.x;
	mov.u32 	%r2, %tid.y;
	mov.u32 	%r3, %tid.x;
	ld.param.u32 	%r58, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_14];
	setp.lt.s32 	%p1, %r57, %r58;
	ld.param.u32 	%r59, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_15];
	setp.ge.s32 	%p2, %r57, %r59;
	ld.param.u32 	%r60, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_9];
	shl.b32 	%r61, %r57, 3;
	ld.param.u32 	%r62, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_13];
	add.s32 	%r63, %r61, %r62;
	min.s32 	%r4, %r63, %r60;
	or.pred  	%p3, %p1, %p2;
	@%p3 bra 	LBB0_3;
// %bb.1:                               // %true_bb
	ld.param.u32 	%r48, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_11];
	ld.param.u32 	%r47, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_10];
	setp.ge.s32 	%p4, %r1, %r48;
	setp.lt.s32 	%p5, %r1, %r47;
	and.pred  	%p6, %p4, %p5;
	shl.b32 	%r82, %r1, 5;
	add.s32 	%r83, %r82, %r50;
	min.s32 	%r84, %r83, %r46;
	add.s32 	%r85, %r4, %r2;
	sub.s32 	%r86, %r85, %r51;
	mul.wide.s32 	%rd3, %r86, %r45;
	sub.s32 	%r87, %r3, %r52;
	add.s32 	%r88, %r87, %r84;
	cvt.s64.s32 	%rd4, %r88;
	add.s64 	%rd5, %rd3, %rd4;
	mul.wide.s32 	%rd6, %r85, %r54;
	sub.s64 	%rd7, %rd6, %rd73;
	add.s32 	%r5, %r84, %r3;
	@%p6 bra 	LBB0_5;
	bra.uni 	LBB0_2;
LBB0_5:                                 // %true_bb1
	ld.param.u32 	%r142, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_3];
	ld.param.u32 	%r138, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_2];
	cvt.s64.s32 	%rd8, %r5;
	add.s64 	%rd9, %rd7, %rd8;
	setp.lt.s32 	%p7, %r138, 1;
	@%p7 bra 	LBB0_14;
// %bb.6:                               // %"for repeat_edge.s0._2.preheader"
	cvt.s64.s32 	%rd10, %r53;
	cvt.s64.s32 	%rd11, %r49;
	add.s32 	%r98, %r138, -1;
	and.b32  	%r6, %r138, 3;
	setp.lt.u32 	%p8, %r98, 3;
	@%p8 bra 	LBB0_7;
	bra.uni 	LBB0_8;
LBB0_7:
	mov.u32 	%r135, 0;
	setp.eq.s32 	%p12, %r6, 0;
	@%p12 bra 	LBB0_14;
	bra.uni 	LBB0_12;
LBB0_3:                                 // %false_bb
	ld.param.u32 	%r42, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_4];
	ld.param.u32 	%r39, [kernel_repeat_edge_s0__1__1_o___block_id_y_param_1];
	shl.b32 	%r64, %r1, 5;
	add.s32 	%r65, %r64, %r50;
	min.s32 	%r66, %r65, %r46;
	add.s32 	%r67, %r4, %r2;
	sub.s32 	%r68, %r67, %r51;
	mul.wide.s32 	%rd76, %r68, %r45;
	sub.s32 	%r69, %r3, %r52;
	add.s32 	%r70, %r69, %r66;
	cvt.s64.s32 	%rd77, %r70;
	add.s64 	%rd78, %rd76, %rd77;
	min.s32 	%r71, %r67, %r42;
	max.s32 	%r72, %r71, %r39;
	mul.wide.s32 	%rd79, %r72, %r54;
	sub.s64 	%rd80, %rd79, %rd73;
	add.s32 	%r73, %r66, %r3;
	min.s32 	%r74, %r73, %r43;
	max.s32 	%r75, %r74, %r56;
	cvt.s64.s32 	%rd81, %r75;
	add.s64 	%rd82, %rd80, %rd81;
	cvt.s64.s32 	%rd83, %r49;
	min.s32 	%r76, %r44, 0;
	max.s32 	%r77, %r76, %r55;
	mul.wide.s32 	%rd84, %r77, %r53;
	add.s64 	%rd85, %rd82, %rd84;
	add.s64 	%rd86, %rd2, %rd85;
	ld.global.nc.u8 	%rs1, [%rd86];
	cvt.u16.u8 	%rs2, %rs1;
	add.s64 	%rd87, %rd1, %rd78;
	st.global.u8 	[%rd87], %rs2;
	min.s32 	%r78, %r44, 1;
	max.s32 	%r79, %r78, %r55;
	mul.wide.s32 	%rd88, %r79, %r53;
	add.s64 	%rd89, %rd82, %rd88;
	add.s64 	%rd90, %rd2, %rd89;
	ld.global.nc.u8 	%rs3, [%rd90];
	cvt.u16.u8 	%rs4, %rs3;
	add.s64 	%rd91, %rd87, %rd83;
	st.global.u8 	[%rd91], %rs4;
	min.s32 	%r80, %r44, 2;
	max.s32 	%r81, %r80, %r55;
	mul.wide.s32 	%rd92, %r81, %r53;
	add.s64 	%rd93, %rd82, %rd92;
	add.s64 	%rd94, %rd2, %rd93;
	ld.global.nc.u8 	%rs5, [%rd94];
	cvt.u16.u8 	%rs6, %rs5;
	add.s64 	%rd95, %rd91, %rd83;
	st.global.u8 	[%rd95], %rs6;
	ret;
LBB0_2:                                 // %false_bb2
	min.s32 	%r89, %r5, %r43;
	max.s32 	%r90, %r89, %r56;
	cvt.s64.s32 	%rd96, %r90;
	add.s64 	%rd97, %rd7, %rd96;
	cvt.s64.s32 	%rd98, %r49;
	min.s32 	%r91, %r44, 0;
	max.s32 	%r92, %r91, %r55;
	mul.wide.s32 	%rd99, %r92, %r53;
	add.s64 	%rd100, %rd97, %rd99;
	add.s64 	%rd101, %rd2, %rd100;
	ld.global.nc.u8 	%rs7, [%rd101];
	cvt.u16.u8 	%rs8, %rs7;
	add.s64 	%rd102, %rd1, %rd5;
	st.global.u8 	[%rd102], %rs8;
	min.s32 	%r93, %r44, 1;
	max.s32 	%r94, %r93, %r55;
	mul.wide.s32 	%rd103, %r94, %r53;
	add.s64 	%rd104, %rd97, %rd103;
	add.s64 	%rd105, %rd2, %rd104;
	ld.global.nc.u8 	%rs9, [%rd105];
	cvt.u16.u8 	%rs10, %rs9;
	add.s64 	%rd106, %rd102, %rd98;
	st.global.u8 	[%rd106], %rs10;
	min.s32 	%r95, %r44, 2;
	max.s32 	%r96, %r95, %r55;
	mul.wide.s32 	%rd107, %r96, %r53;
	add.s64 	%rd108, %rd97, %rd107;
	add.s64 	%rd109, %rd2, %rd108;
	ld.global.nc.u8 	%rs11, [%rd109];
	cvt.u16.u8 	%rs12, %rs11;
	add.s64 	%rd110, %rd106, %rd98;
	st.global.u8 	[%rd110], %rs12;
	ret;
LBB0_8:                                 // %"for repeat_edge.s0._2.preheader.new"
	mul.lo.s64 	%rd12, %rd11, 3;
	add.s64 	%rd218, %rd1, %rd5;
	shl.b64 	%rd14, %rd11, 2;
	shl.b64 	%rd15, %rd11, 1;
	sub.s32 	%r7, %r6, %r138;
	mov.u32 	%r132, 3;
LBB0_9:                                 // %"for repeat_edge.s0._2"
                                        // =>This Inner Loop Header: Depth=1
	add.s32 	%r100, %r132, -3;
	min.s32 	%r101, %r100, %r44;
	max.s32 	%r102, %r101, %r55;
	cvt.s64.s32 	%rd111, %r102;
	mul.lo.s64 	%rd112, %rd111, %rd10;
	add.s64 	%rd113, %rd112, %rd9;
	add.s64 	%rd114, %rd2, %rd113;
	ld.global.nc.u8 	%rs13, [%rd114];
	cvt.u16.u8 	%rs14, %rs13;
	st.global.u8 	[%rd218], %rs14;
	add.s32 	%r103, %r132, -2;
	setp.lt.s32 	%p9, %r103, %r44;
	selp.b32 	%r104, %r103, %r44, %p9;
	max.s32 	%r105, %r104, %r55;
	cvt.s64.s32 	%rd115, %r105;
	mul.lo.s64 	%rd116, %rd115, %rd10;
	add.s64 	%rd117, %rd116, %rd9;
	add.s64 	%rd118, %rd2, %rd117;
	ld.global.nc.u8 	%rs15, [%rd118];
	cvt.u16.u8 	%rs16, %rs15;
	add.s64 	%rd119, %rd218, %rd11;
	st.global.u8 	[%rd119], %rs16;
	add.s32 	%r106, %r132, -1;
	setp.lt.s32 	%p10, %r106, %r44;
	selp.b32 	%r107, %r106, %r44, %p10;
	max.s32 	%r108, %r107, %r55;
	cvt.s64.s32 	%rd120, %r108;
	mul.lo.s64 	%rd121, %rd120, %rd10;
	add.s64 	%rd122, %rd121, %rd9;
	add.s64 	%rd123, %rd2, %rd122;
	ld.global.nc.u8 	%rs17, [%rd123];
	cvt.u16.u8 	%rs18, %rs17;
	add.s64 	%rd124, %rd218, %rd15;
	st.global.u8 	[%rd124], %rs18;
	min.s32 	%r109, %r132, %r44;
	max.s32 	%r110, %r109, %r55;
	cvt.s64.s32 	%rd125, %r110;
	mul.lo.s64 	%rd126, %rd125, %rd10;
	add.s64 	%rd127, %rd126, %rd9;
	add.s64 	%rd128, %rd2, %rd127;
	ld.global.nc.u8 	%rs19, [%rd128];
	cvt.u16.u8 	%rs20, %rs19;
	add.s64 	%rd129, %rd218, %rd12;
	st.global.u8 	[%rd129], %rs20;
	add.s32 	%r132, %r132, 4;
	add.s64 	%rd218, %rd218, %rd14;
	add.s32 	%r111, %r7, %r132;
	setp.ne.s32 	%p11, %r111, 3;
	@%p11 bra 	LBB0_9;
// %bb.10:                              // %"end for repeat_edge.s0._2.loopexit.unr-lcssa.loopexit"
	add.s32 	%r135, %r132, -3;
	setp.eq.s32 	%p12, %r6, 0;
	@%p12 bra 	LBB0_14;
LBB0_12:                                // %"for repeat_edge.s0._2.epil.preheader"
	cvt.u64.u32 	%rd130, %r135;
	mul.lo.s64 	%rd131, %rd11, %rd130;
	add.s64 	%rd132, %rd3, %rd131;
	add.s64 	%rd133, %rd132, %rd4;
	add.s64 	%rd219, %rd1, %rd133;
	neg.s32 	%r134, %r6;
LBB0_13:                                // %"for repeat_edge.s0._2.epil"
                                        // =>This Inner Loop Header: Depth=1
	.pragma "nounroll";
	min.s32 	%r112, %r135, %r44;
	max.s32 	%r113, %r112, %r55;
	cvt.s64.s32 	%rd134, %r113;
	mul.lo.s64 	%rd135, %rd134, %rd10;
	add.s64 	%rd136, %rd135, %rd9;
	add.s64 	%rd137, %rd2, %rd136;
	ld.global.nc.u8 	%rs21, [%rd137];
	cvt.u16.u8 	%rs22, %rs21;
	st.global.u8 	[%rd219], %rs22;
	add.s32 	%r135, %r135, 1;
	add.s64 	%rd219, %rd219, %rd11;
	add.s32 	%r134, %r134, 1;
	setp.ne.s32 	%p13, %r134, 0;
	@%p13 bra 	LBB0_13;
LBB0_14:                                // %"end for repeat_edge.s0._2"
	setp.le.s32 	%p14, %r142, %r138;
	@%p14 bra 	LBB0_21;
// %bb.15:                              // %"for repeat_edge.s0._24.preheader"
	cvt.s64.s32 	%rd21, %r53;
	cvt.s64.s32 	%rd22, %r49;
	sub.s32 	%r114, %r142, %r138;
	add.s32 	%r115, %r142, -1;
	sub.s32 	%r17, %r115, %r138;
	and.b32  	%r18, %r114, 3;
	setp.eq.s32 	%p15, %r18, 0;
	@%p15 bra 	LBB0_18;
// %bb.16:                              // %"for repeat_edge.s0._24.prol.preheader"
	cvt.s64.s32 	%rd138, %r138;
	mul.lo.s64 	%rd139, %rd22, %rd138;
	add.s64 	%rd140, %rd139, %rd3;
	add.s64 	%rd141, %rd140, %rd4;
	add.s64 	%rd221, %rd1, %rd141;
	mul.lo.s64 	%rd142, %rd21, %rd138;
	add.s64 	%rd143, %rd142, %rd6;
	add.s64 	%rd144, %rd143, %rd8;
	sub.s64 	%rd145, %rd144, %rd73;
	add.s64 	%rd220, %rd2, %rd145;
	neg.s32 	%r136, %r18;
LBB0_17:                                // %"for repeat_edge.s0._24.prol"
                                        // =>This Inner Loop Header: Depth=1
	.pragma "nounroll";
	ld.global.nc.u8 	%rs23, [%rd220];
	cvt.u16.u8 	%rs24, %rs23;
	st.global.u8 	[%rd221], %rs24;
	add.s32 	%r138, %r138, 1;
	add.s64 	%rd221, %rd221, %rd22;
	add.s64 	%rd220, %rd220, %rd21;
	add.s32 	%r136, %r136, 1;
	setp.ne.s32 	%p16, %r136, 0;
	@%p16 bra 	LBB0_17;
LBB0_18:                                // %"for repeat_edge.s0._24.prol.loopexit"
	setp.lt.u32 	%p17, %r17, 3;
	@%p17 bra 	LBB0_21;
// %bb.19:                              // %"for repeat_edge.s0._24.preheader.new"
	sub.s32 	%r139, %r142, %r138;
	cvt.s64.s32 	%rd146, %r138;
	add.s64 	%rd147, %rd146, 3;
	mul.lo.s64 	%rd148, %rd147, %rd22;
	add.s64 	%rd149, %rd148, %rd3;
	add.s64 	%rd229, %rd1, %rd149;
	shl.b64 	%rd30, %rd22, 2;
	mul.lo.s64 	%rd150, %rd147, %rd21;
	add.s64 	%rd151, %rd150, %rd6;
	sub.s64 	%rd152, %rd151, %rd73;
	add.s64 	%rd228, %rd2, %rd152;
	shl.b64 	%rd32, %rd21, 2;
	add.s64 	%rd153, %rd146, 2;
	mul.lo.s64 	%rd154, %rd153, %rd22;
	add.s64 	%rd155, %rd154, %rd3;
	add.s64 	%rd227, %rd1, %rd155;
	mul.lo.s64 	%rd156, %rd153, %rd21;
	add.s64 	%rd157, %rd156, %rd6;
	sub.s64 	%rd158, %rd157, %rd73;
	add.s64 	%rd226, %rd2, %rd158;
	add.s64 	%rd159, %rd146, 1;
	mul.lo.s64 	%rd160, %rd159, %rd22;
	add.s64 	%rd161, %rd160, %rd3;
	add.s64 	%rd225, %rd1, %rd161;
	mul.lo.s64 	%rd162, %rd159, %rd21;
	add.s64 	%rd163, %rd162, %rd6;
	sub.s64 	%rd164, %rd163, %rd73;
	add.s64 	%rd224, %rd2, %rd164;
	mul.lo.s64 	%rd165, %rd146, %rd22;
	add.s64 	%rd166, %rd165, %rd3;
	add.s64 	%rd223, %rd1, %rd166;
	mul.lo.s64 	%rd167, %rd146, %rd21;
	add.s64 	%rd168, %rd167, %rd6;
	sub.s64 	%rd169, %rd168, %rd73;
	add.s64 	%rd222, %rd2, %rd169;
LBB0_20:                                // %"for repeat_edge.s0._24"
                                        // =>This Inner Loop Header: Depth=1
	add.s64 	%rd170, %rd222, %rd8;
	ld.global.nc.u8 	%rs25, [%rd170];
	cvt.u16.u8 	%rs26, %rs25;
	add.s64 	%rd171, %rd223, %rd4;
	st.global.u8 	[%rd171], %rs26;
	add.s64 	%rd172, %rd224, %rd8;
	ld.global.nc.u8 	%rs27, [%rd172];
	cvt.u16.u8 	%rs28, %rs27;
	add.s64 	%rd173, %rd225, %rd4;
	st.global.u8 	[%rd173], %rs28;
	add.s64 	%rd174, %rd226, %rd8;
	ld.global.nc.u8 	%rs29, [%rd174];
	cvt.u16.u8 	%rs30, %rs29;
	add.s64 	%rd175, %rd227, %rd4;
	st.global.u8 	[%rd175], %rs30;
	add.s64 	%rd176, %rd228, %rd8;
	ld.global.nc.u8 	%rs31, [%rd176];
	cvt.u16.u8 	%rs32, %rs31;
	add.s64 	%rd177, %rd229, %rd4;
	st.global.u8 	[%rd177], %rs32;
	add.s32 	%r139, %r139, -4;
	add.s64 	%rd229, %rd229, %rd30;
	add.s64 	%rd228, %rd228, %rd32;
	add.s64 	%rd227, %rd227, %rd30;
	add.s64 	%rd226, %rd226, %rd32;
	add.s64 	%rd225, %rd225, %rd30;
	add.s64 	%rd224, %rd224, %rd32;
	add.s64 	%rd223, %rd223, %rd30;
	add.s64 	%rd222, %rd222, %rd32;
	setp.ne.s32 	%p18, %r139, 0;
	@%p18 bra 	LBB0_20;
LBB0_21:                                // %"end for repeat_edge.s0._25"
	setp.gt.s32 	%p19, %r142, 2;
	@%p19 bra 	LBB0_4;
// %bb.22:                              // %"for repeat_edge.s0._26.preheader"
	cvt.s64.s32 	%rd55, %r53;
	cvt.s64.s32 	%rd56, %r49;
	mov.u32 	%r116, 3;
	sub.s32 	%r117, %r116, %r142;
	mov.u32 	%r118, 2;
	sub.s32 	%r28, %r118, %r142;
	and.b32  	%r29, %r117, 3;
	setp.eq.s32 	%p20, %r29, 0;
	@%p20 bra 	LBB0_25;
// %bb.23:                              // %"for repeat_edge.s0._26.prol.preheader"
	cvt.s64.s32 	%rd178, %r142;
	mul.lo.s64 	%rd179, %rd56, %rd178;
	add.s64 	%rd180, %rd179, %rd3;
	add.s64 	%rd181, %rd180, %rd4;
	add.s64 	%rd230, %rd1, %rd181;
	neg.s32 	%r140, %r29;
LBB0_24:                                // %"for repeat_edge.s0._26.prol"
                                        // =>This Inner Loop Header: Depth=1
	.pragma "nounroll";
	min.s32 	%r119, %r142, %r44;
	max.s32 	%r120, %r119, %r55;
	cvt.s64.s32 	%rd182, %r120;
	mul.lo.s64 	%rd183, %rd182, %rd55;
	add.s64 	%rd184, %rd183, %rd9;
	add.s64 	%rd185, %rd2, %rd184;
	ld.global.nc.u8 	%rs33, [%rd185];
	cvt.u16.u8 	%rs34, %rs33;
	st.global.u8 	[%rd230], %rs34;
	add.s32 	%r142, %r142, 1;
	add.s64 	%rd230, %rd230, %rd56;
	add.s32 	%r140, %r140, 1;
	setp.ne.s32 	%p21, %r140, 0;
	@%p21 bra 	LBB0_24;
LBB0_25:                                // %"for repeat_edge.s0._26.prol.loopexit"
	setp.lt.u32 	%p22, %r28, 3;
	@%p22 bra 	LBB0_4;
// %bb.26:                              // %"for repeat_edge.s0._26.preheader.new"
	cvt.s64.s32 	%rd186, %r142;
	add.s64 	%rd187, %rd186, 3;
	mul.lo.s64 	%rd188, %rd187, %rd56;
	add.s64 	%rd189, %rd188, %rd3;
	add.s64 	%rd234, %rd1, %rd189;
	shl.b64 	%rd61, %rd56, 2;
	add.s32 	%r143, %r142, 3;
	add.s64 	%rd190, %rd186, 2;
	mul.lo.s64 	%rd191, %rd190, %rd56;
	add.s64 	%rd192, %rd191, %rd3;
	add.s64 	%rd233, %rd1, %rd192;
	add.s64 	%rd193, %rd186, 1;
	mul.lo.s64 	%rd194, %rd193, %rd56;
	add.s64 	%rd195, %rd194, %rd3;
	add.s64 	%rd232, %rd1, %rd195;
	mul.lo.s64 	%rd196, %rd186, %rd56;
	add.s64 	%rd197, %rd196, %rd3;
	add.s64 	%rd231, %rd1, %rd197;
LBB0_27:                                // %"for repeat_edge.s0._26"
                                        // =>This Inner Loop Header: Depth=1
	add.s32 	%r121, %r143, -3;
	min.s32 	%r122, %r121, %r44;
	max.s32 	%r123, %r122, %r55;
	cvt.s64.s32 	%rd198, %r123;
	mul.lo.s64 	%rd199, %rd198, %rd55;
	add.s64 	%rd200, %rd199, %rd9;
	add.s64 	%rd201, %rd2, %rd200;
	ld.global.nc.u8 	%rs35, [%rd201];
	cvt.u16.u8 	%rs36, %rs35;
	add.s64 	%rd202, %rd231, %rd4;
	st.global.u8 	[%rd202], %rs36;
	add.s32 	%r124, %r143, -2;
	setp.lt.s32 	%p23, %r124, %r44;
	selp.b32 	%r125, %r124, %r44, %p23;
	max.s32 	%r126, %r125, %r55;
	cvt.s64.s32 	%rd203, %r126;
	mul.lo.s64 	%rd204, %rd203, %rd55;
	add.s64 	%rd205, %rd204, %rd9;
	add.s64 	%rd206, %rd2, %rd205;
	ld.global.nc.u8 	%rs37, [%rd206];
	cvt.u16.u8 	%rs38, %rs37;
	add.s64 	%rd207, %rd232, %rd4;
	st.global.u8 	[%rd207], %rs38;
	add.s32 	%r127, %r143, -1;
	setp.lt.s32 	%p24, %r127, %r44;
	selp.b32 	%r128, %r127, %r44, %p24;
	max.s32 	%r129, %r128, %r55;
	cvt.s64.s32 	%rd208, %r129;
	mul.lo.s64 	%rd209, %rd208, %rd55;
	add.s64 	%rd210, %rd209, %rd9;
	add.s64 	%rd211, %rd2, %rd210;
	ld.global.nc.u8 	%rs39, [%rd211];
	cvt.u16.u8 	%rs40, %rs39;
	add.s64 	%rd212, %rd233, %rd4;
	st.global.u8 	[%rd212], %rs40;
	min.s32 	%r130, %r143, %r44;
	max.s32 	%r131, %r130, %r55;
	cvt.s64.s32 	%rd213, %r131;
	mul.lo.s64 	%rd214, %rd213, %rd55;
	add.s64 	%rd215, %rd214, %rd9;
	add.s64 	%rd216, %rd2, %rd215;
	ld.global.nc.u8 	%rs41, [%rd216];
	cvt.u16.u8 	%rs42, %rs41;
	add.s64 	%rd217, %rd234, %rd4;
	st.global.u8 	[%rd217], %rs42;
	add.s64 	%rd234, %rd234, %rd61;
	add.s32 	%r38, %r143, 4;
	add.s64 	%rd233, %rd233, %rd61;
	add.s64 	%rd232, %rd232, %rd61;
	add.s64 	%rd231, %rd231, %rd61;
	setp.eq.s32 	%p25, %r143, 2;
	mov.u32 	%r143, %r38;
	@%p25 bra 	LBB0_4;
	bra.uni 	LBB0_27;
LBB0_4:                                 // %after_bb
	ret;
}
                                        // -- End function
	// .globl	kernel_repeat_edge_1_s0__1__1_o___block_id_y // -- Begin function kernel_repeat_edge_1_s0__1__1_o___block_id_y
.visible .entry kernel_repeat_edge_1_s0__1__1_o___block_id_y(
	.param .u64 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_0,
	.param .u32 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_1,
	.param .u32 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_2,
	.param .u32 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_3,
	.param .u32 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_4,
	.param .u32 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_5,
	.param .u32 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_6,
	.param .u32 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_7,
	.param .u32 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_8,
	.param .u32 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_9,
	.param .u32 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_10,
	.param .u32 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_11,
	.param .u32 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_12,
	.param .u32 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_13,
	.param .u32 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_14,
	.param .u32 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_15,
	.param .u32 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_16,
	.param .u32 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_17,
	.param .u32 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_18,
	.param .u32 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_19,
	.param .u32 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_20,
	.param .u32 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_21,
	.param .u32 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_22,
	.param .u64 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_23,
	.param .u64 kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_24
)                                       // @kernel_repeat_edge_1_s0__1__1_o___block_id_y
{
	.reg .pred 	%p<26>;
	.reg .b16 	%rs<43>;
	.reg .b32 	%r<144>;
	.reg .b64 	%rd<235>;

// %bb.0:                               // %entry
	ld.param.u32 	%r56, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_22];
	ld.param.u32 	%r55, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_21];
	ld.param.u32 	%r54, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_20];
	ld.param.u32 	%r53, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_17];
	ld.param.u32 	%r51, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_15];
	ld.param.u32 	%r50, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_14];
	ld.param.u32 	%r49, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_13];
	ld.param.u32 	%r46, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_9];
	ld.param.u32 	%r45, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_8];
	ld.param.u32 	%r44, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_7];
	ld.param.u32 	%r43, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_6];
	ld.param.u32 	%r41, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_4];
	ld.param.u64 	%rd73, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_0];
	ld.param.u64 	%rd74, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_24];
	cvta.to.global.u64 	%rd1, %rd74;
	ld.param.u32 	%r57, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_1];
	ld.param.u64 	%rd75, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_23];
	cvta.to.global.u64 	%rd2, %rd75;
	mov.u32 	%r58, %ctaid.y;
	mov.u32 	%r1, %ctaid.x;
	mov.u32 	%r2, %tid.y;
	mov.u32 	%r3, %tid.x;
	ld.param.u32 	%r59, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_18];
	setp.lt.s32 	%p1, %r58, %r59;
	ld.param.u32 	%r60, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_19];
	setp.ge.s32 	%p2, %r58, %r60;
	shl.b32 	%r61, %r58, 3;
	ld.param.u32 	%r62, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_10];
	add.s32 	%r63, %r61, %r57;
	min.s32 	%r4, %r63, %r62;
	or.pred  	%p3, %p1, %p2;
	@%p3 bra 	LBB1_3;
// %bb.1:                               // %true_bb
	ld.param.u32 	%r48, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_12];
	ld.param.u32 	%r47, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_11];
	setp.ge.s32 	%p4, %r1, %r48;
	setp.lt.s32 	%p5, %r1, %r47;
	and.pred  	%p6, %p4, %p5;
	shl.b32 	%r82, %r1, 5;
	add.s32 	%r83, %r82, %r56;
	min.s32 	%r84, %r83, %r46;
	add.s32 	%r85, %r4, %r2;
	sub.s32 	%r86, %r85, %r54;
	mul.wide.s32 	%rd3, %r86, %r41;
	sub.s32 	%r87, %r3, %r55;
	add.s32 	%r88, %r87, %r84;
	cvt.s64.s32 	%rd4, %r88;
	add.s64 	%rd5, %rd3, %rd4;
	mul.wide.s32 	%rd6, %r85, %r50;
	sub.s64 	%rd7, %rd6, %rd73;
	add.s32 	%r5, %r84, %r3;
	@%p6 bra 	LBB1_5;
	bra.uni 	LBB1_2;
LBB1_5:                                 // %true_bb1
	ld.param.u32 	%r142, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_3];
	ld.param.u32 	%r138, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_2];
	cvt.s64.s32 	%rd8, %r5;
	add.s64 	%rd9, %rd7, %rd8;
	setp.lt.s32 	%p7, %r138, 1;
	@%p7 bra 	LBB1_14;
// %bb.6:                               // %"for repeat_edge$1.s0._2.preheader"
	cvt.s64.s32 	%rd10, %r49;
	cvt.s64.s32 	%rd11, %r45;
	add.s32 	%r98, %r138, -1;
	and.b32  	%r6, %r138, 3;
	setp.lt.u32 	%p8, %r98, 3;
	@%p8 bra 	LBB1_7;
	bra.uni 	LBB1_8;
LBB1_7:
	mov.u32 	%r135, 0;
	setp.eq.s32 	%p12, %r6, 0;
	@%p12 bra 	LBB1_14;
	bra.uni 	LBB1_12;
LBB1_3:                                 // %false_bb
	ld.param.u32 	%r52, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_16];
	ld.param.u32 	%r42, [kernel_repeat_edge_1_s0__1__1_o___block_id_y_param_5];
	shl.b32 	%r64, %r1, 5;
	add.s32 	%r65, %r64, %r56;
	min.s32 	%r66, %r65, %r46;
	add.s32 	%r67, %r4, %r2;
	sub.s32 	%r68, %r67, %r54;
	mul.wide.s32 	%rd76, %r68, %r41;
	sub.s32 	%r69, %r3, %r55;
	add.s32 	%r70, %r69, %r66;
	cvt.s64.s32 	%rd77, %r70;
	add.s64 	%rd78, %rd76, %rd77;
	min.s32 	%r71, %r67, %r42;
	max.s32 	%r72, %r71, %r52;
	mul.wide.s32 	%rd79, %r72, %r50;
	sub.s64 	%rd80, %rd79, %rd73;
	add.s32 	%r73, %r66, %r3;
	min.s32 	%r74, %r73, %r43;
	max.s32 	%r75, %r74, %r53;
	cvt.s64.s32 	%rd81, %r75;
	add.s64 	%rd82, %rd80, %rd81;
	cvt.s64.s32 	%rd83, %r45;
	min.s32 	%r76, %r44, 0;
	max.s32 	%r77, %r76, %r51;
	mul.wide.s32 	%rd84, %r77, %r49;
	add.s64 	%rd85, %rd82, %rd84;
	add.s64 	%rd86, %rd1, %rd85;
	ld.global.nc.u8 	%rs1, [%rd86];
	cvt.u16.u8 	%rs2, %rs1;
	add.s64 	%rd87, %rd2, %rd78;
	st.global.u8 	[%rd87], %rs2;
	min.s32 	%r78, %r44, 1;
	max.s32 	%r79, %r78, %r51;
	mul.wide.s32 	%rd88, %r79, %r49;
	add.s64 	%rd89, %rd82, %rd88;
	add.s64 	%rd90, %rd1, %rd89;
	ld.global.nc.u8 	%rs3, [%rd90];
	cvt.u16.u8 	%rs4, %rs3;
	add.s64 	%rd91, %rd87, %rd83;
	st.global.u8 	[%rd91], %rs4;
	min.s32 	%r80, %r44, 2;
	max.s32 	%r81, %r80, %r51;
	mul.wide.s32 	%rd92, %r81, %r49;
	add.s64 	%rd93, %rd82, %rd92;
	add.s64 	%rd94, %rd1, %rd93;
	ld.global.nc.u8 	%rs5, [%rd94];
	cvt.u16.u8 	%rs6, %rs5;
	add.s64 	%rd95, %rd91, %rd83;
	st.global.u8 	[%rd95], %rs6;
	ret;
LBB1_2:                                 // %false_bb2
	min.s32 	%r89, %r5, %r43;
	max.s32 	%r90, %r89, %r53;
	cvt.s64.s32 	%rd96, %r90;
	add.s64 	%rd97, %rd7, %rd96;
	cvt.s64.s32 	%rd98, %r45;
	min.s32 	%r91, %r44, 0;
	max.s32 	%r92, %r91, %r51;
	mul.wide.s32 	%rd99, %r92, %r49;
	add.s64 	%rd100, %rd97, %rd99;
	add.s64 	%rd101, %rd1, %rd100;
	ld.global.nc.u8 	%rs7, [%rd101];
	cvt.u16.u8 	%rs8, %rs7;
	add.s64 	%rd102, %rd2, %rd5;
	st.global.u8 	[%rd102], %rs8;
	min.s32 	%r93, %r44, 1;
	max.s32 	%r94, %r93, %r51;
	mul.wide.s32 	%rd103, %r94, %r49;
	add.s64 	%rd104, %rd97, %rd103;
	add.s64 	%rd105, %rd1, %rd104;
	ld.global.nc.u8 	%rs9, [%rd105];
	cvt.u16.u8 	%rs10, %rs9;
	add.s64 	%rd106, %rd102, %rd98;
	st.global.u8 	[%rd106], %rs10;
	min.s32 	%r95, %r44, 2;
	max.s32 	%r96, %r95, %r51;
	mul.wide.s32 	%rd107, %r96, %r49;
	add.s64 	%rd108, %rd97, %rd107;
	add.s64 	%rd109, %rd1, %rd108;
	ld.global.nc.u8 	%rs11, [%rd109];
	cvt.u16.u8 	%rs12, %rs11;
	add.s64 	%rd110, %rd106, %rd98;
	st.global.u8 	[%rd110], %rs12;
	ret;
LBB1_8:                                 // %"for repeat_edge$1.s0._2.preheader.new"
	mul.lo.s64 	%rd12, %rd11, 3;
	add.s64 	%rd218, %rd2, %rd5;
	shl.b64 	%rd14, %rd11, 2;
	shl.b64 	%rd15, %rd11, 1;
	sub.s32 	%r7, %r6, %r138;
	mov.u32 	%r132, 3;
LBB1_9:                                 // %"for repeat_edge$1.s0._2"
                                        // =>This Inner Loop Header: Depth=1
	add.s32 	%r100, %r132, -3;
	min.s32 	%r101, %r100, %r44;
	max.s32 	%r102, %r101, %r51;
	cvt.s64.s32 	%rd111, %r102;
	mul.lo.s64 	%rd112, %rd111, %rd10;
	add.s64 	%rd113, %rd112, %rd9;
	add.s64 	%rd114, %rd1, %rd113;
	ld.global.nc.u8 	%rs13, [%rd114];
	cvt.u16.u8 	%rs14, %rs13;
	st.global.u8 	[%rd218], %rs14;
	add.s32 	%r103, %r132, -2;
	setp.lt.s32 	%p9, %r103, %r44;
	selp.b32 	%r104, %r103, %r44, %p9;
	max.s32 	%r105, %r104, %r51;
	cvt.s64.s32 	%rd115, %r105;
	mul.lo.s64 	%rd116, %rd115, %rd10;
	add.s64 	%rd117, %rd116, %rd9;
	add.s64 	%rd118, %rd1, %rd117;
	ld.global.nc.u8 	%rs15, [%rd118];
	cvt.u16.u8 	%rs16, %rs15;
	add.s64 	%rd119, %rd218, %rd11;
	st.global.u8 	[%rd119], %rs16;
	add.s32 	%r106, %r132, -1;
	setp.lt.s32 	%p10, %r106, %r44;
	selp.b32 	%r107, %r106, %r44, %p10;
	max.s32 	%r108, %r107, %r51;
	cvt.s64.s32 	%rd120, %r108;
	mul.lo.s64 	%rd121, %rd120, %rd10;
	add.s64 	%rd122, %rd121, %rd9;
	add.s64 	%rd123, %rd1, %rd122;
	ld.global.nc.u8 	%rs17, [%rd123];
	cvt.u16.u8 	%rs18, %rs17;
	add.s64 	%rd124, %rd218, %rd15;
	st.global.u8 	[%rd124], %rs18;
	min.s32 	%r109, %r132, %r44;
	max.s32 	%r110, %r109, %r51;
	cvt.s64.s32 	%rd125, %r110;
	mul.lo.s64 	%rd126, %rd125, %rd10;
	add.s64 	%rd127, %rd126, %rd9;
	add.s64 	%rd128, %rd1, %rd127;
	ld.global.nc.u8 	%rs19, [%rd128];
	cvt.u16.u8 	%rs20, %rs19;
	add.s64 	%rd129, %rd218, %rd12;
	st.global.u8 	[%rd129], %rs20;
	add.s32 	%r132, %r132, 4;
	add.s64 	%rd218, %rd218, %rd14;
	add.s32 	%r111, %r7, %r132;
	setp.ne.s32 	%p11, %r111, 3;
	@%p11 bra 	LBB1_9;
// %bb.10:                              // %"end for repeat_edge$1.s0._2.loopexit.unr-lcssa.loopexit"
	add.s32 	%r135, %r132, -3;
	setp.eq.s32 	%p12, %r6, 0;
	@%p12 bra 	LBB1_14;
LBB1_12:                                // %"for repeat_edge$1.s0._2.epil.preheader"
	cvt.u64.u32 	%rd130, %r135;
	mul.lo.s64 	%rd131, %rd11, %rd130;
	add.s64 	%rd132, %rd3, %rd131;
	add.s64 	%rd133, %rd132, %rd4;
	add.s64 	%rd219, %rd2, %rd133;
	neg.s32 	%r134, %r6;
LBB1_13:                                // %"for repeat_edge$1.s0._2.epil"
                                        // =>This Inner Loop Header: Depth=1
	.pragma "nounroll";
	min.s32 	%r112, %r135, %r44;
	max.s32 	%r113, %r112, %r51;
	cvt.s64.s32 	%rd134, %r113;
	mul.lo.s64 	%rd135, %rd134, %rd10;
	add.s64 	%rd136, %rd135, %rd9;
	add.s64 	%rd137, %rd1, %rd136;
	ld.global.nc.u8 	%rs21, [%rd137];
	cvt.u16.u8 	%rs22, %rs21;
	st.global.u8 	[%rd219], %rs22;
	add.s32 	%r135, %r135, 1;
	add.s64 	%rd219, %rd219, %rd11;
	add.s32 	%r134, %r134, 1;
	setp.ne.s32 	%p13, %r134, 0;
	@%p13 bra 	LBB1_13;
LBB1_14:                                // %"end for repeat_edge$1.s0._2"
	setp.le.s32 	%p14, %r142, %r138;
	@%p14 bra 	LBB1_21;
// %bb.15:                              // %"for repeat_edge$1.s0._24.preheader"
	cvt.s64.s32 	%rd21, %r49;
	cvt.s64.s32 	%rd22, %r45;
	sub.s32 	%r114, %r142, %r138;
	add.s32 	%r115, %r142, -1;
	sub.s32 	%r17, %r115, %r138;
	and.b32  	%r18, %r114, 3;
	setp.eq.s32 	%p15, %r18, 0;
	@%p15 bra 	LBB1_18;
// %bb.16:                              // %"for repeat_edge$1.s0._24.prol.preheader"
	cvt.s64.s32 	%rd138, %r138;
	mul.lo.s64 	%rd139, %rd22, %rd138;
	add.s64 	%rd140, %rd139, %rd3;
	add.s64 	%rd141, %rd140, %rd4;
	add.s64 	%rd221, %rd2, %rd141;
	mul.lo.s64 	%rd142, %rd21, %rd138;
	add.s64 	%rd143, %rd142, %rd6;
	add.s64 	%rd144, %rd143, %rd8;
	sub.s64 	%rd145, %rd144, %rd73;
	add.s64 	%rd220, %rd1, %rd145;
	neg.s32 	%r136, %r18;
LBB1_17:                                // %"for repeat_edge$1.s0._24.prol"
                                        // =>This Inner Loop Header: Depth=1
	.pragma "nounroll";
	ld.global.nc.u8 	%rs23, [%rd220];
	cvt.u16.u8 	%rs24, %rs23;
	st.global.u8 	[%rd221], %rs24;
	add.s32 	%r138, %r138, 1;
	add.s64 	%rd221, %rd221, %rd22;
	add.s64 	%rd220, %rd220, %rd21;
	add.s32 	%r136, %r136, 1;
	setp.ne.s32 	%p16, %r136, 0;
	@%p16 bra 	LBB1_17;
LBB1_18:                                // %"for repeat_edge$1.s0._24.prol.loopexit"
	setp.lt.u32 	%p17, %r17, 3;
	@%p17 bra 	LBB1_21;
// %bb.19:                              // %"for repeat_edge$1.s0._24.preheader.new"
	sub.s32 	%r139, %r142, %r138;
	cvt.s64.s32 	%rd146, %r138;
	add.s64 	%rd147, %rd146, 3;
	mul.lo.s64 	%rd148, %rd147, %rd22;
	add.s64 	%rd149, %rd148, %rd3;
	add.s64 	%rd229, %rd2, %rd149;
	shl.b64 	%rd30, %rd22, 2;
	mul.lo.s64 	%rd150, %rd147, %rd21;
	add.s64 	%rd151, %rd150, %rd6;
	sub.s64 	%rd152, %rd151, %rd73;
	add.s64 	%rd228, %rd1, %rd152;
	shl.b64 	%rd32, %rd21, 2;
	add.s64 	%rd153, %rd146, 2;
	mul.lo.s64 	%rd154, %rd153, %rd22;
	add.s64 	%rd155, %rd154, %rd3;
	add.s64 	%rd227, %rd2, %rd155;
	mul.lo.s64 	%rd156, %rd153, %rd21;
	add.s64 	%rd157, %rd156, %rd6;
	sub.s64 	%rd158, %rd157, %rd73;
	add.s64 	%rd226, %rd1, %rd158;
	add.s64 	%rd159, %rd146, 1;
	mul.lo.s64 	%rd160, %rd159, %rd22;
	add.s64 	%rd161, %rd160, %rd3;
	add.s64 	%rd225, %rd2, %rd161;
	mul.lo.s64 	%rd162, %rd159, %rd21;
	add.s64 	%rd163, %rd162, %rd6;
	sub.s64 	%rd164, %rd163, %rd73;
	add.s64 	%rd224, %rd1, %rd164;
	mul.lo.s64 	%rd165, %rd146, %rd22;
	add.s64 	%rd166, %rd165, %rd3;
	add.s64 	%rd223, %rd2, %rd166;
	mul.lo.s64 	%rd167, %rd146, %rd21;
	add.s64 	%rd168, %rd167, %rd6;
	sub.s64 	%rd169, %rd168, %rd73;
	add.s64 	%rd222, %rd1, %rd169;
LBB1_20:                                // %"for repeat_edge$1.s0._24"
                                        // =>This Inner Loop Header: Depth=1
	add.s64 	%rd170, %rd222, %rd8;
	ld.global.nc.u8 	%rs25, [%rd170];
	cvt.u16.u8 	%rs26, %rs25;
	add.s64 	%rd171, %rd223, %rd4;
	st.global.u8 	[%rd171], %rs26;
	add.s64 	%rd172, %rd224, %rd8;
	ld.global.nc.u8 	%rs27, [%rd172];
	cvt.u16.u8 	%rs28, %rs27;
	add.s64 	%rd173, %rd225, %rd4;
	st.global.u8 	[%rd173], %rs28;
	add.s64 	%rd174, %rd226, %rd8;
	ld.global.nc.u8 	%rs29, [%rd174];
	cvt.u16.u8 	%rs30, %rs29;
	add.s64 	%rd175, %rd227, %rd4;
	st.global.u8 	[%rd175], %rs30;
	add.s64 	%rd176, %rd228, %rd8;
	ld.global.nc.u8 	%rs31, [%rd176];
	cvt.u16.u8 	%rs32, %rs31;
	add.s64 	%rd177, %rd229, %rd4;
	st.global.u8 	[%rd177], %rs32;
	add.s32 	%r139, %r139, -4;
	add.s64 	%rd229, %rd229, %rd30;
	add.s64 	%rd228, %rd228, %rd32;
	add.s64 	%rd227, %rd227, %rd30;
	add.s64 	%rd226, %rd226, %rd32;
	add.s64 	%rd225, %rd225, %rd30;
	add.s64 	%rd224, %rd224, %rd32;
	add.s64 	%rd223, %rd223, %rd30;
	add.s64 	%rd222, %rd222, %rd32;
	setp.ne.s32 	%p18, %r139, 0;
	@%p18 bra 	LBB1_20;
LBB1_21:                                // %"end for repeat_edge$1.s0._25"
	setp.gt.s32 	%p19, %r142, 2;
	@%p19 bra 	LBB1_4;
// %bb.22:                              // %"for repeat_edge$1.s0._26.preheader"
	cvt.s64.s32 	%rd55, %r49;
	cvt.s64.s32 	%rd56, %r45;
	mov.u32 	%r116, 3;
	sub.s32 	%r117, %r116, %r142;
	mov.u32 	%r118, 2;
	sub.s32 	%r28, %r118, %r142;
	and.b32  	%r29, %r117, 3;
	setp.eq.s32 	%p20, %r29, 0;
	@%p20 bra 	LBB1_25;
// %bb.23:                              // %"for repeat_edge$1.s0._26.prol.preheader"
	cvt.s64.s32 	%rd178, %r142;
	mul.lo.s64 	%rd179, %rd56, %rd178;
	add.s64 	%rd180, %rd179, %rd3;
	add.s64 	%rd181, %rd180, %rd4;
	add.s64 	%rd230, %rd2, %rd181;
	neg.s32 	%r140, %r29;
LBB1_24:                                // %"for repeat_edge$1.s0._26.prol"
                                        // =>This Inner Loop Header: Depth=1
	.pragma "nounroll";
	min.s32 	%r119, %r142, %r44;
	max.s32 	%r120, %r119, %r51;
	cvt.s64.s32 	%rd182, %r120;
	mul.lo.s64 	%rd183, %rd182, %rd55;
	add.s64 	%rd184, %rd183, %rd9;
	add.s64 	%rd185, %rd1, %rd184;
	ld.global.nc.u8 	%rs33, [%rd185];
	cvt.u16.u8 	%rs34, %rs33;
	st.global.u8 	[%rd230], %rs34;
	add.s32 	%r142, %r142, 1;
	add.s64 	%rd230, %rd230, %rd56;
	add.s32 	%r140, %r140, 1;
	setp.ne.s32 	%p21, %r140, 0;
	@%p21 bra 	LBB1_24;
LBB1_25:                                // %"for repeat_edge$1.s0._26.prol.loopexit"
	setp.lt.u32 	%p22, %r28, 3;
	@%p22 bra 	LBB1_4;
// %bb.26:                              // %"for repeat_edge$1.s0._26.preheader.new"
	cvt.s64.s32 	%rd186, %r142;
	add.s64 	%rd187, %rd186, 3;
	mul.lo.s64 	%rd188, %rd187, %rd56;
	add.s64 	%rd189, %rd188, %rd3;
	add.s64 	%rd234, %rd2, %rd189;
	shl.b64 	%rd61, %rd56, 2;
	add.s32 	%r143, %r142, 3;
	add.s64 	%rd190, %rd186, 2;
	mul.lo.s64 	%rd191, %rd190, %rd56;
	add.s64 	%rd192, %rd191, %rd3;
	add.s64 	%rd233, %rd2, %rd192;
	add.s64 	%rd193, %rd186, 1;
	mul.lo.s64 	%rd194, %rd193, %rd56;
	add.s64 	%rd195, %rd194, %rd3;
	add.s64 	%rd232, %rd2, %rd195;
	mul.lo.s64 	%rd196, %rd186, %rd56;
	add.s64 	%rd197, %rd196, %rd3;
	add.s64 	%rd231, %rd2, %rd197;
LBB1_27:                                // %"for repeat_edge$1.s0._26"
                                        // =>This Inner Loop Header: Depth=1
	add.s32 	%r121, %r143, -3;
	min.s32 	%r122, %r121, %r44;
	max.s32 	%r123, %r122, %r51;
	cvt.s64.s32 	%rd198, %r123;
	mul.lo.s64 	%rd199, %rd198, %rd55;
	add.s64 	%rd200, %rd199, %rd9;
	add.s64 	%rd201, %rd1, %rd200;
	ld.global.nc.u8 	%rs35, [%rd201];
	cvt.u16.u8 	%rs36, %rs35;
	add.s64 	%rd202, %rd231, %rd4;
	st.global.u8 	[%rd202], %rs36;
	add.s32 	%r124, %r143, -2;
	setp.lt.s32 	%p23, %r124, %r44;
	selp.b32 	%r125, %r124, %r44, %p23;
	max.s32 	%r126, %r125, %r51;
	cvt.s64.s32 	%rd203, %r126;
	mul.lo.s64 	%rd204, %rd203, %rd55;
	add.s64 	%rd205, %rd204, %rd9;
	add.s64 	%rd206, %rd1, %rd205;
	ld.global.nc.u8 	%rs37, [%rd206];
	cvt.u16.u8 	%rs38, %rs37;
	add.s64 	%rd207, %rd232, %rd4;
	st.global.u8 	[%rd207], %rs38;
	add.s32 	%r127, %r143, -1;
	setp.lt.s32 	%p24, %r127, %r44;
	selp.b32 	%r128, %r127, %r44, %p24;
	max.s32 	%r129, %r128, %r51;
	cvt.s64.s32 	%rd208, %r129;
	mul.lo.s64 	%rd209, %rd208, %rd55;
	add.s64 	%rd210, %rd209, %rd9;
	add.s64 	%rd211, %rd1, %rd210;
	ld.global.nc.u8 	%rs39, [%rd211];
	cvt.u16.u8 	%rs40, %rs39;
	add.s64 	%rd212, %rd233, %rd4;
	st.global.u8 	[%rd212], %rs40;
	min.s32 	%r130, %r143, %r44;
	max.s32 	%r131, %r130, %r51;
	cvt.s64.s32 	%rd213, %r131;
	mul.lo.s64 	%rd214, %rd213, %rd55;
	add.s64 	%rd215, %rd214, %rd9;
	add.s64 	%rd216, %rd1, %rd215;
	ld.global.nc.u8 	%rs41, [%rd216];
	cvt.u16.u8 	%rs42, %rs41;
	add.s64 	%rd217, %rd234, %rd4;
	st.global.u8 	[%rd217], %rs42;
	add.s64 	%rd234, %rd234, %rd61;
	add.s32 	%r38, %r143, 4;
	add.s64 	%rd233, %rd233, %rd61;
	add.s64 	%rd232, %rd232, %rd61;
	add.s64 	%rd231, %rd231, %rd61;
	setp.eq.s32 	%p25, %r143, 2;
	mov.u32 	%r143, %r38;
	@%p25 bra 	LBB1_4;
	bra.uni 	LBB1_27;
LBB1_4:                                 // %after_bb
	ret;
}
                                        // -- End function
	// .globl	kernel_diff_s0_z_z_o___block_id_z // -- Begin function kernel_diff_s0_z_z_o___block_id_z
.visible .entry kernel_diff_s0_z_z_o___block_id_z(
	.param .u32 kernel_diff_s0_z_z_o___block_id_z_param_0,
	.param .u32 kernel_diff_s0_z_z_o___block_id_z_param_1,
	.param .u32 kernel_diff_s0_z_z_o___block_id_z_param_2,
	.param .u32 kernel_diff_s0_z_z_o___block_id_z_param_3,
	.param .u32 kernel_diff_s0_z_z_o___block_id_z_param_4,
	.param .u32 kernel_diff_s0_z_z_o___block_id_z_param_5,
	.param .u32 kernel_diff_s0_z_z_o___block_id_z_param_6,
	.param .u32 kernel_diff_s0_z_z_o___block_id_z_param_7,
	.param .u32 kernel_diff_s0_z_z_o___block_id_z_param_8,
	.param .u32 kernel_diff_s0_z_z_o___block_id_z_param_9,
	.param .u32 kernel_diff_s0_z_z_o___block_id_z_param_10,
	.param .u32 kernel_diff_s0_z_z_o___block_id_z_param_11,
	.param .u32 kernel_diff_s0_z_z_o___block_id_z_param_12,
	.param .u32 kernel_diff_s0_z_z_o___block_id_z_param_13,
	.param .u32 kernel_diff_s0_z_z_o___block_id_z_param_14,
	.param .u32 kernel_diff_s0_z_z_o___block_id_z_param_15,
	.param .u32 kernel_diff_s0_z_z_o___block_id_z_param_16,
	.param .u32 kernel_diff_s0_z_z_o___block_id_z_param_17,
	.param .u32 kernel_diff_s0_z_z_o___block_id_z_param_18,
	.param .u64 kernel_diff_s0_z_z_o___block_id_z_param_19,
	.param .u64 kernel_diff_s0_z_z_o___block_id_z_param_20,
	.param .u64 kernel_diff_s0_z_z_o___block_id_z_param_21
)                                       // @kernel_diff_s0_z_z_o___block_id_z
{
	.reg .pred 	%p<7>;
	.reg .b16 	%rs<46>;
	.reg .b32 	%r<49>;
	.reg .b64 	%rd<30>;

// %bb.0:                               // %entry
	ld.param.u32 	%r1, [kernel_diff_s0_z_z_o___block_id_z_param_0];
	ld.param.u64 	%rd1, [kernel_diff_s0_z_z_o___block_id_z_param_21];
	cvta.to.global.u64 	%rd2, %rd1;
	ld.param.u32 	%r2, [kernel_diff_s0_z_z_o___block_id_z_param_1];
	ld.param.u64 	%rd3, [kernel_diff_s0_z_z_o___block_id_z_param_20];
	cvta.to.global.u64 	%rd4, %rd3;
	ld.param.u32 	%r3, [kernel_diff_s0_z_z_o___block_id_z_param_2];
	ld.param.u64 	%rd5, [kernel_diff_s0_z_z_o___block_id_z_param_19];
	cvta.to.global.u64 	%rd6, %rd5;
	ld.param.u32 	%r4, [kernel_diff_s0_z_z_o___block_id_z_param_3];
	ld.param.u32 	%r5, [kernel_diff_s0_z_z_o___block_id_z_param_4];
	mov.u32 	%r6, %ctaid.z;
	ld.param.u32 	%r7, [kernel_diff_s0_z_z_o___block_id_z_param_5];
	mov.u32 	%r8, %ctaid.y;
	mov.u32 	%r9, %ctaid.x;
	mov.u32 	%r10, %tid.z;
	ld.param.u32 	%r11, [kernel_diff_s0_z_z_o___block_id_z_param_7];
	mov.u32 	%r12, %tid.y;
	ld.param.u32 	%r13, [kernel_diff_s0_z_z_o___block_id_z_param_8];
	mov.u32 	%r14, %tid.x;
	ld.param.u32 	%r15, [kernel_diff_s0_z_z_o___block_id_z_param_9];
	shl.b32 	%r16, %r6, 2;
	ld.param.u32 	%r17, [kernel_diff_s0_z_z_o___block_id_z_param_11];
	min.s32 	%r18, %r16, %r15;
	ld.param.u32 	%r19, [kernel_diff_s0_z_z_o___block_id_z_param_12];
	shl.b32 	%r20, %r8, 3;
	ld.param.u32 	%r21, [kernel_diff_s0_z_z_o___block_id_z_param_13];
	add.s32 	%r22, %r20, %r1;
	ld.param.u32 	%r23, [kernel_diff_s0_z_z_o___block_id_z_param_14];
	ld.param.u32 	%r24, [kernel_diff_s0_z_z_o___block_id_z_param_15];
	min.s32 	%r25, %r22, %r13;
	ld.param.u32 	%r26, [kernel_diff_s0_z_z_o___block_id_z_param_16];
	shl.b32 	%r27, %r9, 5;
	ld.param.u32 	%r28, [kernel_diff_s0_z_z_o___block_id_z_param_18];
	add.s32 	%r29, %r27, %r28;
	min.s32 	%r30, %r29, %r11;
	sub.s32 	%r31, %r12, %r21;
	add.s32 	%r32, %r31, %r25;
	mul.wide.s32 	%rd7, %r32, %r2;
	sub.s32 	%r33, %r12, %r17;
	add.s32 	%r34, %r33, %r25;
	mul.wide.s32 	%rd8, %r34, %r7;
	sub.s32 	%r35, %r14, %r19;
	add.s32 	%r36, %r35, %r30;
	cvt.s64.s32 	%rd9, %r36;
	add.s64 	%rd10, %rd8, %rd9;
	add.s32 	%r37, %r10, %r18;
	add.s32 	%r38, %r37, %r4;
	add.s32 	%r39, %r5, -128;
	mul.lo.s32 	%r40, %r39, %r3;
	mul.wide.s32 	%rd11, %r38, %r40;
	sub.s32 	%r41, %r12, %r24;
	add.s32 	%r42, %r41, %r25;
	mul.wide.s32 	%rd12, %r42, %r39;
	add.s64 	%rd13, %rd12, %rd11;
	sub.s32 	%r43, %r14, %r26;
	add.s32 	%r44, %r43, %r30;
	cvt.s64.s32 	%rd14, %r44;
	add.s64 	%rd15, %rd13, %rd14;
	shl.b32 	%r45, %r37, 1;
	sub.s32 	%r46, %r45, %r23;
	add.s32 	%r47, %r46, %r14;
	add.s32 	%r48, %r47, %r30;
	cvt.s64.s32 	%rd16, %r48;
	add.s64 	%rd17, %rd7, %rd16;
	ld.param.s32 	%rd18, [kernel_diff_s0_z_z_o___block_id_z_param_10];
	ld.param.s32 	%rd19, [kernel_diff_s0_z_z_o___block_id_z_param_6];
	ld.param.s32 	%rd20, [kernel_diff_s0_z_z_o___block_id_z_param_17];
	add.s64 	%rd21, %rd4, %rd10;
	ld.global.nc.u8 	%rs1, [%rd21];
	cvt.u16.u8 	%rs2, %rs1;
	add.s64 	%rd22, %rd2, %rd17;
	ld.global.nc.u8 	%rs3, [%rd22];
	cvt.u16.u8 	%rs4, %rs3;
	setp.lt.u16 	%p1, %rs2, %rs4;
	sub.s16 	%rs5, %rs4, %rs2;
	sub.s16 	%rs6, %rs2, %rs4;
	selp.b16 	%rs7, %rs5, %rs6, %p1;
	and.b16  	%rs8, %rs7, 255;
	ld.global.nc.u8 	%rs9, [%rd22+1];
	cvt.u16.u8 	%rs10, %rs9;
	setp.lt.u16 	%p2, %rs2, %rs10;
	sub.s16 	%rs11, %rs10, %rs2;
	sub.s16 	%rs12, %rs2, %rs10;
	selp.b16 	%rs13, %rs11, %rs12, %p2;
	and.b16  	%rs14, %rs13, 255;
	min.u16 	%rs15, %rs8, %rs14;
	add.s64 	%rd23, %rd6, %rd15;
	st.global.u8 	[%rd23], %rs15;
	add.s64 	%rd24, %rd21, %rd18;
	ld.global.nc.u8 	%rs16, [%rd24];
	cvt.u16.u8 	%rs17, %rs16;
	add.s64 	%rd25, %rd22, %rd19;
	ld.global.nc.u8 	%rs18, [%rd25];
	cvt.u16.u8 	%rs19, %rs18;
	setp.lt.u16 	%p3, %rs17, %rs19;
	sub.s16 	%rs20, %rs19, %rs17;
	sub.s16 	%rs21, %rs17, %rs19;
	selp.b16 	%rs22, %rs20, %rs21, %p3;
	and.b16  	%rs23, %rs22, 255;
	ld.global.nc.u8 	%rs24, [%rd25+1];
	cvt.u16.u8 	%rs25, %rs24;
	setp.lt.u16 	%p4, %rs17, %rs25;
	sub.s16 	%rs26, %rs25, %rs17;
	sub.s16 	%rs27, %rs17, %rs25;
	selp.b16 	%rs28, %rs26, %rs27, %p4;
	and.b16  	%rs29, %rs28, 255;
	min.u16 	%rs30, %rs23, %rs29;
	add.s64 	%rd26, %rd23, %rd20;
	st.global.u8 	[%rd26], %rs30;
	add.s64 	%rd27, %rd24, %rd18;
	ld.global.nc.u8 	%rs31, [%rd27];
	cvt.u16.u8 	%rs32, %rs31;
	add.s64 	%rd28, %rd25, %rd19;
	ld.global.nc.u8 	%rs33, [%rd28];
	cvt.u16.u8 	%rs34, %rs33;
	setp.lt.u16 	%p5, %rs32, %rs34;
	sub.s16 	%rs35, %rs34, %rs32;
	sub.s16 	%rs36, %rs32, %rs34;
	selp.b16 	%rs37, %rs35, %rs36, %p5;
	and.b16  	%rs38, %rs37, 255;
	ld.global.nc.u8 	%rs39, [%rd28+1];
	cvt.u16.u8 	%rs40, %rs39;
	setp.lt.u16 	%p6, %rs32, %rs40;
	sub.s16 	%rs41, %rs40, %rs32;
	sub.s16 	%rs42, %rs32, %rs40;
	selp.b16 	%rs43, %rs41, %rs42, %p6;
	and.b16  	%rs44, %rs43, 255;
	min.u16 	%rs45, %rs38, %rs44;
	add.s64 	%rd29, %rd26, %rd20;
	st.global.u8 	[%rd29], %rs45;
	ret;
}
                                        // -- End function
	// .globl	kernel_cost_confidence_s0_y_y_o___block_id_y // -- Begin function kernel_cost_confidence_s0_y_y_o___block_id_y
.visible .entry kernel_cost_confidence_s0_y_y_o___block_id_y(
	.param .u64 kernel_cost_confidence_s0_y_y_o___block_id_y_param_0,
	.param .u32 kernel_cost_confidence_s0_y_y_o___block_id_y_param_1,
	.param .u32 kernel_cost_confidence_s0_y_y_o___block_id_y_param_2,
	.param .u32 kernel_cost_confidence_s0_y_y_o___block_id_y_param_3,
	.param .u32 kernel_cost_confidence_s0_y_y_o___block_id_y_param_4,
	.param .u32 kernel_cost_confidence_s0_y_y_o___block_id_y_param_5,
	.param .u32 kernel_cost_confidence_s0_y_y_o___block_id_y_param_6,
	.param .u32 kernel_cost_confidence_s0_y_y_o___block_id_y_param_7,
	.param .f32 kernel_cost_confidence_s0_y_y_o___block_id_y_param_8,
	.param .u32 kernel_cost_confidence_s0_y_y_o___block_id_y_param_9,
	.param .u32 kernel_cost_confidence_s0_y_y_o___block_id_y_param_10,
	.param .u32 kernel_cost_confidence_s0_y_y_o___block_id_y_param_11,
	.param .u32 kernel_cost_confidence_s0_y_y_o___block_id_y_param_12,
	.param .u32 kernel_cost_confidence_s0_y_y_o___block_id_y_param_13,
	.param .u32 kernel_cost_confidence_s0_y_y_o___block_id_y_param_14,
	.param .u32 kernel_cost_confidence_s0_y_y_o___block_id_y_param_15,
	.param .u64 kernel_cost_confidence_s0_y_y_o___block_id_y_param_16,
	.param .u64 kernel_cost_confidence_s0_y_y_o___block_id_y_param_17
)                                       // @kernel_cost_confidence_s0_y_y_o___block_id_y
{
	.reg .pred 	%p<9>;
	.reg .b16 	%rs<37>;
	.reg .f32 	%f<71>;
	.reg .b32 	%r<56>;
	.reg .b64 	%rd<124>;

// %bb.0:                               // %entry
	ld.param.u32 	%r19, [kernel_cost_confidence_s0_y_y_o___block_id_y_param_9];
	ld.param.u32 	%r18, [kernel_cost_confidence_s0_y_y_o___block_id_y_param_5];
	ld.param.u32 	%r17, [kernel_cost_confidence_s0_y_y_o___block_id_y_param_4];
	ld.param.u64 	%rd50, [kernel_cost_confidence_s0_y_y_o___block_id_y_param_0];
	ld.param.u64 	%rd51, [kernel_cost_confidence_s0_y_y_o___block_id_y_param_17];
	cvta.to.global.u64 	%rd1, %rd51;
	ld.param.u32 	%r22, [kernel_cost_confidence_s0_y_y_o___block_id_y_param_1];
	ld.param.u64 	%rd52, [kernel_cost_confidence_s0_y_y_o___block_id_y_param_16];
	ld.param.u32 	%r23, [kernel_cost_confidence_s0_y_y_o___block_id_y_param_2];
	mov.u32 	%r24, %ctaid.y;
	mov.u32 	%r25, %ctaid.x;
	mov.u32 	%r1, %tid.y;
	mov.u32 	%r2, %tid.x;
	ld.param.u32 	%r26, [kernel_cost_confidence_s0_y_y_o___block_id_y_param_6];
	shl.b32 	%r27, %r24, 3;
	ld.param.u32 	%r28, [kernel_cost_confidence_s0_y_y_o___block_id_y_param_7];
	add.s32 	%r29, %r27, %r22;
	min.s32 	%r3, %r29, %r28;
	ld.param.u32 	%r30, [kernel_cost_confidence_s0_y_y_o___block_id_y_param_10];
	shl.b32 	%r31, %r25, 5;
	ld.param.u32 	%r32, [kernel_cost_confidence_s0_y_y_o___block_id_y_param_11];
	ld.param.u32 	%r33, [kernel_cost_confidence_s0_y_y_o___block_id_y_param_15];
	add.s32 	%r34, %r31, %r33;
	min.s32 	%r4, %r34, %r26;
	shl.b32 	%r35, %r1, 5;
	add.s32 	%r36, %r35, %r2;
	mul.wide.u32 	%rd3, %r36, 4;
	mov.u32 	%r55, 0;
	st.shared.u32 	[%rd3], %r55;
	bar.sync 	0;
	sub.s32 	%r38, %r1, %r30;
	add.s32 	%r39, %r38, %r3;
	mul.wide.s32 	%rd4, %r39, %r23;
	add.s64 	%rd5, %rd4, %rd50;
	ld.param.s32 	%rd6, [kernel_cost_confidence_s0_y_y_o___block_id_y_param_12];
	add.s64 	%rd7, %rd4, %rd6;
	sub.s32 	%r40, %r4, %r32;
	add.s32 	%r5, %r40, %r2;
	setp.lt.s32 	%p1, %r19, 1;
	@%p1 bra 	LBB3_8;
// %bb.1:                               // %"for sum.s1.r$x.preheader"
	cvt.s64.s32 	%rd8, %r18;
	cvt.s64.s32 	%rd9, %r5;
	ld.shared.f32 	%f66, [%rd3];
	and.b32  	%r6, %r19, 1;
	setp.eq.s32 	%p2, %r19, 1;
	@%p2 bra 	LBB3_2;
	bra.uni 	LBB3_3;
LBB3_2:
	mov.u32 	%r53, 0;
	setp.eq.s32 	%p4, %r6, 0;
	@%p4 bra 	LBB3_7;
	bra.uni 	LBB3_6;
LBB3_3:                                 // %"for sum.s1.r$x.preheader.new"
	sub.s32 	%r53, %r19, %r6;
	cvt.s64.s32 	%rd53, %r17;
	add.s64 	%rd54, %rd53, 1;
	mul.lo.s64 	%rd55, %rd54, %rd8;
	add.s64 	%rd56, %rd55, %rd4;
	add.s64 	%rd57, %rd56, %rd6;
	add.s64 	%rd117, %rd1, %rd57;
	shl.b64 	%rd11, %rd8, 1;
	add.s64 	%rd116, %rd1, %rd56;
	add.s64 	%rd58, %rd50, %rd55;
	add.s64 	%rd59, %rd58, %rd4;
	add.s64 	%rd115, %rd1, %rd59;
	mul.lo.s64 	%rd60, %rd8, %rd53;
	add.s64 	%rd61, %rd60, %rd4;
	add.s64 	%rd62, %rd61, %rd6;
	add.s64 	%rd114, %rd1, %rd62;
	add.s64 	%rd113, %rd1, %rd61;
	add.s64 	%rd63, %rd50, %rd60;
	add.s64 	%rd64, %rd63, %rd4;
	add.s64 	%rd112, %rd1, %rd64;
	mov.u32 	%r52, 0;
LBB3_4:                                 // %"for sum.s1.r$x"
                                        // =>This Inner Loop Header: Depth=1
	add.s64 	%rd65, %rd112, %rd9;
	ld.global.nc.u8 	%rs1, [%rd65];
	cvt.u16.u8 	%rs2, %rs1;
	add.s64 	%rd66, %rd113, %rd9;
	ld.global.nc.u8 	%rs3, [%rd66];
	cvt.u16.u8 	%rs4, %rs3;
	add.s64 	%rd67, %rd114, %rd9;
	ld.global.nc.u8 	%rs5, [%rd67];
	cvt.u16.u8 	%rs6, %rs5;
	cvt.rn.f32.u16 	%f17, %rs2;
	cvt.rn.f32.u16 	%f18, %rs4;
	cvt.rn.f32.u16 	%f19, %rs6;
	mul.ftz.f32 	%f20, %f19, %f19;
	fma.rn.ftz.f32 	%f21, %f18, %f18, %f20;
	fma.rn.ftz.f32 	%f22, %f17, %f17, %f21;
	fma.rn.ftz.f32 	%f23, %f22, %f22, %f66;
	add.s64 	%rd68, %rd115, %rd9;
	ld.global.nc.u8 	%rs7, [%rd68];
	cvt.u16.u8 	%rs8, %rs7;
	add.s64 	%rd69, %rd116, %rd9;
	ld.global.nc.u8 	%rs9, [%rd69];
	cvt.u16.u8 	%rs10, %rs9;
	add.s64 	%rd70, %rd117, %rd9;
	ld.global.nc.u8 	%rs11, [%rd70];
	cvt.u16.u8 	%rs12, %rs11;
	cvt.rn.f32.u16 	%f24, %rs8;
	cvt.rn.f32.u16 	%f25, %rs10;
	cvt.rn.f32.u16 	%f26, %rs12;
	mul.ftz.f32 	%f27, %f26, %f26;
	fma.rn.ftz.f32 	%f28, %f25, %f25, %f27;
	fma.rn.ftz.f32 	%f29, %f24, %f24, %f28;
	fma.rn.ftz.f32 	%f66, %f29, %f29, %f23;
	add.s32 	%r52, %r52, 2;
	add.s64 	%rd117, %rd117, %rd11;
	add.s64 	%rd116, %rd116, %rd11;
	add.s64 	%rd115, %rd115, %rd11;
	add.s64 	%rd114, %rd114, %rd11;
	add.s64 	%rd113, %rd113, %rd11;
	add.s64 	%rd112, %rd112, %rd11;
	setp.ne.s32 	%p3, %r53, %r52;
	@%p3 bra 	LBB3_4;
// %bb.5:                               // %"end for sum.s1.r$x.loopexit.unr-lcssa"
	setp.eq.s32 	%p4, %r6, 0;
	@%p4 bra 	LBB3_7;
LBB3_6:                                 // %"for sum.s1.r$x.epil"
	add.s32 	%r43, %r53, %r17;
	cvt.s64.s32 	%rd71, %r43;
	mul.lo.s64 	%rd72, %rd71, %rd8;
	add.s64 	%rd73, %rd72, %rd9;
	add.s64 	%rd74, %rd73, %rd5;
	add.s64 	%rd75, %rd1, %rd74;
	ld.global.nc.u8 	%rs13, [%rd75];
	cvt.u16.u8 	%rs14, %rs13;
	add.s64 	%rd76, %rd73, %rd4;
	add.s64 	%rd77, %rd1, %rd76;
	ld.global.nc.u8 	%rs15, [%rd77];
	cvt.u16.u8 	%rs16, %rs15;
	add.s64 	%rd78, %rd73, %rd7;
	add.s64 	%rd79, %rd1, %rd78;
	ld.global.nc.u8 	%rs17, [%rd79];
	cvt.u16.u8 	%rs18, %rs17;
	cvt.rn.f32.u16 	%f30, %rs14;
	cvt.rn.f32.u16 	%f31, %rs16;
	cvt.rn.f32.u16 	%f32, %rs18;
	mul.ftz.f32 	%f33, %f32, %f32;
	fma.rn.ftz.f32 	%f34, %f31, %f31, %f33;
	fma.rn.ftz.f32 	%f35, %f30, %f30, %f34;
	fma.rn.ftz.f32 	%f66, %f35, %f35, %f66;
LBB3_7:                                 // %"end for sum.s1.r$x.loopexit"
	st.shared.f32 	[%rd3], %f66;
LBB3_8:                                 // %"end for sum.s1.r$x"
	ld.param.u32 	%r21, [kernel_cost_confidence_s0_y_y_o___block_id_y_param_14];
	ld.param.u32 	%r20, [kernel_cost_confidence_s0_y_y_o___block_id_y_param_13];
	ld.param.f32 	%f15, [kernel_cost_confidence_s0_y_y_o___block_id_y_param_8];
	ld.param.u32 	%r16, [kernel_cost_confidence_s0_y_y_o___block_id_y_param_3];
	cvta.to.global.u64 	%rd2, %rd52;
	bar.sync 	0;
	st.shared.u32 	[%rd3+1024], %r55;
	bar.sync 	0;
	@%p1 bra 	LBB3_15;
// %bb.9:                               // %"for sum$1.s1.r$x.preheader"
	cvt.s64.s32 	%rd29, %r18;
	cvt.s64.s32 	%rd30, %r5;
	ld.shared.f32 	%f70, [%rd3+1024];
	and.b32  	%r11, %r19, 1;
	setp.eq.s32 	%p6, %r19, 1;
	@%p6 bra 	LBB3_12;
// %bb.10:                              // %"for sum$1.s1.r$x.preheader.new"
	sub.s32 	%r55, %r19, %r11;
	cvt.s64.s32 	%rd80, %r17;
	add.s64 	%rd81, %rd80, 1;
	mul.lo.s64 	%rd82, %rd81, %rd29;
	add.s64 	%rd83, %rd82, %rd4;
	add.s64 	%rd84, %rd83, %rd6;
	add.s64 	%rd123, %rd1, %rd84;
	shl.b64 	%rd32, %rd29, 1;
	add.s64 	%rd122, %rd1, %rd83;
	add.s64 	%rd85, %rd50, %rd82;
	add.s64 	%rd86, %rd85, %rd4;
	add.s64 	%rd121, %rd1, %rd86;
	mul.lo.s64 	%rd87, %rd29, %rd80;
	add.s64 	%rd88, %rd87, %rd4;
	add.s64 	%rd89, %rd88, %rd6;
	add.s64 	%rd120, %rd1, %rd89;
	add.s64 	%rd119, %rd1, %rd88;
	add.s64 	%rd90, %rd50, %rd87;
	add.s64 	%rd91, %rd90, %rd4;
	add.s64 	%rd118, %rd1, %rd91;
	mov.u32 	%r54, 0;
	rcp.approx.ftz.f32 	%f43, %f15;
LBB3_11:                                // %"for sum$1.s1.r$x"
                                        // =>This Inner Loop Header: Depth=1
	add.s64 	%rd92, %rd118, %rd30;
	ld.global.nc.u8 	%rs19, [%rd92];
	cvt.u16.u8 	%rs20, %rs19;
	add.s64 	%rd93, %rd119, %rd30;
	ld.global.nc.u8 	%rs21, [%rd93];
	cvt.u16.u8 	%rs22, %rs21;
	add.s64 	%rd94, %rd120, %rd30;
	ld.global.nc.u8 	%rs23, [%rd94];
	cvt.u16.u8 	%rs24, %rs23;
	cvt.rn.f32.u16 	%f37, %rs20;
	cvt.rn.f32.u16 	%f38, %rs22;
	cvt.rn.f32.u16 	%f39, %rs24;
	mul.ftz.f32 	%f40, %f39, %f39;
	fma.rn.ftz.f32 	%f41, %f38, %f38, %f40;
	fma.rn.ftz.f32 	%f42, %f37, %f37, %f41;
	fma.rn.ftz.f32 	%f44, %f42, %f43, %f70;
	add.s64 	%rd95, %rd121, %rd30;
	ld.global.nc.u8 	%rs25, [%rd95];
	cvt.u16.u8 	%rs26, %rs25;
	add.s64 	%rd96, %rd122, %rd30;
	ld.global.nc.u8 	%rs27, [%rd96];
	cvt.u16.u8 	%rs28, %rs27;
	add.s64 	%rd97, %rd123, %rd30;
	ld.global.nc.u8 	%rs29, [%rd97];
	cvt.u16.u8 	%rs30, %rs29;
	cvt.rn.f32.u16 	%f45, %rs26;
	cvt.rn.f32.u16 	%f46, %rs28;
	cvt.rn.f32.u16 	%f47, %rs30;
	mul.ftz.f32 	%f48, %f47, %f47;
	fma.rn.ftz.f32 	%f49, %f46, %f46, %f48;
	fma.rn.ftz.f32 	%f50, %f45, %f45, %f49;
	fma.rn.ftz.f32 	%f70, %f50, %f43, %f44;
	add.s32 	%r54, %r54, 2;
	add.s64 	%rd123, %rd123, %rd32;
	add.s64 	%rd122, %rd122, %rd32;
	add.s64 	%rd121, %rd121, %rd32;
	add.s64 	%rd120, %rd120, %rd32;
	add.s64 	%rd119, %rd119, %rd32;
	add.s64 	%rd118, %rd118, %rd32;
	setp.ne.s32 	%p7, %r55, %r54;
	@%p7 bra 	LBB3_11;
LBB3_12:                                // %"end for sum$1.s1.r$x.loopexit.unr-lcssa"
	setp.eq.s32 	%p8, %r11, 0;
	@%p8 bra 	LBB3_14;
// %bb.13:                              // %"for sum$1.s1.r$x.epil"
	add.s32 	%r47, %r55, %r17;
	cvt.s64.s32 	%rd98, %r47;
	mul.lo.s64 	%rd99, %rd98, %rd29;
	add.s64 	%rd100, %rd99, %rd30;
	add.s64 	%rd101, %rd100, %rd5;
	add.s64 	%rd102, %rd1, %rd101;
	ld.global.nc.u8 	%rs31, [%rd102];
	cvt.u16.u8 	%rs32, %rs31;
	add.s64 	%rd103, %rd100, %rd4;
	add.s64 	%rd104, %rd1, %rd103;
	ld.global.nc.u8 	%rs33, [%rd104];
	cvt.u16.u8 	%rs34, %rs33;
	add.s64 	%rd105, %rd100, %rd7;
	add.s64 	%rd106, %rd1, %rd105;
	ld.global.nc.u8 	%rs35, [%rd106];
	cvt.u16.u8 	%rs36, %rs35;
	cvt.rn.f32.u16 	%f51, %rs32;
	cvt.rn.f32.u16 	%f52, %rs34;
	cvt.rn.f32.u16 	%f53, %rs36;
	mul.ftz.f32 	%f54, %f53, %f53;
	fma.rn.ftz.f32 	%f55, %f52, %f52, %f54;
	fma.rn.ftz.f32 	%f56, %f51, %f51, %f55;
	div.approx.ftz.f32 	%f57, %f56, %f15;
	add.ftz.f32 	%f70, %f70, %f57;
LBB3_14:                                // %"end for sum$1.s1.r$x.loopexit"
	st.shared.f32 	[%rd3+1024], %f70;
LBB3_15:                                // %"end for sum$1.s1.r$x"
	bar.sync 	0;
	ld.shared.f32 	%f58, [%rd3+1024];
	ld.shared.f32 	%f59, [%rd3];
	div.approx.ftz.f32 	%f60, %f59, %f15;
	neg.ftz.f32 	%f61, %f58;
	fma.rn.ftz.f32 	%f62, %f61, %f58, %f60;
	sub.s32 	%r48, %r1, %r20;
	add.s32 	%r49, %r48, %r3;
	mul.wide.s32 	%rd107, %r49, %r16;
	sub.s32 	%r50, %r2, %r21;
	add.s32 	%r51, %r50, %r4;
	cvt.s64.s32 	%rd108, %r51;
	add.s64 	%rd109, %rd107, %rd108;
	shl.b64 	%rd110, %rd109, 2;
	add.s64 	%rd111, %rd2, %rd110;
	st.global.f32 	[%rd111], %f62;
	ret;
}
                                        // -- End function
	// .globl	kernel_downy_s0__0__0_o___block_id_z // -- Begin function kernel_downy_s0__0__0_o___block_id_z
.visible .entry kernel_downy_s0__0__0_o___block_id_z(
	.param .u64 kernel_downy_s0__0__0_o___block_id_z_param_0,
	.param .u32 kernel_downy_s0__0__0_o___block_id_z_param_1,
	.param .u32 kernel_downy_s0__0__0_o___block_id_z_param_2,
	.param .u32 kernel_downy_s0__0__0_o___block_id_z_param_3,
	.param .u32 kernel_downy_s0__0__0_o___block_id_z_param_4,
	.param .u32 kernel_downy_s0__0__0_o___block_id_z_param_5,
	.param .u32 kernel_downy_s0__0__0_o___block_id_z_param_6,
	.param .u32 kernel_downy_s0__0__0_o___block_id_z_param_7,
	.param .u32 kernel_downy_s0__0__0_o___block_id_z_param_8,
	.param .u32 kernel_downy_s0__0__0_o___block_id_z_param_9,
	.param .u32 kernel_downy_s0__0__0_o___block_id_z_param_10,
	.param .u32 kernel_downy_s0__0__0_o___block_id_z_param_11,
	.param .u32 kernel_downy_s0__0__0_o___block_id_z_param_12,
	.param .u32 kernel_downy_s0__0__0_o___block_id_z_param_13,
	.param .u32 kernel_downy_s0__0__0_o___block_id_z_param_14,
	.param .u32 kernel_downy_s0__0__0_o___block_id_z_param_15,
	.param .u32 kernel_downy_s0__0__0_o___block_id_z_param_16,
	.param .u32 kernel_downy_s0__0__0_o___block_id_z_param_17,
	.param .u32 kernel_downy_s0__0__0_o___block_id_z_param_18,
	.param .u32 kernel_downy_s0__0__0_o___block_id_z_param_19,
	.param .u32 kernel_downy_s0__0__0_o___block_id_z_param_20,
	.param .u64 kernel_downy_s0__0__0_o___block_id_z_param_21,
	.param .u64 kernel_downy_s0__0__0_o___block_id_z_param_22,
	.param .u64 kernel_downy_s0__0__0_o___block_id_z_param_23
)                                       // @kernel_downy_s0__0__0_o___block_id_z
{
	.reg .pred 	%p<2>;
	.reg .b16 	%rs<25>;
	.reg .f32 	%f<55>;
	.reg .b32 	%r<57>;
	.reg .b64 	%rd<35>;

// %bb.0:                               // %entry
	ld.param.u64 	%rd2, [kernel_downy_s0__0__0_o___block_id_z_param_0];
	ld.param.u64 	%rd3, [kernel_downy_s0__0__0_o___block_id_z_param_23];
	cvta.to.global.u64 	%rd4, %rd3;
	ld.param.u32 	%r13, [kernel_downy_s0__0__0_o___block_id_z_param_2];
	ld.param.u64 	%rd6, [kernel_downy_s0__0__0_o___block_id_z_param_21];
	cvta.to.global.u64 	%rd7, %rd6;
	mov.u32 	%r14, %ctaid.z;
	ld.param.u32 	%r15, [kernel_downy_s0__0__0_o___block_id_z_param_5];
	mov.u32 	%r16, %ctaid.y;
	ld.param.u32 	%r17, [kernel_downy_s0__0__0_o___block_id_z_param_6];
	mov.u32 	%r18, %ctaid.x;
	mov.u32 	%r19, %tid.z;
	ld.param.u32 	%r20, [kernel_downy_s0__0__0_o___block_id_z_param_7];
	mov.u32 	%r1, %tid.y;
	ld.param.u32 	%r21, [kernel_downy_s0__0__0_o___block_id_z_param_8];
	mov.u32 	%r2, %tid.x;
	ld.param.u32 	%r22, [kernel_downy_s0__0__0_o___block_id_z_param_9];
	shl.b32 	%r23, %r14, 1;
	ld.param.u32 	%r24, [kernel_downy_s0__0__0_o___block_id_z_param_10];
	ld.param.u32 	%r25, [kernel_downy_s0__0__0_o___block_id_z_param_11];
	ld.param.u32 	%r26, [kernel_downy_s0__0__0_o___block_id_z_param_13];
	min.s32 	%r27, %r23, %r26;
	ld.param.u32 	%r28, [kernel_downy_s0__0__0_o___block_id_z_param_12];
	mad.lo.s32 	%r29, %r16, 14, %r25;
	min.s32 	%r3, %r29, %r28;
	shl.b32 	%r30, %r18, 4;
	ld.param.u32 	%r31, [kernel_downy_s0__0__0_o___block_id_z_param_18];
	add.s32 	%r32, %r30, %r31;
	ld.param.u32 	%r33, [kernel_downy_s0__0__0_o___block_id_z_param_19];
	min.s32 	%r4, %r32, %r24;
	ld.param.u32 	%r34, [kernel_downy_s0__0__0_o___block_id_z_param_20];
	shl.b32 	%r35, %r3, 1;
	add.s32 	%r36, %r35, %r1;
	add.s32 	%r37, %r36, %r22;
	mul.wide.s32 	%rd8, %r37, %r13;
	add.s32 	%r38, %r36, %r21;
	mul.wide.s32 	%rd9, %r38, %r20;
	add.s32 	%r5, %r19, %r27;
	add.s32 	%r39, %r5, %r17;
	mul.wide.s32 	%rd10, %r39, %r15;
	mul.lo.s32 	%r6, %r19, 30;
	add.s32 	%r40, %r6, %r1;
	shl.b32 	%r41, %r40, 4;
	add.s32 	%r42, %r41, %r2;
	ld.param.s32 	%rd11, [kernel_downy_s0__0__0_o___block_id_z_param_1];
	add.s32 	%r43, %r4, %r2;
	shl.b32 	%r44, %r43, 1;
	sub.s32 	%r45, %r44, %r34;
	cvt.s64.s32 	%rd12, %r45;
	add.s64 	%rd13, %rd9, %rd12;
	shl.b64 	%rd14, %rd13, 2;
	add.s64 	%rd15, %rd7, %rd14;
	ld.global.nc.f32 	%f1, [%rd15+-4];
	ld.global.nc.f32 	%f2, [%rd15];
	ld.global.nc.f32 	%f3, [%rd15+4];
	ld.global.nc.f32 	%f4, [%rd15+8];
	sub.s32 	%r46, %r44, %r33;
	cvt.s64.s32 	%rd16, %r46;
	add.s64 	%rd17, %rd8, %rd16;
	add.s64 	%rd18, %rd17, %rd2;
	add.s64 	%rd19, %rd18, %rd10;
	add.s64 	%rd20, %rd4, %rd19;
	ld.global.nc.u8 	%rs1, [%rd20+2];
	cvt.u16.u8 	%rs2, %rs1;
	add.s64 	%rd21, %rd17, %rd10;
	add.s64 	%rd22, %rd4, %rd21;
	ld.global.nc.u8 	%rs3, [%rd22+2];
	cvt.u16.u8 	%rs4, %rs3;
	add.s64 	%rd23, %rd22, %rd11;
	ld.global.nc.u8 	%rs5, [%rd23+2];
	cvt.u16.u8 	%rs6, %rs5;
	ld.global.nc.u8 	%rs7, [%rd20+-1];
	cvt.u16.u8 	%rs8, %rs7;
	ld.global.nc.u8 	%rs9, [%rd22+-1];
	cvt.u16.u8 	%rs10, %rs9;
	ld.global.nc.u8 	%rs11, [%rd23+-1];
	cvt.u16.u8 	%rs12, %rs11;
	ld.global.nc.u8 	%rs13, [%rd20];
	cvt.u16.u8 	%rs14, %rs13;
	ld.global.nc.u8 	%rs15, [%rd22];
	cvt.u16.u8 	%rs16, %rs15;
	ld.global.nc.u8 	%rs17, [%rd23];
	cvt.u16.u8 	%rs18, %rs17;
	ld.global.nc.u8 	%rs19, [%rd20+1];
	cvt.u16.u8 	%rs20, %rs19;
	ld.global.nc.u8 	%rs21, [%rd22+1];
	cvt.u16.u8 	%rs22, %rs21;
	ld.global.nc.u8 	%rs23, [%rd23+1];
	cvt.u16.u8 	%rs24, %rs23;
	cvt.rn.f32.u16 	%f5, %rs2;
	cvt.rn.f32.u16 	%f6, %rs4;
	cvt.rn.f32.u16 	%f7, %rs6;
	mul.ftz.f32 	%f8, %f7, %f7;
	fma.rn.ftz.f32 	%f9, %f6, %f6, %f8;
	fma.rn.ftz.f32 	%f10, %f5, %f5, %f9;
	cvt.rn.f32.u16 	%f11, %rs8;
	cvt.rn.f32.u16 	%f12, %rs10;
	cvt.rn.f32.u16 	%f13, %rs12;
	mul.ftz.f32 	%f14, %f13, %f13;
	fma.rn.ftz.f32 	%f15, %f12, %f12, %f14;
	fma.rn.ftz.f32 	%f16, %f11, %f11, %f15;
	mul.ftz.f32 	%f17, %f1, %f16;
	fma.rn.ftz.f32 	%f18, %f4, %f10, %f17;
	add.ftz.f32 	%f19, %f1, %f4;
	cvt.rn.f32.u16 	%f20, %rs14;
	cvt.rn.f32.u16 	%f21, %rs16;
	cvt.rn.f32.u16 	%f22, %rs18;
	mul.ftz.f32 	%f23, %f22, %f22;
	fma.rn.ftz.f32 	%f24, %f21, %f21, %f23;
	fma.rn.ftz.f32 	%f25, %f20, %f20, %f24;
	cvt.rn.f32.u16 	%f26, %rs20;
	cvt.rn.f32.u16 	%f27, %rs22;
	cvt.rn.f32.u16 	%f28, %rs24;
	mul.ftz.f32 	%f29, %f28, %f28;
	fma.rn.ftz.f32 	%f30, %f27, %f27, %f29;
	fma.rn.ftz.f32 	%f31, %f26, %f26, %f30;
	mul.ftz.f32 	%f32, %f3, %f31;
	fma.rn.ftz.f32 	%f33, %f2, %f25, %f32;
	add.ftz.f32 	%f34, %f2, %f3;
	fma.rn.ftz.f32 	%f35, %f33, 0f40400000, %f18;
	mul.ftz.f32 	%f36, %f35, 0f3E000000;
	mul.wide.u32 	%rd24, %r42, 4;
	st.shared.f32 	[%rd24], %f36;
	fma.rn.ftz.f32 	%f37, %f34, 0f40400000, %f19;
	mul.ftz.f32 	%f38, %f37, 0f3E000000;
	st.shared.f32 	[%rd24+3840], %f38;
	bar.sync 	0;
	setp.gt.u32 	%p1, %r1, 13;
	@%p1 bra 	LBB4_2;
// %bb.1:                               // %true_bb
	ld.param.u32 	%r12, [kernel_downy_s0__0__0_o___block_id_z_param_17];
	ld.param.u32 	%r11, [kernel_downy_s0__0__0_o___block_id_z_param_16];
	ld.param.u32 	%r10, [kernel_downy_s0__0__0_o___block_id_z_param_15];
	ld.param.u32 	%r9, [kernel_downy_s0__0__0_o___block_id_z_param_14];
	ld.param.u32 	%r8, [kernel_downy_s0__0__0_o___block_id_z_param_4];
	ld.param.u32 	%r7, [kernel_downy_s0__0__0_o___block_id_z_param_3];
	ld.param.u64 	%rd5, [kernel_downy_s0__0__0_o___block_id_z_param_22];
	cvta.to.global.u64 	%rd1, %rd5;
	shl.b32 	%r47, %r1, 1;
	or.b32  	%r48, %r47, 1;
	add.s32 	%r49, %r48, %r6;
	shl.b32 	%r50, %r49, 4;
	add.s32 	%r51, %r50, %r2;
	add.s32 	%r52, %r5, %r9;
	mul.wide.s32 	%rd25, %r52, %r12;
	sub.s32 	%r53, %r1, %r10;
	add.s32 	%r54, %r53, %r3;
	mul.wide.s32 	%rd26, %r54, %r8;
	add.s64 	%rd27, %rd26, %rd25;
	sub.s32 	%r55, %r2, %r11;
	add.s32 	%r56, %r55, %r4;
	cvt.s64.s32 	%rd28, %r56;
	add.s64 	%rd29, %rd27, %rd28;
	mul.wide.u32 	%rd30, %r51, 4;
	ld.shared.f32 	%f39, [%rd30+128];
	ld.shared.f32 	%f40, [%rd30+-64];
	ld.shared.f32 	%f41, [%rd30];
	ld.shared.f32 	%f42, [%rd30+64];
	add.ftz.f32 	%f43, %f41, %f42;
	fma.rn.ftz.f32 	%f44, %f43, 0f40400000, %f40;
	add.ftz.f32 	%f45, %f39, %f44;
	mul.ftz.f32 	%f46, %f45, 0f3E000000;
	shl.b64 	%rd31, %rd29, 2;
	add.s64 	%rd32, %rd1, %rd31;
	st.global.f32 	[%rd32], %f46;
	ld.shared.f32 	%f47, [%rd30+3968];
	ld.shared.f32 	%f48, [%rd30+3776];
	ld.shared.f32 	%f49, [%rd30+3840];
	ld.shared.f32 	%f50, [%rd30+3904];
	add.ftz.f32 	%f51, %f49, %f50;
	fma.rn.ftz.f32 	%f52, %f51, 0f40400000, %f48;
	add.ftz.f32 	%f53, %f47, %f52;
	mul.ftz.f32 	%f54, %f53, 0f3E000000;
	mul.wide.s32 	%rd33, %r7, 4;
	add.s64 	%rd34, %rd32, %rd33;
	st.global.f32 	[%rd34], %f54;
LBB4_2:                                 // %after_bb
	ret;
}
                                        // -- End function
	// .globl	kernel_downy_1_s0__0__0_o___block_id_z // -- Begin function kernel_downy_1_s0__0__0_o___block_id_z
.visible .entry kernel_downy_1_s0__0__0_o___block_id_z(
	.param .u32 kernel_downy_1_s0__0__0_o___block_id_z_param_0,
	.param .u32 kernel_downy_1_s0__0__0_o___block_id_z_param_1,
	.param .u32 kernel_downy_1_s0__0__0_o___block_id_z_param_2,
	.param .u32 kernel_downy_1_s0__0__0_o___block_id_z_param_3,
	.param .u32 kernel_downy_1_s0__0__0_o___block_id_z_param_4,
	.param .u32 kernel_downy_1_s0__0__0_o___block_id_z_param_5,
	.param .u32 kernel_downy_1_s0__0__0_o___block_id_z_param_6,
	.param .u32 kernel_downy_1_s0__0__0_o___block_id_z_param_7,
	.param .u32 kernel_downy_1_s0__0__0_o___block_id_z_param_8,
	.param .u32 kernel_downy_1_s0__0__0_o___block_id_z_param_9,
	.param .u32 kernel_downy_1_s0__0__0_o___block_id_z_param_10,
	.param .u32 kernel_downy_1_s0__0__0_o___block_id_z_param_11,
	.param .u32 kernel_downy_1_s0__0__0_o___block_id_z_param_12,
	.param .u32 kernel_downy_1_s0__0__0_o___block_id_z_param_13,
	.param .u32 kernel_downy_1_s0__0__0_o___block_id_z_param_14,
	.param .u32 kernel_downy_1_s0__0__0_o___block_id_z_param_15,
	.param .u32 kernel_downy_1_s0__0__0_o___block_id_z_param_16,
	.param .u32 kernel_downy_1_s0__0__0_o___block_id_z_param_17,
	.param .u64 kernel_downy_1_s0__0__0_o___block_id_z_param_18,
	.param .u64 kernel_downy_1_s0__0__0_o___block_id_z_param_19
)                                       // @kernel_downy_1_s0__0__0_o___block_id_z
{
	.reg .pred 	%p<2>;
	.reg .f32 	%f<33>;
	.reg .b32 	%r<69>;
	.reg .b64 	%rd<51>;

// %bb.0:                               // %entry
	ld.param.u32 	%r11, [kernel_downy_1_s0__0__0_o___block_id_z_param_1];
	ld.param.u64 	%rd4, [kernel_downy_1_s0__0__0_o___block_id_z_param_18];
	cvta.to.global.u64 	%rd5, %rd4;
	mov.u32 	%r12, %ctaid.z;
	mov.u32 	%r13, %ctaid.y;
	ld.param.u32 	%r14, [kernel_downy_1_s0__0__0_o___block_id_z_param_5];
	mov.u32 	%r15, %ctaid.x;
	ld.param.u32 	%r16, [kernel_downy_1_s0__0__0_o___block_id_z_param_6];
	mov.u32 	%r17, %tid.z;
	mov.u32 	%r1, %tid.y;
	ld.param.u32 	%r18, [kernel_downy_1_s0__0__0_o___block_id_z_param_7];
	mov.u32 	%r2, %tid.x;
	ld.param.u32 	%r19, [kernel_downy_1_s0__0__0_o___block_id_z_param_8];
	shl.b32 	%r20, %r12, 1;
	ld.param.u32 	%r21, [kernel_downy_1_s0__0__0_o___block_id_z_param_9];
	ld.param.u32 	%r22, [kernel_downy_1_s0__0__0_o___block_id_z_param_10];
	ld.param.u32 	%r23, [kernel_downy_1_s0__0__0_o___block_id_z_param_11];
	min.s32 	%r24, %r20, %r23;
	ld.param.u32 	%r25, [kernel_downy_1_s0__0__0_o___block_id_z_param_12];
	mad.lo.s32 	%r26, %r13, 14, %r22;
	ld.param.u32 	%r27, [kernel_downy_1_s0__0__0_o___block_id_z_param_13];
	ld.param.u32 	%r28, [kernel_downy_1_s0__0__0_o___block_id_z_param_14];
	min.s32 	%r3, %r26, %r21;
	shl.b32 	%r29, %r15, 3;
	ld.param.u32 	%r30, [kernel_downy_1_s0__0__0_o___block_id_z_param_17];
	add.s32 	%r31, %r29, %r30;
	min.s32 	%r4, %r31, %r19;
	mul.lo.s32 	%r5, %r17, 30;
	add.s32 	%r32, %r5, %r1;
	shl.b32 	%r33, %r32, 3;
	add.s32 	%r34, %r33, %r2;
	add.s32 	%r35, %r24, %r25;
	add.s32 	%r36, %r35, %r17;
	mul.wide.s32 	%rd6, %r36, %r28;
	shl.b32 	%r37, %r3, 1;
	add.s32 	%r38, %r37, %r1;
	min.s32 	%r39, %r38, %r16;
	max.s32 	%r40, %r39, 1;
	add.s32 	%r41, %r40, %r18;
	mul.wide.s32 	%rd7, %r41, %r14;
	add.s64 	%rd8, %rd7, %rd6;
	add.s32 	%r42, %r4, %r2;
	ld.param.s32 	%rd9, [kernel_downy_1_s0__0__0_o___block_id_z_param_4];
	shl.b32 	%r43, %r42, 1;
	add.s32 	%r44, %r43, 3;
	min.s32 	%r45, %r44, %r11;
	max.s32 	%r46, %r45, 1;
	not.b32 	%r47, %r27;
	add.s32 	%r48, %r46, %r47;
	cvt.s64.s32 	%rd10, %r48;
	min.s32 	%r49, %r43, %r11;
	max.s32 	%r50, %r49, 1;
	add.s32 	%r51, %r50, %r47;
	cvt.s64.s32 	%rd11, %r51;
	add.s32 	%r52, %r11, -1;
	min.s32 	%r53, %r43, %r52;
	max.s32 	%r54, %r53, 0;
	sub.s32 	%r55, %r54, %r27;
	cvt.s64.s32 	%rd12, %r55;
	add.s32 	%r56, %r43, 2;
	min.s32 	%r57, %r56, %r11;
	max.s32 	%r58, %r57, 1;
	add.s32 	%r59, %r58, %r47;
	cvt.s64.s32 	%rd13, %r59;
	add.s64 	%rd14, %rd8, %rd10;
	shl.b64 	%rd15, %rd14, 2;
	add.s64 	%rd16, %rd5, %rd15;
	ld.global.nc.f32 	%f1, [%rd16];
	add.s64 	%rd17, %rd8, %rd11;
	shl.b64 	%rd18, %rd17, 2;
	add.s64 	%rd19, %rd5, %rd18;
	ld.global.nc.f32 	%f2, [%rd19];
	add.s64 	%rd20, %rd8, %rd12;
	shl.b64 	%rd21, %rd20, 2;
	add.s64 	%rd22, %rd5, %rd21;
	ld.global.nc.f32 	%f3, [%rd22];
	add.s64 	%rd23, %rd8, %rd13;
	shl.b64 	%rd24, %rd23, 2;
	add.s64 	%rd25, %rd5, %rd24;
	ld.global.nc.f32 	%f4, [%rd25];
	add.ftz.f32 	%f5, %f3, %f4;
	fma.rn.ftz.f32 	%f6, %f5, 0f40400000, %f2;
	add.ftz.f32 	%f7, %f1, %f6;
	mul.ftz.f32 	%f8, %f7, 0f3E000000;
	mul.wide.u32 	%rd26, %r34, 4;
	st.shared.f32 	[%rd26], %f8;
	add.s64 	%rd27, %rd8, %rd9;
	add.s64 	%rd28, %rd27, %rd10;
	shl.b64 	%rd29, %rd28, 2;
	add.s64 	%rd30, %rd5, %rd29;
	ld.global.nc.f32 	%f9, [%rd30];
	add.s64 	%rd31, %rd27, %rd11;
	shl.b64 	%rd32, %rd31, 2;
	add.s64 	%rd33, %rd5, %rd32;
	ld.global.nc.f32 	%f10, [%rd33];
	add.s64 	%rd34, %rd27, %rd12;
	shl.b64 	%rd35, %rd34, 2;
	add.s64 	%rd36, %rd5, %rd35;
	ld.global.nc.f32 	%f11, [%rd36];
	add.s64 	%rd37, %rd27, %rd13;
	shl.b64 	%rd38, %rd37, 2;
	add.s64 	%rd39, %rd5, %rd38;
	ld.global.nc.f32 	%f12, [%rd39];
	add.ftz.f32 	%f13, %f11, %f12;
	fma.rn.ftz.f32 	%f14, %f13, 0f40400000, %f10;
	add.ftz.f32 	%f15, %f9, %f14;
	mul.ftz.f32 	%f16, %f15, 0f3E000000;
	st.shared.f32 	[%rd26+1920], %f16;
	bar.sync 	0;
	setp.gt.u32 	%p1, %r1, 13;
	@%p1 bra 	LBB5_2;
// %bb.1:                               // %true_bb
	ld.param.u32 	%r10, [kernel_downy_1_s0__0__0_o___block_id_z_param_16];
	ld.param.u32 	%r9, [kernel_downy_1_s0__0__0_o___block_id_z_param_15];
	ld.param.u32 	%r8, [kernel_downy_1_s0__0__0_o___block_id_z_param_3];
	ld.param.u32 	%r7, [kernel_downy_1_s0__0__0_o___block_id_z_param_2];
	ld.param.u32 	%r6, [kernel_downy_1_s0__0__0_o___block_id_z_param_0];
	ld.param.u64 	%rd3, [kernel_downy_1_s0__0__0_o___block_id_z_param_19];
	cvta.to.global.u64 	%rd1, %rd3;
	cvt.s64.s32 	%rd2, %r36;
	shl.b32 	%r60, %r1, 1;
	or.b32  	%r61, %r60, 1;
	add.s32 	%r62, %r61, %r5;
	shl.b32 	%r63, %r62, 3;
	add.s32 	%r64, %r63, %r2;
	cvt.s64.s32 	%rd40, %r6;
	mul.lo.s64 	%rd41, %rd2, %rd40;
	sub.s32 	%r65, %r1, %r9;
	add.s32 	%r66, %r65, %r3;
	mul.wide.s32 	%rd42, %r66, %r8;
	add.s64 	%rd43, %rd42, %rd41;
	sub.s32 	%r67, %r2, %r10;
	add.s32 	%r68, %r67, %r4;
	cvt.s64.s32 	%rd44, %r68;
	add.s64 	%rd45, %rd43, %rd44;
	mul.wide.u32 	%rd46, %r64, 4;
	ld.shared.f32 	%f17, [%rd46+64];
	ld.shared.f32 	%f18, [%rd46+-32];
	ld.shared.f32 	%f19, [%rd46];
	ld.shared.f32 	%f20, [%rd46+32];
	add.ftz.f32 	%f21, %f19, %f20;
	fma.rn.ftz.f32 	%f22, %f21, 0f40400000, %f18;
	add.ftz.f32 	%f23, %f17, %f22;
	mul.ftz.f32 	%f24, %f23, 0f3E000000;
	shl.b64 	%rd47, %rd45, 2;
	add.s64 	%rd48, %rd1, %rd47;
	st.global.f32 	[%rd48], %f24;
	ld.shared.f32 	%f25, [%rd46+1984];
	ld.shared.f32 	%f26, [%rd46+1888];
	ld.shared.f32 	%f27, [%rd46+1920];
	ld.shared.f32 	%f28, [%rd46+1952];
	add.ftz.f32 	%f29, %f27, %f28;
	fma.rn.ftz.f32 	%f30, %f29, 0f40400000, %f26;
	add.ftz.f32 	%f31, %f25, %f30;
	mul.ftz.f32 	%f32, %f31, 0f3E000000;
	mul.wide.s32 	%rd49, %r7, 4;
	add.s64 	%rd50, %rd48, %rd49;
	st.global.f32 	[%rd50], %f32;
LBB5_2:                                 // %after_bb
	ret;
}
                                        // -- End function
	// .globl	kernel_downy_2_s0__0__0_o___block_id_z // -- Begin function kernel_downy_2_s0__0__0_o___block_id_z
.visible .entry kernel_downy_2_s0__0__0_o___block_id_z(
	.param .u32 kernel_downy_2_s0__0__0_o___block_id_z_param_0,
	.param .u32 kernel_downy_2_s0__0__0_o___block_id_z_param_1,
	.param .u32 kernel_downy_2_s0__0__0_o___block_id_z_param_2,
	.param .u32 kernel_downy_2_s0__0__0_o___block_id_z_param_3,
	.param .u32 kernel_downy_2_s0__0__0_o___block_id_z_param_4,
	.param .u32 kernel_downy_2_s0__0__0_o___block_id_z_param_5,
	.param .u32 kernel_downy_2_s0__0__0_o___block_id_z_param_6,
	.param .u32 kernel_downy_2_s0__0__0_o___block_id_z_param_7,
	.param .u32 kernel_downy_2_s0__0__0_o___block_id_z_param_8,
	.param .u32 kernel_downy_2_s0__0__0_o___block_id_z_param_9,
	.param .u32 kernel_downy_2_s0__0__0_o___block_id_z_param_10,
	.param .u32 kernel_downy_2_s0__0__0_o___block_id_z_param_11,
	.param .u32 kernel_downy_2_s0__0__0_o___block_id_z_param_12,
	.param .u32 kernel_downy_2_s0__0__0_o___block_id_z_param_13,
	.param .u32 kernel_downy_2_s0__0__0_o___block_id_z_param_14,
	.param .u32 kernel_downy_2_s0__0__0_o___block_id_z_param_15,
	.param .u32 kernel_downy_2_s0__0__0_o___block_id_z_param_16,
	.param .u32 kernel_downy_2_s0__0__0_o___block_id_z_param_17,
	.param .u64 kernel_downy_2_s0__0__0_o___block_id_z_param_18,
	.param .u64 kernel_downy_2_s0__0__0_o___block_id_z_param_19
)                                       // @kernel_downy_2_s0__0__0_o___block_id_z
{
	.reg .pred 	%p<2>;
	.reg .f32 	%f<33>;
	.reg .b32 	%r<69>;
	.reg .b64 	%rd<51>;

// %bb.0:                               // %entry
	ld.param.u32 	%r11, [kernel_downy_2_s0__0__0_o___block_id_z_param_0];
	ld.param.u32 	%r12, [kernel_downy_2_s0__0__0_o___block_id_z_param_1];
	ld.param.u64 	%rd4, [kernel_downy_2_s0__0__0_o___block_id_z_param_18];
	cvta.to.global.u64 	%rd5, %rd4;
	mov.u32 	%r13, %ctaid.z;
	mov.u32 	%r14, %ctaid.y;
	ld.param.u32 	%r15, [kernel_downy_2_s0__0__0_o___block_id_z_param_5];
	mov.u32 	%r16, %ctaid.x;
	ld.param.u32 	%r17, [kernel_downy_2_s0__0__0_o___block_id_z_param_6];
	mov.u32 	%r18, %tid.z;
	mov.u32 	%r1, %tid.y;
	ld.param.u32 	%r19, [kernel_downy_2_s0__0__0_o___block_id_z_param_7];
	mov.u32 	%r2, %tid.x;
	ld.param.u32 	%r20, [kernel_downy_2_s0__0__0_o___block_id_z_param_8];
	shl.b32 	%r21, %r13, 1;
	ld.param.u32 	%r22, [kernel_downy_2_s0__0__0_o___block_id_z_param_9];
	ld.param.u32 	%r23, [kernel_downy_2_s0__0__0_o___block_id_z_param_10];
	ld.param.u32 	%r24, [kernel_downy_2_s0__0__0_o___block_id_z_param_11];
	min.s32 	%r25, %r21, %r24;
	ld.param.u32 	%r26, [kernel_downy_2_s0__0__0_o___block_id_z_param_12];
	mad.lo.s32 	%r27, %r14, 14, %r23;
	min.s32 	%r3, %r27, %r22;
	shl.b32 	%r28, %r16, 3;
	ld.param.u32 	%r29, [kernel_downy_2_s0__0__0_o___block_id_z_param_16];
	add.s32 	%r30, %r28, %r29;
	ld.param.u32 	%r31, [kernel_downy_2_s0__0__0_o___block_id_z_param_17];
	min.s32 	%r4, %r30, %r20;
	mul.lo.s32 	%r5, %r18, 30;
	add.s32 	%r32, %r5, %r1;
	shl.b32 	%r33, %r32, 3;
	add.s32 	%r34, %r33, %r2;
	add.s32 	%r35, %r25, %r26;
	add.s32 	%r36, %r35, %r18;
	mul.wide.s32 	%rd6, %r36, %r31;
	shl.b32 	%r37, %r3, 1;
	add.s32 	%r38, %r37, %r1;
	min.s32 	%r39, %r38, %r17;
	max.s32 	%r40, %r39, 1;
	add.s32 	%r41, %r40, %r19;
	mul.wide.s32 	%rd7, %r41, %r15;
	add.s64 	%rd8, %rd7, %rd6;
	add.s32 	%r42, %r4, %r2;
	ld.param.s32 	%rd9, [kernel_downy_2_s0__0__0_o___block_id_z_param_4];
	shl.b32 	%r43, %r42, 1;
	add.s32 	%r44, %r43, 3;
	min.s32 	%r45, %r44, %r12;
	max.s32 	%r46, %r45, 1;
	not.b32 	%r47, %r11;
	add.s32 	%r48, %r46, %r47;
	cvt.s64.s32 	%rd10, %r48;
	min.s32 	%r49, %r43, %r12;
	max.s32 	%r50, %r49, 1;
	add.s32 	%r51, %r50, %r47;
	cvt.s64.s32 	%rd11, %r51;
	add.s32 	%r52, %r12, -1;
	min.s32 	%r53, %r43, %r52;
	max.s32 	%r54, %r53, 0;
	sub.s32 	%r55, %r54, %r11;
	cvt.s64.s32 	%rd12, %r55;
	add.s32 	%r56, %r43, 2;
	min.s32 	%r57, %r56, %r12;
	max.s32 	%r58, %r57, 1;
	add.s32 	%r59, %r58, %r47;
	cvt.s64.s32 	%rd13, %r59;
	add.s64 	%rd14, %rd8, %rd10;
	shl.b64 	%rd15, %rd14, 2;
	add.s64 	%rd16, %rd5, %rd15;
	ld.global.nc.f32 	%f1, [%rd16];
	add.s64 	%rd17, %rd8, %rd11;
	shl.b64 	%rd18, %rd17, 2;
	add.s64 	%rd19, %rd5, %rd18;
	ld.global.nc.f32 	%f2, [%rd19];
	add.s64 	%rd20, %rd8, %rd12;
	shl.b64 	%rd21, %rd20, 2;
	add.s64 	%rd22, %rd5, %rd21;
	ld.global.nc.f32 	%f3, [%rd22];
	add.s64 	%rd23, %rd8, %rd13;
	shl.b64 	%rd24, %rd23, 2;
	add.s64 	%rd25, %rd5, %rd24;
	ld.global.nc.f32 	%f4, [%rd25];
	add.ftz.f32 	%f5, %f3, %f4;
	fma.rn.ftz.f32 	%f6, %f5, 0f40400000, %f2;
	add.ftz.f32 	%f7, %f1, %f6;
	mul.ftz.f32 	%f8, %f7, 0f3E000000;
	mul.wide.u32 	%rd26, %r34, 4;
	st.shared.f32 	[%rd26], %f8;
	add.s64 	%rd27, %rd8, %rd9;
	add.s64 	%rd28, %rd27, %rd10;
	shl.b64 	%rd29, %rd28, 2;
	add.s64 	%rd30, %rd5, %rd29;
	ld.global.nc.f32 	%f9, [%rd30];
	add.s64 	%rd31, %rd27, %rd11;
	shl.b64 	%rd32, %rd31, 2;
	add.s64 	%rd33, %rd5, %rd32;
	ld.global.nc.f32 	%f10, [%rd33];
	add.s64 	%rd34, %rd27, %rd12;
	shl.b64 	%rd35, %rd34, 2;
	add.s64 	%rd36, %rd5, %rd35;
	ld.global.nc.f32 	%f11, [%rd36];
	add.s64 	%rd37, %rd27, %rd13;
	shl.b64 	%rd38, %rd37, 2;
	add.s64 	%rd39, %rd5, %rd38;
	ld.global.nc.f32 	%f12, [%rd39];
	add.ftz.f32 	%f13, %f11, %f12;
	fma.rn.ftz.f32 	%f14, %f13, 0f40400000, %f10;
	add.ftz.f32 	%f15, %f9, %f14;
	mul.ftz.f32 	%f16, %f15, 0f3E000000;
	st.shared.f32 	[%rd26+1920], %f16;
	bar.sync 	0;
	setp.gt.u32 	%p1, %r1, 13;
	@%p1 bra 	LBB6_2;
// %bb.1:                               // %true_bb
	ld.param.u32 	%r10, [kernel_downy_2_s0__0__0_o___block_id_z_param_15];
	ld.param.u32 	%r9, [kernel_downy_2_s0__0__0_o___block_id_z_param_14];
	ld.param.u32 	%r8, [kernel_downy_2_s0__0__0_o___block_id_z_param_13];
	ld.param.u32 	%r7, [kernel_downy_2_s0__0__0_o___block_id_z_param_3];
	ld.param.u32 	%r6, [kernel_downy_2_s0__0__0_o___block_id_z_param_2];
	ld.param.u64 	%rd3, [kernel_downy_2_s0__0__0_o___block_id_z_param_19];
	cvta.to.global.u64 	%rd1, %rd3;
	cvt.s64.s32 	%rd2, %r36;
	shl.b32 	%r60, %r1, 1;
	or.b32  	%r61, %r60, 1;
	add.s32 	%r62, %r61, %r5;
	shl.b32 	%r63, %r62, 3;
	add.s32 	%r64, %r63, %r2;
	cvt.s64.s32 	%rd40, %r10;
	mul.lo.s64 	%rd41, %rd2, %rd40;
	sub.s32 	%r65, %r1, %r8;
	add.s32 	%r66, %r65, %r3;
	mul.wide.s32 	%rd42, %r66, %r7;
	add.s64 	%rd43, %rd42, %rd41;
	sub.s32 	%r67, %r2, %r9;
	add.s32 	%r68, %r67, %r4;
	cvt.s64.s32 	%rd44, %r68;
	add.s64 	%rd45, %rd43, %rd44;
	mul.wide.u32 	%rd46, %r64, 4;
	ld.shared.f32 	%f17, [%rd46+64];
	ld.shared.f32 	%f18, [%rd46+-32];
	ld.shared.f32 	%f19, [%rd46];
	ld.shared.f32 	%f20, [%rd46+32];
	add.ftz.f32 	%f21, %f19, %f20;
	fma.rn.ftz.f32 	%f22, %f21, 0f40400000, %f18;
	add.ftz.f32 	%f23, %f17, %f22;
	mul.ftz.f32 	%f24, %f23, 0f3E000000;
	shl.b64 	%rd47, %rd45, 2;
	add.s64 	%rd48, %rd1, %rd47;
	st.global.f32 	[%rd48], %f24;
	ld.shared.f32 	%f25, [%rd46+1984];
	ld.shared.f32 	%f26, [%rd46+1888];
	ld.shared.f32 	%f27, [%rd46+1920];
	ld.shared.f32 	%f28, [%rd46+1952];
	add.ftz.f32 	%f29, %f27, %f28;
	fma.rn.ftz.f32 	%f30, %f29, 0f40400000, %f26;
	add.ftz.f32 	%f31, %f25, %f30;
	mul.ftz.f32 	%f32, %f31, 0f3E000000;
	mul.wide.s32 	%rd49, %r6, 4;
	add.s64 	%rd50, %rd48, %rd49;
	st.global.f32 	[%rd50], %f32;
LBB6_2:                                 // %after_bb
	ret;
}
                                        // -- End function
	// .globl	kernel_downy_3_s0__0__0_o___block_id_z // -- Begin function kernel_downy_3_s0__0__0_o___block_id_z
.visible .entry kernel_downy_3_s0__0__0_o___block_id_z(
	.param .u32 kernel_downy_3_s0__0__0_o___block_id_z_param_0,
	.param .u32 kernel_downy_3_s0__0__0_o___block_id_z_param_1,
	.param .u32 kernel_downy_3_s0__0__0_o___block_id_z_param_2,
	.param .u32 kernel_downy_3_s0__0__0_o___block_id_z_param_3,
	.param .u32 kernel_downy_3_s0__0__0_o___block_id_z_param_4,
	.param .u32 kernel_downy_3_s0__0__0_o___block_id_z_param_5,
	.param .u32 kernel_downy_3_s0__0__0_o___block_id_z_param_6,
	.param .u32 kernel_downy_3_s0__0__0_o___block_id_z_param_7,
	.param .u32 kernel_downy_3_s0__0__0_o___block_id_z_param_8,
	.param .u32 kernel_downy_3_s0__0__0_o___block_id_z_param_9,
	.param .u32 kernel_downy_3_s0__0__0_o___block_id_z_param_10,
	.param .u32 kernel_downy_3_s0__0__0_o___block_id_z_param_11,
	.param .u32 kernel_downy_3_s0__0__0_o___block_id_z_param_12,
	.param .u32 kernel_downy_3_s0__0__0_o___block_id_z_param_13,
	.param .u32 kernel_downy_3_s0__0__0_o___block_id_z_param_14,
	.param .u32 kernel_downy_3_s0__0__0_o___block_id_z_param_15,
	.param .u32 kernel_downy_3_s0__0__0_o___block_id_z_param_16,
	.param .u32 kernel_downy_3_s0__0__0_o___block_id_z_param_17,
	.param .u64 kernel_downy_3_s0__0__0_o___block_id_z_param_18,
	.param .u64 kernel_downy_3_s0__0__0_o___block_id_z_param_19
)                                       // @kernel_downy_3_s0__0__0_o___block_id_z
{
	.reg .pred 	%p<2>;
	.reg .f32 	%f<33>;
	.reg .b32 	%r<69>;
	.reg .b64 	%rd<51>;

// %bb.0:                               // %entry
	ld.param.u32 	%r11, [kernel_downy_3_s0__0__0_o___block_id_z_param_0];
	ld.param.u32 	%r12, [kernel_downy_3_s0__0__0_o___block_id_z_param_1];
	ld.param.u64 	%rd4, [kernel_downy_3_s0__0__0_o___block_id_z_param_18];
	cvta.to.global.u64 	%rd5, %rd4;
	mov.u32 	%r13, %ctaid.z;
	mov.u32 	%r14, %ctaid.y;
	ld.param.u32 	%r15, [kernel_downy_3_s0__0__0_o___block_id_z_param_5];
	mov.u32 	%r16, %ctaid.x;
	ld.param.u32 	%r17, [kernel_downy_3_s0__0__0_o___block_id_z_param_6];
	mov.u32 	%r18, %tid.z;
	mov.u32 	%r1, %tid.y;
	ld.param.u32 	%r19, [kernel_downy_3_s0__0__0_o___block_id_z_param_7];
	mov.u32 	%r2, %tid.x;
	ld.param.u32 	%r20, [kernel_downy_3_s0__0__0_o___block_id_z_param_8];
	shl.b32 	%r21, %r13, 1;
	ld.param.u32 	%r22, [kernel_downy_3_s0__0__0_o___block_id_z_param_9];
	ld.param.u32 	%r23, [kernel_downy_3_s0__0__0_o___block_id_z_param_10];
	ld.param.u32 	%r24, [kernel_downy_3_s0__0__0_o___block_id_z_param_11];
	min.s32 	%r25, %r21, %r24;
	ld.param.u32 	%r26, [kernel_downy_3_s0__0__0_o___block_id_z_param_12];
	mad.lo.s32 	%r27, %r14, 14, %r23;
	min.s32 	%r3, %r27, %r22;
	shl.b32 	%r28, %r16, 3;
	ld.param.u32 	%r29, [kernel_downy_3_s0__0__0_o___block_id_z_param_16];
	add.s32 	%r30, %r28, %r29;
	ld.param.u32 	%r31, [kernel_downy_3_s0__0__0_o___block_id_z_param_17];
	min.s32 	%r4, %r30, %r20;
	mul.lo.s32 	%r5, %r18, 30;
	add.s32 	%r32, %r5, %r1;
	shl.b32 	%r33, %r32, 3;
	add.s32 	%r34, %r33, %r2;
	add.s32 	%r35, %r25, %r26;
	add.s32 	%r36, %r35, %r18;
	mul.wide.s32 	%rd6, %r36, %r31;
	shl.b32 	%r37, %r3, 1;
	add.s32 	%r38, %r37, %r1;
	min.s32 	%r39, %r38, %r17;
	max.s32 	%r40, %r39, 1;
	add.s32 	%r41, %r40, %r19;
	mul.wide.s32 	%rd7, %r41, %r15;
	add.s64 	%rd8, %rd7, %rd6;
	add.s32 	%r42, %r4, %r2;
	ld.param.s32 	%rd9, [kernel_downy_3_s0__0__0_o___block_id_z_param_4];
	shl.b32 	%r43, %r42, 1;
	add.s32 	%r44, %r43, 3;
	min.s32 	%r45, %r44, %r12;
	max.s32 	%r46, %r45, 1;
	not.b32 	%r47, %r11;
	add.s32 	%r48, %r46, %r47;
	cvt.s64.s32 	%rd10, %r48;
	min.s32 	%r49, %r43, %r12;
	max.s32 	%r50, %r49, 1;
	add.s32 	%r51, %r50, %r47;
	cvt.s64.s32 	%rd11, %r51;
	add.s32 	%r52, %r12, -1;
	min.s32 	%r53, %r43, %r52;
	max.s32 	%r54, %r53, 0;
	sub.s32 	%r55, %r54, %r11;
	cvt.s64.s32 	%rd12, %r55;
	add.s32 	%r56, %r43, 2;
	min.s32 	%r57, %r56, %r12;
	max.s32 	%r58, %r57, 1;
	add.s32 	%r59, %r58, %r47;
	cvt.s64.s32 	%rd13, %r59;
	add.s64 	%rd14, %rd8, %rd10;
	shl.b64 	%rd15, %rd14, 2;
	add.s64 	%rd16, %rd5, %rd15;
	ld.global.nc.f32 	%f1, [%rd16];
	add.s64 	%rd17, %rd8, %rd11;
	shl.b64 	%rd18, %rd17, 2;
	add.s64 	%rd19, %rd5, %rd18;
	ld.global.nc.f32 	%f2, [%rd19];
	add.s64 	%rd20, %rd8, %rd12;
	shl.b64 	%rd21, %rd20, 2;
	add.s64 	%rd22, %rd5, %rd21;
	ld.global.nc.f32 	%f3, [%rd22];
	add.s64 	%rd23, %rd8, %rd13;
	shl.b64 	%rd24, %rd23, 2;
	add.s64 	%rd25, %rd5, %rd24;
	ld.global.nc.f32 	%f4, [%rd25];
	add.ftz.f32 	%f5, %f3, %f4;
	fma.rn.ftz.f32 	%f6, %f5, 0f40400000, %f2;
	add.ftz.f32 	%f7, %f1, %f6;
	mul.ftz.f32 	%f8, %f7, 0f3E000000;
	mul.wide.u32 	%rd26, %r34, 4;
	st.shared.f32 	[%rd26], %f8;
	add.s64 	%rd27, %rd8, %rd9;
	add.s64 	%rd28, %rd27, %rd10;
	shl.b64 	%rd29, %rd28, 2;
	add.s64 	%rd30, %rd5, %rd29;
	ld.global.nc.f32 	%f9, [%rd30];
	add.s64 	%rd31, %rd27, %rd11;
	shl.b64 	%rd32, %rd31, 2;
	add.s64 	%rd33, %rd5, %rd32;
	ld.global.nc.f32 	%f10, [%rd33];
	add.s64 	%rd34, %rd27, %rd12;
	shl.b64 	%rd35, %rd34, 2;
	add.s64 	%rd36, %rd5, %rd35;
	ld.global.nc.f32 	%f11, [%rd36];
	add.s64 	%rd37, %rd27, %rd13;
	shl.b64 	%rd38, %rd37, 2;
	add.s64 	%rd39, %rd5, %rd38;
	ld.global.nc.f32 	%f12, [%rd39];
	add.ftz.f32 	%f13, %f11, %f12;
	fma.rn.ftz.f32 	%f14, %f13, 0f40400000, %f10;
	add.ftz.f32 	%f15, %f9, %f14;
	mul.ftz.f32 	%f16, %f15, 0f3E000000;
	st.shared.f32 	[%rd26+1920], %f16;
	bar.sync 	0;
	setp.gt.u32 	%p1, %r1, 13;
	@%p1 bra 	LBB7_2;
// %bb.1:                               // %true_bb
	ld.param.u32 	%r10, [kernel_downy_3_s0__0__0_o___block_id_z_param_15];
	ld.param.u32 	%r9, [kernel_downy_3_s0__0__0_o___block_id_z_param_14];
	ld.param.u32 	%r8, [kernel_downy_3_s0__0__0_o___block_id_z_param_13];
	ld.param.u32 	%r7, [kernel_downy_3_s0__0__0_o___block_id_z_param_3];
	ld.param.u32 	%r6, [kernel_downy_3_s0__0__0_o___block_id_z_param_2];
	ld.param.u64 	%rd3, [kernel_downy_3_s0__0__0_o___block_id_z_param_19];
	cvta.to.global.u64 	%rd1, %rd3;
	cvt.s64.s32 	%rd2, %r36;
	shl.b32 	%r60, %r1, 1;
	or.b32  	%r61, %r60, 1;
	add.s32 	%r62, %r61, %r5;
	shl.b32 	%r63, %r62, 3;
	add.s32 	%r64, %r63, %r2;
	cvt.s64.s32 	%rd40, %r10;
	mul.lo.s64 	%rd41, %rd2, %rd40;
	sub.s32 	%r65, %r1, %r8;
	add.s32 	%r66, %r65, %r3;
	mul.wide.s32 	%rd42, %r66, %r7;
	add.s64 	%rd43, %rd42, %rd41;
	sub.s32 	%r67, %r2, %r9;
	add.s32 	%r68, %r67, %r4;
	cvt.s64.s32 	%rd44, %r68;
	add.s64 	%rd45, %rd43, %rd44;
	mul.wide.u32 	%rd46, %r64, 4;
	ld.shared.f32 	%f17, [%rd46+64];
	ld.shared.f32 	%f18, [%rd46+-32];
	ld.shared.f32 	%f19, [%rd46];
	ld.shared.f32 	%f20, [%rd46+32];
	add.ftz.f32 	%f21, %f19, %f20;
	fma.rn.ftz.f32 	%f22, %f21, 0f40400000, %f18;
	add.ftz.f32 	%f23, %f17, %f22;
	mul.ftz.f32 	%f24, %f23, 0f3E000000;
	shl.b64 	%rd47, %rd45, 2;
	add.s64 	%rd48, %rd1, %rd47;
	st.global.f32 	[%rd48], %f24;
	ld.shared.f32 	%f25, [%rd46+1984];
	ld.shared.f32 	%f26, [%rd46+1888];
	ld.shared.f32 	%f27, [%rd46+1920];
	ld.shared.f32 	%f28, [%rd46+1952];
	add.ftz.f32 	%f29, %f27, %f28;
	fma.rn.ftz.f32 	%f30, %f29, 0f40400000, %f26;
	add.ftz.f32 	%f31, %f25, %f30;
	mul.ftz.f32 	%f32, %f31, 0f3E000000;
	mul.wide.s32 	%rd49, %r6, 4;
	add.s64 	%rd50, %rd48, %rd49;
	st.global.f32 	[%rd50], %f32;
LBB7_2:                                 // %after_bb
	ret;
}
                                        // -- End function
	// .globl	kernel_downy_4_s0__0__0_o___block_id_z // -- Begin function kernel_downy_4_s0__0__0_o___block_id_z
.visible .entry kernel_downy_4_s0__0__0_o___block_id_z(
	.param .u32 kernel_downy_4_s0__0__0_o___block_id_z_param_0,
	.param .u32 kernel_downy_4_s0__0__0_o___block_id_z_param_1,
	.param .u32 kernel_downy_4_s0__0__0_o___block_id_z_param_2,
	.param .u32 kernel_downy_4_s0__0__0_o___block_id_z_param_3,
	.param .u32 kernel_downy_4_s0__0__0_o___block_id_z_param_4,
	.param .u32 kernel_downy_4_s0__0__0_o___block_id_z_param_5,
	.param .u32 kernel_downy_4_s0__0__0_o___block_id_z_param_6,
	.param .u32 kernel_downy_4_s0__0__0_o___block_id_z_param_7,
	.param .u32 kernel_downy_4_s0__0__0_o___block_id_z_param_8,
	.param .u32 kernel_downy_4_s0__0__0_o___block_id_z_param_9,
	.param .u32 kernel_downy_4_s0__0__0_o___block_id_z_param_10,
	.param .u32 kernel_downy_4_s0__0__0_o___block_id_z_param_11,
	.param .u32 kernel_downy_4_s0__0__0_o___block_id_z_param_12,
	.param .u32 kernel_downy_4_s0__0__0_o___block_id_z_param_13,
	.param .u32 kernel_downy_4_s0__0__0_o___block_id_z_param_14,
	.param .u32 kernel_downy_4_s0__0__0_o___block_id_z_param_15,
	.param .u32 kernel_downy_4_s0__0__0_o___block_id_z_param_16,
	.param .u32 kernel_downy_4_s0__0__0_o___block_id_z_param_17,
	.param .u64 kernel_downy_4_s0__0__0_o___block_id_z_param_18,
	.param .u64 kernel_downy_4_s0__0__0_o___block_id_z_param_19
)                                       // @kernel_downy_4_s0__0__0_o___block_id_z
{
	.reg .pred 	%p<2>;
	.reg .f32 	%f<33>;
	.reg .b32 	%r<69>;
	.reg .b64 	%rd<51>;

// %bb.0:                               // %entry
	ld.param.u32 	%r11, [kernel_downy_4_s0__0__0_o___block_id_z_param_0];
	ld.param.u32 	%r12, [kernel_downy_4_s0__0__0_o___block_id_z_param_1];
	ld.param.u64 	%rd4, [kernel_downy_4_s0__0__0_o___block_id_z_param_18];
	cvta.to.global.u64 	%rd5, %rd4;
	mov.u32 	%r13, %ctaid.z;
	mov.u32 	%r14, %ctaid.y;
	ld.param.u32 	%r15, [kernel_downy_4_s0__0__0_o___block_id_z_param_5];
	mov.u32 	%r16, %ctaid.x;
	ld.param.u32 	%r17, [kernel_downy_4_s0__0__0_o___block_id_z_param_6];
	mov.u32 	%r18, %tid.z;
	mov.u32 	%r1, %tid.y;
	ld.param.u32 	%r19, [kernel_downy_4_s0__0__0_o___block_id_z_param_7];
	mov.u32 	%r2, %tid.x;
	ld.param.u32 	%r20, [kernel_downy_4_s0__0__0_o___block_id_z_param_8];
	shl.b32 	%r21, %r13, 1;
	ld.param.u32 	%r22, [kernel_downy_4_s0__0__0_o___block_id_z_param_9];
	ld.param.u32 	%r23, [kernel_downy_4_s0__0__0_o___block_id_z_param_10];
	ld.param.u32 	%r24, [kernel_downy_4_s0__0__0_o___block_id_z_param_11];
	min.s32 	%r25, %r21, %r24;
	ld.param.u32 	%r26, [kernel_downy_4_s0__0__0_o___block_id_z_param_12];
	mad.lo.s32 	%r27, %r14, 14, %r23;
	min.s32 	%r3, %r27, %r22;
	shl.b32 	%r28, %r16, 3;
	ld.param.u32 	%r29, [kernel_downy_4_s0__0__0_o___block_id_z_param_16];
	add.s32 	%r30, %r28, %r29;
	ld.param.u32 	%r31, [kernel_downy_4_s0__0__0_o___block_id_z_param_17];
	min.s32 	%r4, %r30, %r20;
	mul.lo.s32 	%r5, %r18, 30;
	add.s32 	%r32, %r5, %r1;
	shl.b32 	%r33, %r32, 3;
	add.s32 	%r34, %r33, %r2;
	add.s32 	%r35, %r25, %r26;
	add.s32 	%r36, %r35, %r18;
	mul.wide.s32 	%rd6, %r36, %r31;
	shl.b32 	%r37, %r3, 1;
	add.s32 	%r38, %r37, %r1;
	min.s32 	%r39, %r38, %r17;
	max.s32 	%r40, %r39, 1;
	add.s32 	%r41, %r40, %r19;
	mul.wide.s32 	%rd7, %r41, %r15;
	add.s64 	%rd8, %rd7, %rd6;
	add.s32 	%r42, %r4, %r2;
	ld.param.s32 	%rd9, [kernel_downy_4_s0__0__0_o___block_id_z_param_4];
	shl.b32 	%r43, %r42, 1;
	add.s32 	%r44, %r43, 3;
	min.s32 	%r45, %r44, %r12;
	max.s32 	%r46, %r45, 1;
	not.b32 	%r47, %r11;
	add.s32 	%r48, %r46, %r47;
	cvt.s64.s32 	%rd10, %r48;
	min.s32 	%r49, %r43, %r12;
	max.s32 	%r50, %r49, 1;
	add.s32 	%r51, %r50, %r47;
	cvt.s64.s32 	%rd11, %r51;
	add.s32 	%r52, %r12, -1;
	min.s32 	%r53, %r43, %r52;
	max.s32 	%r54, %r53, 0;
	sub.s32 	%r55, %r54, %r11;
	cvt.s64.s32 	%rd12, %r55;
	add.s32 	%r56, %r43, 2;
	min.s32 	%r57, %r56, %r12;
	max.s32 	%r58, %r57, 1;
	add.s32 	%r59, %r58, %r47;
	cvt.s64.s32 	%rd13, %r59;
	add.s64 	%rd14, %rd8, %rd10;
	shl.b64 	%rd15, %rd14, 2;
	add.s64 	%rd16, %rd5, %rd15;
	ld.global.nc.f32 	%f1, [%rd16];
	add.s64 	%rd17, %rd8, %rd11;
	shl.b64 	%rd18, %rd17, 2;
	add.s64 	%rd19, %rd5, %rd18;
	ld.global.nc.f32 	%f2, [%rd19];
	add.s64 	%rd20, %rd8, %rd12;
	shl.b64 	%rd21, %rd20, 2;
	add.s64 	%rd22, %rd5, %rd21;
	ld.global.nc.f32 	%f3, [%rd22];
	add.s64 	%rd23, %rd8, %rd13;
	shl.b64 	%rd24, %rd23, 2;
	add.s64 	%rd25, %rd5, %rd24;
	ld.global.nc.f32 	%f4, [%rd25];
	add.ftz.f32 	%f5, %f3, %f4;
	fma.rn.ftz.f32 	%f6, %f5, 0f40400000, %f2;
	add.ftz.f32 	%f7, %f1, %f6;
	mul.ftz.f32 	%f8, %f7, 0f3E000000;
	mul.wide.u32 	%rd26, %r34, 4;
	st.shared.f32 	[%rd26], %f8;
	add.s64 	%rd27, %rd8, %rd9;
	add.s64 	%rd28, %rd27, %rd10;
	shl.b64 	%rd29, %rd28, 2;
	add.s64 	%rd30, %rd5, %rd29;
	ld.global.nc.f32 	%f9, [%rd30];
	add.s64 	%rd31, %rd27, %rd11;
	shl.b64 	%rd32, %rd31, 2;
	add.s64 	%rd33, %rd5, %rd32;
	ld.global.nc.f32 	%f10, [%rd33];
	add.s64 	%rd34, %rd27, %rd12;
	shl.b64 	%rd35, %rd34, 2;
	add.s64 	%rd36, %rd5, %rd35;
	ld.global.nc.f32 	%f11, [%rd36];
	add.s64 	%rd37, %rd27, %rd13;
	shl.b64 	%rd38, %rd37, 2;
	add.s64 	%rd39, %rd5, %rd38;
	ld.global.nc.f32 	%f12, [%rd39];
	add.ftz.f32 	%f13, %f11, %f12;
	fma.rn.ftz.f32 	%f14, %f13, 0f40400000, %f10;
	add.ftz.f32 	%f15, %f9, %f14;
	mul.ftz.f32 	%f16, %f15, 0f3E000000;
	st.shared.f32 	[%rd26+1920], %f16;
	bar.sync 	0;
	setp.gt.u32 	%p1, %r1, 13;
	@%p1 bra 	LBB8_2;
// %bb.1:                               // %true_bb
	ld.param.u32 	%r10, [kernel_downy_4_s0__0__0_o___block_id_z_param_15];
	ld.param.u32 	%r9, [kernel_downy_4_s0__0__0_o___block_id_z_param_14];
	ld.param.u32 	%r8, [kernel_downy_4_s0__0__0_o___block_id_z_param_13];
	ld.param.u32 	%r7, [kernel_downy_4_s0__0__0_o___block_id_z_param_3];
	ld.param.u32 	%r6, [kernel_downy_4_s0__0__0_o___block_id_z_param_2];
	ld.param.u64 	%rd3, [kernel_downy_4_s0__0__0_o___block_id_z_param_19];
	cvta.to.global.u64 	%rd1, %rd3;
	cvt.s64.s32 	%rd2, %r36;
	shl.b32 	%r60, %r1, 1;
	or.b32  	%r61, %r60, 1;
	add.s32 	%r62, %r61, %r5;
	shl.b32 	%r63, %r62, 3;
	add.s32 	%r64, %r63, %r2;
	cvt.s64.s32 	%rd40, %r10;
	mul.lo.s64 	%rd41, %rd2, %rd40;
	sub.s32 	%r65, %r1, %r8;
	add.s32 	%r66, %r65, %r3;
	mul.wide.s32 	%rd42, %r66, %r7;
	add.s64 	%rd43, %rd42, %rd41;
	sub.s32 	%r67, %r2, %r9;
	add.s32 	%r68, %r67, %r4;
	cvt.s64.s32 	%rd44, %r68;
	add.s64 	%rd45, %rd43, %rd44;
	mul.wide.u32 	%rd46, %r64, 4;
	ld.shared.f32 	%f17, [%rd46+64];
	ld.shared.f32 	%f18, [%rd46+-32];
	ld.shared.f32 	%f19, [%rd46];
	ld.shared.f32 	%f20, [%rd46+32];
	add.ftz.f32 	%f21, %f19, %f20;
	fma.rn.ftz.f32 	%f22, %f21, 0f40400000, %f18;
	add.ftz.f32 	%f23, %f17, %f22;
	mul.ftz.f32 	%f24, %f23, 0f3E000000;
	shl.b64 	%rd47, %rd45, 2;
	add.s64 	%rd48, %rd1, %rd47;
	st.global.f32 	[%rd48], %f24;
	ld.shared.f32 	%f25, [%rd46+1984];
	ld.shared.f32 	%f26, [%rd46+1888];
	ld.shared.f32 	%f27, [%rd46+1920];
	ld.shared.f32 	%f28, [%rd46+1952];
	add.ftz.f32 	%f29, %f27, %f28;
	fma.rn.ftz.f32 	%f30, %f29, 0f40400000, %f26;
	add.ftz.f32 	%f31, %f25, %f30;
	mul.ftz.f32 	%f32, %f31, 0f3E000000;
	mul.wide.s32 	%rd49, %r6, 4;
	add.s64 	%rd50, %rd48, %rd49;
	st.global.f32 	[%rd50], %f32;
LBB8_2:                                 // %after_bb
	ret;
}
                                        // -- End function
	// .globl	kernel_downy_5_s0__0__0_o___block_id_y // -- Begin function kernel_downy_5_s0__0__0_o___block_id_y
.visible .entry kernel_downy_5_s0__0__0_o___block_id_y(
	.param .u32 kernel_downy_5_s0__0__0_o___block_id_y_param_0,
	.param .u32 kernel_downy_5_s0__0__0_o___block_id_y_param_1,
	.param .u32 kernel_downy_5_s0__0__0_o___block_id_y_param_2,
	.param .u32 kernel_downy_5_s0__0__0_o___block_id_y_param_3,
	.param .u32 kernel_downy_5_s0__0__0_o___block_id_y_param_4,
	.param .u32 kernel_downy_5_s0__0__0_o___block_id_y_param_5,
	.param .u32 kernel_downy_5_s0__0__0_o___block_id_y_param_6,
	.param .u32 kernel_downy_5_s0__0__0_o___block_id_y_param_7,
	.param .u32 kernel_downy_5_s0__0__0_o___block_id_y_param_8,
	.param .u32 kernel_downy_5_s0__0__0_o___block_id_y_param_9,
	.param .u32 kernel_downy_5_s0__0__0_o___block_id_y_param_10,
	.param .u32 kernel_downy_5_s0__0__0_o___block_id_y_param_11,
	.param .u32 kernel_downy_5_s0__0__0_o___block_id_y_param_12,
	.param .u32 kernel_downy_5_s0__0__0_o___block_id_y_param_13,
	.param .u32 kernel_downy_5_s0__0__0_o___block_id_y_param_14,
	.param .u32 kernel_downy_5_s0__0__0_o___block_id_y_param_15,
	.param .u32 kernel_downy_5_s0__0__0_o___block_id_y_param_16,
	.param .u32 kernel_downy_5_s0__0__0_o___block_id_y_param_17,
	.param .u32 kernel_downy_5_s0__0__0_o___block_id_y_param_18,
	.param .u64 kernel_downy_5_s0__0__0_o___block_id_y_param_19,
	.param .u64 kernel_downy_5_s0__0__0_o___block_id_y_param_20
)                                       // @kernel_downy_5_s0__0__0_o___block_id_y
{
	.reg .pred 	%p<4>;
	.reg .f32 	%f<33>;
	.reg .b32 	%r<64>;
	.reg .b64 	%rd<60>;

// %bb.0:                               // %entry
	ld.param.u32 	%r62, [kernel_downy_5_s0__0__0_o___block_id_y_param_4];
	setp.lt.s32 	%p1, %r62, 1;
	@%p1 bra 	LBB9_5;
// %bb.1:                               // %"for downy$5.s0.x.preheader"
	ld.param.u32 	%r17, [kernel_downy_5_s0__0__0_o___block_id_y_param_15];
	ld.param.u32 	%r16, [kernel_downy_5_s0__0__0_o___block_id_y_param_5];
	ld.param.u32 	%r14, [kernel_downy_5_s0__0__0_o___block_id_y_param_3];
	ld.param.u32 	%r13, [kernel_downy_5_s0__0__0_o___block_id_y_param_2];
	ld.param.u32 	%r12, [kernel_downy_5_s0__0__0_o___block_id_y_param_1];
	ld.param.u32 	%r11, [kernel_downy_5_s0__0__0_o___block_id_y_param_0];
	ld.param.u64 	%rd16, [kernel_downy_5_s0__0__0_o___block_id_y_param_20];
	cvta.to.global.u64 	%rd1, %rd16;
	ld.param.u64 	%rd17, [kernel_downy_5_s0__0__0_o___block_id_y_param_19];
	cvta.to.global.u64 	%rd2, %rd17;
	mov.u32 	%r18, %ctaid.y;
	mov.u32 	%r19, %ctaid.x;
	mov.u32 	%r20, %tid.y;
	mov.u32 	%r1, %tid.x;
	ld.param.u32 	%r21, [kernel_downy_5_s0__0__0_o___block_id_y_param_6];
	shl.b32 	%r22, %r18, 1;
	ld.param.u32 	%r23, [kernel_downy_5_s0__0__0_o___block_id_y_param_7];
	ld.param.u32 	%r24, [kernel_downy_5_s0__0__0_o___block_id_y_param_8];
	ld.param.u32 	%r25, [kernel_downy_5_s0__0__0_o___block_id_y_param_12];
	min.s32 	%r26, %r22, %r25;
	ld.param.u32 	%r27, [kernel_downy_5_s0__0__0_o___block_id_y_param_9];
	shl.b32 	%r28, %r19, 1;
	ld.param.u32 	%r29, [kernel_downy_5_s0__0__0_o___block_id_y_param_10];
	ld.param.u32 	%r30, [kernel_downy_5_s0__0__0_o___block_id_y_param_11];
	add.s32 	%r31, %r28, %r30;
	ld.param.u32 	%r32, [kernel_downy_5_s0__0__0_o___block_id_y_param_17];
	min.s32 	%r33, %r31, %r32;
	ld.param.u32 	%r34, [kernel_downy_5_s0__0__0_o___block_id_y_param_13];
	mul.lo.s32 	%r2, %r20, 6;
	ld.param.u32 	%r35, [kernel_downy_5_s0__0__0_o___block_id_y_param_14];
	shl.b32 	%r3, %r1, 1;
	add.s32 	%r36, %r26, %r20;
	ld.param.u32 	%r37, [kernel_downy_5_s0__0__0_o___block_id_y_param_16];
	add.s32 	%r38, %r36, %r34;
	ld.param.u32 	%r39, [kernel_downy_5_s0__0__0_o___block_id_y_param_18];
	mul.wide.s32 	%rd3, %r38, %r37;
	add.s32 	%r40, %r1, %r29;
	add.s32 	%r41, %r40, %r33;
	mul.wide.s32 	%rd4, %r41, %r27;
	add.s32 	%r42, %r36, %r35;
	mul.wide.s32 	%rd18, %r42, %r39;
	shl.b32 	%r43, %r33, 1;
	add.s32 	%r44, %r43, %r1;
	min.s32 	%r45, %r44, %r23;
	max.s32 	%r46, %r45, 3;
	add.s32 	%r47, %r46, %r24;
	mul.wide.s32 	%rd19, %r47, %r21;
	add.s64 	%rd5, %rd19, %rd18;
	add.s32 	%r48, %r2, %r1;
	cvt.u64.u32 	%rd6, %r48;
	add.s32 	%r4, %r12, -1;
	not.b32 	%r5, %r11;
	cvt.s64.s32 	%rd20, %r14;
	shl.b64 	%rd7, %rd6, 2;
	add.s64 	%rd8, %rd5, %rd20;
	cvt.u64.u32 	%rd21, %r2;
	cvt.u64.u32 	%rd22, %r3;
	add.s64 	%rd23, %rd22, %rd21;
	shl.b64 	%rd11, %rd23, 2;
	add.s64 	%rd9, %rd11, 8;
	add.s64 	%rd10, %rd11, -4;
	shl.b32 	%r63, %r16, 1;
	mul.wide.s32 	%rd12, %r13, 4;
	add.s64 	%rd24, %rd3, %rd4;
	cvt.s64.s32 	%rd25, %r16;
	add.s64 	%rd26, %rd24, %rd25;
	cvt.s64.s32 	%rd27, %r17;
	sub.s64 	%rd28, %rd26, %rd27;
	shl.b64 	%rd29, %rd28, 2;
	add.s64 	%rd59, %rd1, %rd29;
	setp.lt.u32 	%p2, %r1, 2;
LBB9_2:                                 // %"for downy$5.s0.x"
                                        // =>This Inner Loop Header: Depth=1
	min.s32 	%r49, %r63, %r4;
	min.s32 	%r50, %r63, %r12;
	add.s32 	%r51, %r63, 3;
	min.s32 	%r52, %r51, %r12;
	add.s32 	%r63, %r63, 2;
	min.s32 	%r53, %r63, %r12;
	max.s32 	%r54, %r49, 0;
	sub.s32 	%r55, %r54, %r11;
	cvt.s64.s32 	%rd30, %r55;
	max.s32 	%r56, %r53, 1;
	add.s32 	%r57, %r56, %r5;
	cvt.s64.s32 	%rd31, %r57;
	max.s32 	%r58, %r50, 1;
	add.s32 	%r59, %r58, %r5;
	cvt.s64.s32 	%rd32, %r59;
	max.s32 	%r60, %r52, 1;
	add.s32 	%r61, %r60, %r5;
	cvt.s64.s32 	%rd33, %r61;
	add.s64 	%rd34, %rd5, %rd33;
	shl.b64 	%rd35, %rd34, 2;
	add.s64 	%rd36, %rd2, %rd35;
	ld.global.nc.f32 	%f1, [%rd36];
	add.s64 	%rd37, %rd5, %rd32;
	shl.b64 	%rd38, %rd37, 2;
	add.s64 	%rd39, %rd2, %rd38;
	ld.global.nc.f32 	%f2, [%rd39];
	add.s64 	%rd40, %rd5, %rd30;
	shl.b64 	%rd41, %rd40, 2;
	add.s64 	%rd42, %rd2, %rd41;
	ld.global.nc.f32 	%f3, [%rd42];
	add.s64 	%rd43, %rd5, %rd31;
	shl.b64 	%rd44, %rd43, 2;
	add.s64 	%rd45, %rd2, %rd44;
	ld.global.nc.f32 	%f4, [%rd45];
	add.ftz.f32 	%f5, %f3, %f4;
	fma.rn.ftz.f32 	%f6, %f5, 0f40400000, %f2;
	add.ftz.f32 	%f7, %f1, %f6;
	mul.ftz.f32 	%f8, %f7, 0f3E000000;
	st.shared.f32 	[%rd7], %f8;
	add.s64 	%rd46, %rd8, %rd33;
	shl.b64 	%rd47, %rd46, 2;
	add.s64 	%rd48, %rd2, %rd47;
	ld.global.nc.f32 	%f9, [%rd48];
	add.s64 	%rd49, %rd8, %rd32;
	shl.b64 	%rd50, %rd49, 2;
	add.s64 	%rd51, %rd2, %rd50;
	ld.global.nc.f32 	%f10, [%rd51];
	add.s64 	%rd52, %rd8, %rd30;
	shl.b64 	%rd53, %rd52, 2;
	add.s64 	%rd54, %rd2, %rd53;
	ld.global.nc.f32 	%f11, [%rd54];
	add.s64 	%rd55, %rd8, %rd31;
	shl.b64 	%rd56, %rd55, 2;
	add.s64 	%rd57, %rd2, %rd56;
	ld.global.nc.f32 	%f12, [%rd57];
	add.ftz.f32 	%f13, %f11, %f12;
	fma.rn.ftz.f32 	%f14, %f13, 0f40400000, %f10;
	add.ftz.f32 	%f15, %f9, %f14;
	mul.ftz.f32 	%f16, %f15, 0f3E000000;
	st.shared.f32 	[%rd7+48], %f16;
	bar.sync 	0;
	@%p2 bra 	LBB9_3;
	bra.uni 	LBB9_4;
LBB9_3:                                 // %true_bb
                                        //   in Loop: Header=BB9_2 Depth=1
	ld.shared.f32 	%f17, [%rd9+4];
	ld.shared.f32 	%f18, [%rd10+4];
	ld.shared.f32 	%f19, [%rd11+4];
	ld.shared.f32 	%f20, [%rd11+8];
	add.ftz.f32 	%f21, %f19, %f20;
	fma.rn.ftz.f32 	%f22, %f21, 0f40400000, %f18;
	add.ftz.f32 	%f23, %f17, %f22;
	mul.ftz.f32 	%f24, %f23, 0f3E000000;
	st.global.f32 	[%rd59], %f24;
	ld.shared.f32 	%f25, [%rd11+60];
	ld.shared.f32 	%f26, [%rd11+48];
	ld.shared.f32 	%f27, [%rd11+52];
	ld.shared.f32 	%f28, [%rd11+56];
	add.ftz.f32 	%f29, %f27, %f28;
	fma.rn.ftz.f32 	%f30, %f29, 0f40400000, %f26;
	add.ftz.f32 	%f31, %f25, %f30;
	mul.ftz.f32 	%f32, %f31, 0f3E000000;
	add.s64 	%rd58, %rd59, %rd12;
	st.global.f32 	[%rd58], %f32;
LBB9_4:                                 // %after_bb
                                        //   in Loop: Header=BB9_2 Depth=1
	bar.sync 	0;
	add.s32 	%r62, %r62, -1;
	add.s64 	%rd59, %rd59, 4;
	setp.eq.s32 	%p3, %r62, 0;
	@%p3 bra 	LBB9_5;
	bra.uni 	LBB9_2;
LBB9_5:                                 // %"end for downy$5.s0.x"
	ret;
}
                                        // -- End function
	// .globl	kernel_downy_6_s0__0__0_o___block_id_z // -- Begin function kernel_downy_6_s0__0__0_o___block_id_z
.visible .entry kernel_downy_6_s0__0__0_o___block_id_z(
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_0,
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_1,
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_2,
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_3,
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_4,
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_5,
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_6,
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_7,
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_8,
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_9,
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_10,
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_11,
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_12,
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_13,
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_14,
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_15,
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_16,
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_17,
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_18,
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_19,
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_20,
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_21,
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_22,
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_23,
	.param .u32 kernel_downy_6_s0__0__0_o___block_id_z_param_24,
	.param .u64 kernel_downy_6_s0__0__0_o___block_id_z_param_25,
	.param .u64 kernel_downy_6_s0__0__0_o___block_id_z_param_26
)                                       // @kernel_downy_6_s0__0__0_o___block_id_z
{
	.reg .pred 	%p<2>;
	.reg .f32 	%f<33>;
	.reg .b32 	%r<69>;
	.reg .b64 	%rd<49>;

// %bb.0:                               // %entry
	ld.param.u64 	%rd3, [kernel_downy_6_s0__0__0_o___block_id_z_param_25];
	cvta.to.global.u64 	%rd4, %rd3;
	mov.u32 	%r13, %ctaid.z;
	mov.u32 	%r14, %ctaid.y;
	ld.param.u32 	%r15, [kernel_downy_6_s0__0__0_o___block_id_z_param_5];
	mov.u32 	%r16, %ctaid.x;
	ld.param.u32 	%r17, [kernel_downy_6_s0__0__0_o___block_id_z_param_6];
	mov.u32 	%r18, %tid.z;
	mov.u32 	%r1, %tid.y;
	ld.param.u32 	%r19, [kernel_downy_6_s0__0__0_o___block_id_z_param_7];
	mov.u32 	%r2, %tid.x;
	ld.param.u32 	%r20, [kernel_downy_6_s0__0__0_o___block_id_z_param_8];
	shl.b32 	%r21, %r13, 2;
	ld.param.u32 	%r22, [kernel_downy_6_s0__0__0_o___block_id_z_param_9];
	ld.param.u32 	%r23, [kernel_downy_6_s0__0__0_o___block_id_z_param_10];
	ld.param.u32 	%r24, [kernel_downy_6_s0__0__0_o___block_id_z_param_21];
	min.s32 	%r25, %r21, %r24;
	ld.param.u32 	%r26, [kernel_downy_6_s0__0__0_o___block_id_z_param_11];
	ld.param.u32 	%r27, [kernel_downy_6_s0__0__0_o___block_id_z_param_12];
	ld.param.u32 	%r28, [kernel_downy_6_s0__0__0_o___block_id_z_param_20];
	mad.lo.s32 	%r29, %r14, 3, %r28;
	ld.param.u32 	%r30, [kernel_downy_6_s0__0__0_o___block_id_z_param_14];
	ld.param.u32 	%r31, [kernel_downy_6_s0__0__0_o___block_id_z_param_19];
	min.s32 	%r3, %r29, %r31;
	ld.param.u32 	%r32, [kernel_downy_6_s0__0__0_o___block_id_z_param_15];
	ld.param.u32 	%r33, [kernel_downy_6_s0__0__0_o___block_id_z_param_16];
	ld.param.u32 	%r34, [kernel_downy_6_s0__0__0_o___block_id_z_param_17];
	mad.lo.s32 	%r35, %r16, 3, %r34;
	ld.param.u32 	%r36, [kernel_downy_6_s0__0__0_o___block_id_z_param_18];
	min.s32 	%r37, %r35, %r36;
	shl.b32 	%r4, %r18, 3;
	add.s32 	%r38, %r4, %r1;
	ld.param.u32 	%r39, [kernel_downy_6_s0__0__0_o___block_id_z_param_22];
	mad.lo.s32 	%r40, %r38, 3, %r2;
	ld.param.u32 	%r41, [kernel_downy_6_s0__0__0_o___block_id_z_param_24];
	add.s32 	%r5, %r18, %r25;
	add.s32 	%r42, %r5, %r39;
	mul.wide.s32 	%rd5, %r42, %r41;
	shl.b32 	%r43, %r3, 1;
	add.s32 	%r44, %r43, %r1;
	min.s32 	%r45, %r44, %r32;
	max.s32 	%r46, %r45, 1;
	add.s32 	%r47, %r46, %r33;
	mul.wide.s32 	%rd6, %r47, %r30;
	add.s64 	%rd7, %rd6, %rd5;
	add.s32 	%r6, %r37, %r2;
	ld.param.s32 	%rd8, [kernel_downy_6_s0__0__0_o___block_id_z_param_13];
	shl.b32 	%r48, %r6, 1;
	min.s32 	%r49, %r48, %r26;
	max.s32 	%r50, %r49, 4;
	add.s32 	%r51, %r50, %r27;
	cvt.s64.s32 	%rd9, %r51;
	min.s32 	%r52, %r48, %r22;
	max.s32 	%r53, %r52, 7;
	add.s32 	%r54, %r53, %r23;
	cvt.s64.s32 	%rd10, %r54;
	min.s32 	%r55, %r48, %r19;
	max.s32 	%r56, %r55, 6;
	add.s32 	%r57, %r56, %r20;
	cvt.s64.s32 	%rd11, %r57;
	min.s32 	%r58, %r48, %r15;
	max.s32 	%r59, %r58, 5;
	add.s32 	%r60, %r59, %r17;
	cvt.s64.s32 	%rd12, %r60;
	add.s64 	%rd13, %rd7, %rd9;
	shl.b64 	%rd14, %rd13, 2;
	add.s64 	%rd15, %rd4, %rd14;
	ld.global.nc.f32 	%f1, [%rd15];
	add.s64 	%rd16, %rd7, %rd10;
	shl.b64 	%rd17, %rd16, 2;
	add.s64 	%rd18, %rd4, %rd17;
	ld.global.nc.f32 	%f2, [%rd18];
	add.s64 	%rd19, %rd7, %rd11;
	shl.b64 	%rd20, %rd19, 2;
	add.s64 	%rd21, %rd4, %rd20;
	ld.global.nc.f32 	%f3, [%rd21];
	add.s64 	%rd22, %rd7, %rd12;
	shl.b64 	%rd23, %rd22, 2;
	add.s64 	%rd24, %rd4, %rd23;
	ld.global.nc.f32 	%f4, [%rd24];
	add.ftz.f32 	%f5, %f3, %f4;
	fma.rn.ftz.f32 	%f6, %f5, 0f40400000, %f2;
	add.ftz.f32 	%f7, %f1, %f6;
	mul.ftz.f32 	%f8, %f7, 0f3E000000;
	mul.wide.u32 	%rd25, %r40, 4;
	st.shared.f32 	[%rd25], %f8;
	add.s64 	%rd26, %rd7, %rd8;
	add.s64 	%rd27, %rd26, %rd9;
	shl.b64 	%rd28, %rd27, 2;
	add.s64 	%rd29, %rd4, %rd28;
	ld.global.nc.f32 	%f9, [%rd29];
	add.s64 	%rd30, %rd26, %rd10;
	shl.b64 	%rd31, %rd30, 2;
	add.s64 	%rd32, %rd4, %rd31;
	ld.global.nc.f32 	%f10, [%rd32];
	add.s64 	%rd33, %rd26, %rd11;
	shl.b64 	%rd34, %rd33, 2;
	add.s64 	%rd35, %rd4, %rd34;
	ld.global.nc.f32 	%f11, [%rd35];
	add.s64 	%rd36, %rd26, %rd12;
	shl.b64 	%rd37, %rd36, 2;
	add.s64 	%rd38, %rd4, %rd37;
	ld.global.nc.f32 	%f12, [%rd38];
	add.ftz.f32 	%f13, %f11, %f12;
	fma.rn.ftz.f32 	%f14, %f13, 0f40400000, %f10;
	add.ftz.f32 	%f15, %f9, %f14;
	mul.ftz.f32 	%f16, %f15, 0f3E000000;
	st.shared.f32 	[%rd25+384], %f16;
	bar.sync 	0;
	setp.gt.u32 	%p1, %r1, 2;
	@%p1 bra 	LBB10_2;
// %bb.1:                               // %true_bb
	ld.param.u32 	%r12, [kernel_downy_6_s0__0__0_o___block_id_z_param_23];
	ld.param.u32 	%r11, [kernel_downy_6_s0__0__0_o___block_id_z_param_4];
	ld.param.u32 	%r10, [kernel_downy_6_s0__0__0_o___block_id_z_param_3];
	ld.param.u32 	%r9, [kernel_downy_6_s0__0__0_o___block_id_z_param_2];
	ld.param.u32 	%r8, [kernel_downy_6_s0__0__0_o___block_id_z_param_1];
	ld.param.u32 	%r7, [kernel_downy_6_s0__0__0_o___block_id_z_param_0];
	ld.param.u64 	%rd2, [kernel_downy_6_s0__0__0_o___block_id_z_param_26];
	cvta.to.global.u64 	%rd1, %rd2;
	shl.b32 	%r61, %r1, 1;
	or.b32  	%r62, %r61, 1;
	add.s32 	%r63, %r62, %r4;
	mad.lo.s32 	%r64, %r63, 3, %r2;
	add.s32 	%r65, %r5, %r11;
	mul.wide.s32 	%rd39, %r65, %r7;
	sub.s32 	%r66, %r1, %r12;
	add.s32 	%r67, %r66, %r3;
	mul.wide.s32 	%rd40, %r67, %r10;
	add.s64 	%rd41, %rd40, %rd39;
	add.s32 	%r68, %r6, %r9;
	cvt.s64.s32 	%rd42, %r68;
	add.s64 	%rd43, %rd41, %rd42;
	mul.wide.u32 	%rd44, %r64, 4;
	ld.shared.f32 	%f17, [%rd44+24];
	ld.shared.f32 	%f18, [%rd44+-12];
	ld.shared.f32 	%f19, [%rd44];
	ld.shared.f32 	%f20, [%rd44+12];
	add.ftz.f32 	%f21, %f19, %f20;
	fma.rn.ftz.f32 	%f22, %f21, 0f40400000, %f18;
	add.ftz.f32 	%f23, %f17, %f22;
	mul.ftz.f32 	%f24, %f23, 0f3E000000;
	shl.b64 	%rd45, %rd43, 2;
	add.s64 	%rd46, %rd1, %rd45;
	st.global.f32 	[%rd46], %f24;
	ld.shared.f32 	%f25, [%rd44+408];
	ld.shared.f32 	%f26, [%rd44+372];
	ld.shared.f32 	%f27, [%rd44+384];
	ld.shared.f32 	%f28, [%rd44+396];
	add.ftz.f32 	%f29, %f27, %f28;
	fma.rn.ftz.f32 	%f30, %f29, 0f40400000, %f26;
	add.ftz.f32 	%f31, %f25, %f30;
	mul.ftz.f32 	%f32, %f31, 0f3E000000;
	mul.wide.s32 	%rd47, %r8, 4;
	add.s64 	%rd48, %rd46, %rd47;
	st.global.f32 	[%rd48], %f32;
LBB10_2:                                // %after_bb
	ret;
}
                                        // -- End function
	// .globl	kernel_upx_2_s0__0__0_o___block_id_z // -- Begin function kernel_upx_2_s0__0__0_o___block_id_z
.visible .entry kernel_upx_2_s0__0__0_o___block_id_z(
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_0,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_1,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_2,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_3,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_4,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_5,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_6,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_7,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_8,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_9,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_10,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_11,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_12,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_13,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_14,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_15,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_16,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_17,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_18,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_19,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_20,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_21,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_22,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_23,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_24,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_25,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_26,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_27,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_28,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_29,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_30,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_31,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_32,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_33,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_34,
	.param .u32 kernel_upx_2_s0__0__0_o___block_id_z_param_35,
	.param .u64 kernel_upx_2_s0__0__0_o___block_id_z_param_36,
	.param .u64 kernel_upx_2_s0__0__0_o___block_id_z_param_37,
	.param .u64 kernel_upx_2_s0__0__0_o___block_id_z_param_38,
	.param .u64 kernel_upx_2_s0__0__0_o___block_id_z_param_39
)                                       // @kernel_upx_2_s0__0__0_o___block_id_z
{
	.reg .pred 	%p<8>;
	.reg .f32 	%f<73>;
	.reg .b32 	%r<179>;
	.reg .b64 	%rd<214>;

// %bb.0:                               // %entry
	ld.param.u32 	%r48, [kernel_upx_2_s0__0__0_o___block_id_z_param_29];
	ld.param.u64 	%rd54, [kernel_upx_2_s0__0__0_o___block_id_z_param_39];
	mov.u32 	%r51, %ctaid.z;
	mov.u32 	%r52, %ctaid.y;
	mov.u32 	%r53, %ctaid.x;
	mov.u32 	%r1, %tid.z;
	mov.u32 	%r2, %tid.y;
	mov.u32 	%r3, %tid.x;
	shl.b32 	%r4, %r51, 1;
	min.s32 	%r5, %r4, %r48;
	shl.b32 	%r54, %r52, 3;
	ld.param.u32 	%r55, [kernel_upx_2_s0__0__0_o___block_id_z_param_31];
	add.s32 	%r56, %r54, %r55;
	ld.param.u32 	%r57, [kernel_upx_2_s0__0__0_o___block_id_z_param_30];
	min.s32 	%r6, %r56, %r57;
	shl.b32 	%r58, %r53, 3;
	ld.param.u32 	%r59, [kernel_upx_2_s0__0__0_o___block_id_z_param_33];
	add.s32 	%r60, %r58, %r59;
	ld.param.u32 	%r61, [kernel_upx_2_s0__0__0_o___block_id_z_param_32];
	min.s32 	%r7, %r60, %r61;
	add.s32 	%r62, %r7, 2;
	and.b32  	%r63, %r62, 3;
	add.s32 	%r64, %r63, 23;
	shr.u32 	%r8, %r64, 2;
	add.s32 	%r65, %r6, 2;
	and.b32  	%r66, %r65, 3;
	add.s32 	%r67, %r66, 23;
	shr.u32 	%r68, %r67, 2;
	mul.lo.s32 	%r9, %r8, %r68;
	setp.lt.u32 	%p1, %r2, %r68;
	setp.lt.u32 	%p2, %r3, %r8;
	and.pred  	%p3, %p1, %p2;
	@%p3 bra 	LBB11_6;
	bra.uni 	LBB11_1;
LBB11_6:                                // %true_bb1
	ld.param.u32 	%r50, [kernel_upx_2_s0__0__0_o___block_id_z_param_35];
	ld.param.u32 	%r49, [kernel_upx_2_s0__0__0_o___block_id_z_param_34];
	ld.param.u32 	%r45, [kernel_upx_2_s0__0__0_o___block_id_z_param_25];
	ld.param.u32 	%r44, [kernel_upx_2_s0__0__0_o___block_id_z_param_24];
	ld.param.u32 	%r43, [kernel_upx_2_s0__0__0_o___block_id_z_param_23];
	ld.param.u32 	%r38, [kernel_upx_2_s0__0__0_o___block_id_z_param_18];
	ld.param.u32 	%r34, [kernel_upx_2_s0__0__0_o___block_id_z_param_14];
	ld.param.u32 	%r21, [kernel_upx_2_s0__0__0_o___block_id_z_param_1];
	ld.param.u64 	%rd55, [kernel_upx_2_s0__0__0_o___block_id_z_param_38];
	cvta.to.global.u64 	%rd2, %rd55;
	add.s32 	%r69, %r1, %r5;
	add.s32 	%r70, %r69, %r49;
	mul.wide.s32 	%rd58, %r70, %r43;
	add.s32 	%r71, %r6, -6;
	shr.s32 	%r72, %r71, 2;
	add.s32 	%r73, %r72, %r2;
	min.s32 	%r74, %r73, %r38;
	max.s32 	%r75, %r74, 0;
	sub.s32 	%r76, %r75, %r45;
	mul.wide.s32 	%rd59, %r76, %r50;
	add.s64 	%rd60, %rd59, %rd58;
	mad.lo.s32 	%r77, %r8, %r2, %r3;
	mad.lo.s32 	%r78, %r9, %r1, %r77;
	shl.b32 	%r79, %r9, 1;
	add.s32 	%r80, %r7, -6;
	shr.s32 	%r81, %r80, 2;
	add.s32 	%r82, %r81, %r3;
	cvt.s64.s32 	%rd61, %r21;
	shr.s32 	%r83, %r82, 1;
	shl.b32 	%r84, %r82, 1;
	and.b32  	%r85, %r84, 2;
	add.s32 	%r86, %r85, %r83;
	min.s32 	%r87, %r86, %r34;
	max.s32 	%r88, %r87, 1;
	not.b32 	%r89, %r44;
	add.s32 	%r90, %r88, %r89;
	cvt.s64.s32 	%rd62, %r90;
	add.s32 	%r91, %r34, -1;
	min.s32 	%r92, %r83, %r91;
	max.s32 	%r93, %r92, 0;
	sub.s32 	%r94, %r93, %r44;
	cvt.s64.s32 	%rd63, %r94;
	add.s64 	%rd64, %rd60, %rd62;
	shl.b64 	%rd65, %rd64, 2;
	add.s64 	%rd66, %rd2, %rd65;
	ld.global.nc.f32 	%f1, [%rd66];
	add.s64 	%rd67, %rd60, %rd63;
	shl.b64 	%rd68, %rd67, 2;
	add.s64 	%rd69, %rd2, %rd68;
	ld.global.nc.f32 	%f2, [%rd69];
	fma.rn.ftz.f32 	%f3, %f2, 0f40400000, %f1;
	mul.ftz.f32 	%f4, %f3, 0f3E800000;
	mul.wide.u32 	%rd70, %r78, 4;
	st.shared.f32 	[%rd70], %f4;
	add.s64 	%rd71, %rd60, %rd61;
	add.s64 	%rd72, %rd71, %rd62;
	shl.b64 	%rd73, %rd72, 2;
	add.s64 	%rd74, %rd2, %rd73;
	ld.global.nc.f32 	%f5, [%rd74];
	add.s64 	%rd75, %rd71, %rd63;
	shl.b64 	%rd76, %rd75, 2;
	add.s64 	%rd77, %rd2, %rd76;
	ld.global.nc.f32 	%f6, [%rd77];
	fma.rn.ftz.f32 	%f7, %f6, 0f40400000, %f5;
	mul.ftz.f32 	%f8, %f7, 0f3E800000;
	mul.wide.u32 	%rd78, %r79, 4;
	add.s64 	%rd79, %rd70, %rd78;
	st.shared.f32 	[%rd79], %f8;
LBB11_1:                                // %after_bb
	ld.param.u32 	%r47, [kernel_upx_2_s0__0__0_o___block_id_z_param_27];
	ld.param.u32 	%r37, [kernel_upx_2_s0__0__0_o___block_id_z_param_17];
	ld.param.u32 	%r36, [kernel_upx_2_s0__0__0_o___block_id_z_param_16];
	ld.param.u32 	%r32, [kernel_upx_2_s0__0__0_o___block_id_z_param_12];
	ld.param.u32 	%r31, [kernel_upx_2_s0__0__0_o___block_id_z_param_11];
	ld.param.u32 	%r30, [kernel_upx_2_s0__0__0_o___block_id_z_param_10];
	ld.param.u32 	%r20, [kernel_upx_2_s0__0__0_o___block_id_z_param_0];
	cvta.to.global.u64 	%rd1, %rd54;
	bar.sync 	0;
	setp.eq.s32 	%p4, %r1, 0;
	and.b32  	%r10, %r7, 1;
	or.b32  	%r11, %r10, 6;
	setp.lt.u32 	%p5, %r3, %r11;
	and.pred  	%p6, %p4, %p5;
	@%p6 bra 	LBB11_4;
	bra.uni 	LBB11_2;
LBB11_4:                                // %true_bb7
	ld.param.u64 	%rd56, [kernel_upx_2_s0__0__0_o___block_id_z_param_37];
	ld.param.u64 	%rd57, [kernel_upx_2_s0__0__0_o___block_id_z_param_36];
	ld.param.u32 	%r46, [kernel_upx_2_s0__0__0_o___block_id_z_param_26];
	ld.param.u32 	%r42, [kernel_upx_2_s0__0__0_o___block_id_z_param_22];
	ld.param.u32 	%r41, [kernel_upx_2_s0__0__0_o___block_id_z_param_21];
	ld.param.u32 	%r40, [kernel_upx_2_s0__0__0_o___block_id_z_param_20];
	ld.param.u32 	%r39, [kernel_upx_2_s0__0__0_o___block_id_z_param_19];
	ld.param.u32 	%r35, [kernel_upx_2_s0__0__0_o___block_id_z_param_15];
	ld.param.u32 	%r33, [kernel_upx_2_s0__0__0_o___block_id_z_param_13];
	ld.param.u32 	%r29, [kernel_upx_2_s0__0__0_o___block_id_z_param_9];
	ld.param.u32 	%r28, [kernel_upx_2_s0__0__0_o___block_id_z_param_8];
	ld.param.u32 	%r27, [kernel_upx_2_s0__0__0_o___block_id_z_param_7];
	ld.param.u32 	%r26, [kernel_upx_2_s0__0__0_o___block_id_z_param_6];
	ld.param.u32 	%r25, [kernel_upx_2_s0__0__0_o___block_id_z_param_5];
	ld.param.u32 	%r24, [kernel_upx_2_s0__0__0_o___block_id_z_param_4];
	ld.param.u32 	%r23, [kernel_upx_2_s0__0__0_o___block_id_z_param_3];
	ld.param.u32 	%r22, [kernel_upx_2_s0__0__0_o___block_id_z_param_2];
	cvta.to.global.u64 	%rd212, %rd56;
	cvta.to.global.u64 	%rd4, %rd57;
	shr.s32 	%r177, %r7, 1;
	add.s32 	%r99, %r177, %r3;
	min.s32 	%r100, %r99, %r22;
	add.s32 	%r101, %r6, %r2;
	shr.s32 	%r102, %r101, 1;
	add.s32 	%r103, %r99, -1;
	shr.s32 	%r104, %r103, 1;
	add.s32 	%r105, %r7, -6;
	shr.s32 	%r106, %r105, 2;
	cvt.u64.u32 	%rd81, %r8;
	add.s32 	%r107, %r6, -6;
	shr.s32 	%r108, %r107, 2;
	shr.s32 	%r109, %r101, 2;
	sub.s32 	%r110, %r109, %r108;
	add.s32 	%r111, %r33, -1;
	min.s32 	%r112, %r111, %r104;
	cvt.s64.s32 	%rd82, %r110;
	mul.lo.s64 	%rd83, %rd81, %rd82;
	and.b32  	%r113, %r101, 2;
	add.s32 	%r114, %r110, %r113;
	cvt.s64.s32 	%rd84, %r114;
	add.s32 	%r115, %r35, -1;
	min.s32 	%r116, %r115, %r102;
	max.s32 	%r117, %r116, 0;
	sub.s32 	%r118, %r117, %r42;
	mul.wide.s32 	%rd85, %r118, %r23;
	not.b32 	%r119, %r42;
	min.s32 	%r120, %r101, %r24;
	max.s32 	%r121, %r120, 0;
	sub.s32 	%r122, %r121, %r29;
	mul.wide.s32 	%rd86, %r122, %r25;
	max.s32 	%r123, %r100, 1;
	add.s32 	%r124, %r123, %r26;
	cvt.s64.s32 	%rd87, %r124;
	shl.b32 	%r125, %r99, 1;
	not.b32 	%r126, %r125;
	and.b32  	%r127, %r126, 2;
	add.s32 	%r128, %r127, %r104;
	shl.b32 	%r129, %r101, 1;
	and.b32  	%r130, %r129, 2;
	add.s32 	%r131, %r130, %r102;
	shl.b32 	%r132, %r10, 4;
	shl.b32 	%r133, %r10, 3;
	or.b32  	%r176, %r133, 48;
	mul.lo.s32 	%r134, %r11, %r2;
	cvt.u64.u32 	%rd209, %r134;
	cvt.s64.s32 	%rd208, %r37;
	cvt.u64.u32 	%rd88, %r3;
	add.s32 	%r135, %r131, -1;
	shr.s32 	%r136, %r135, 1;
	sub.s32 	%r137, %r136, %r108;
	cvt.s64.s32 	%rd89, %r137;
	mul.lo.s64 	%rd90, %rd89, %rd81;
	min.s32 	%r138, %r131, %r35;
	max.s32 	%r139, %r138, 1;
	add.s32 	%r140, %r139, %r119;
	mul.wide.s32 	%rd91, %r140, %r23;
	shl.b32 	%r141, %r131, 1;
	not.b32 	%r142, %r141;
	and.b32  	%r143, %r142, 2;
	add.s32 	%r144, %r131, -3;
	shr.s32 	%r145, %r144, 1;
	sub.s32 	%r146, %r145, %r108;
	add.s32 	%r147, %r146, %r143;
	cvt.s64.s32 	%rd92, %r147;
	mul.lo.s64 	%rd93, %rd92, %rd81;
	shl.b32 	%r148, %r9, 1;
	max.s32 	%r149, %r112, 0;
	min.s32 	%r150, %r128, %r33;
	max.s32 	%r151, %r150, 1;
	not.b32 	%r152, %r41;
	add.s32 	%r153, %r151, %r152;
	cvt.u64.u32 	%rd94, %r148;
	cvt.s64.s32 	%rd95, %r27;
	cvt.s64.s32 	%rd96, %r153;
	add.s64 	%rd97, %rd88, %rd208;
	add.s64 	%rd98, %rd97, %rd209;
	mul.wide.s32 	%rd13, %r28, 4;
	add.s32 	%r154, %r47, -1;
	not.b32 	%r155, %r4;
	not.b32 	%r156, %r48;
	max.s32 	%r157, %r155, %r156;
	sub.s32 	%r158, %r154, %r157;
	mul.wide.s32 	%rd99, %r39, %r158;
	add.s64 	%rd100, %rd86, %rd99;
	add.s64 	%rd101, %rd100, %rd87;
	shl.b64 	%rd102, %rd101, 2;
	add.s64 	%rd213, %rd4, %rd102;
	mul.wide.s32 	%rd15, %r39, 4;
	add.s32 	%r159, %r46, -1;
	sub.s32 	%r160, %r159, %r157;
	mul.wide.s32 	%rd103, %r40, %r160;
	add.s64 	%rd104, %rd103, %rd91;
	add.s64 	%rd105, %rd104, %rd95;
	cvt.u64.u32 	%rd106, %r149;
	add.s64 	%rd107, %rd105, %rd106;
	cvt.s64.s32 	%rd108, %r41;
	sub.s64 	%rd109, %rd107, %rd108;
	shl.b64 	%rd16, %rd109, 2;
	mul.wide.s32 	%rd17, %r40, 4;
	add.s64 	%rd110, %rd105, %rd96;
	shl.b64 	%rd18, %rd110, 2;
	add.s64 	%rd111, %rd85, %rd103;
	add.s64 	%rd112, %rd111, %rd95;
	add.s64 	%rd113, %rd112, %rd106;
	sub.s64 	%rd114, %rd113, %rd108;
	shl.b64 	%rd19, %rd114, 2;
	add.s64 	%rd115, %rd112, %rd96;
	shl.b64 	%rd20, %rd115, 2;
	add.s64 	%rd116, %rd104, %rd106;
	sub.s64 	%rd117, %rd116, %rd108;
	shl.b64 	%rd21, %rd117, 2;
	add.s64 	%rd118, %rd104, %rd96;
	shl.b64 	%rd22, %rd118, 2;
	add.s64 	%rd119, %rd111, %rd106;
	sub.s64 	%rd120, %rd119, %rd108;
	shl.b64 	%rd23, %rd120, 2;
	add.s64 	%rd121, %rd111, %rd96;
	shl.b64 	%rd24, %rd121, 2;
	cvt.u64.u32 	%rd207, %r132;
	mul.wide.u32 	%rd26, %r132, 4;
	shl.b64 	%rd122, %rd98, 2;
	add.s64 	%rd211, %rd122, 384;
	mul.wide.u32 	%rd28, %r176, 4;
	shl.b64 	%rd123, %rd90, 2;
	cvt.s64.s32 	%rd124, %r128;
	mul.wide.s32 	%rd125, %r128, 4;
	add.s64 	%rd126, %rd123, %rd125;
	cvt.s64.s32 	%rd127, %r106;
	mul.wide.s32 	%rd128, %r106, 4;
	sub.s64 	%rd29, %rd126, %rd128;
	mul.wide.u32 	%rd30, %r9, 4;
	shl.b64 	%rd129, %rd93, 2;
	add.s64 	%rd130, %rd129, %rd125;
	sub.s64 	%rd31, %rd130, %rd128;
	shl.b64 	%rd131, %rd83, 2;
	add.s64 	%rd132, %rd131, %rd125;
	sub.s64 	%rd32, %rd132, %rd128;
	add.s64 	%rd133, %rd90, %rd124;
	add.s64 	%rd134, %rd133, %rd94;
	sub.s64 	%rd135, %rd134, %rd127;
	shl.b64 	%rd33, %rd135, 2;
	add.s64 	%rd136, %rd93, %rd124;
	add.s64 	%rd137, %rd136, %rd94;
	sub.s64 	%rd138, %rd137, %rd127;
	shl.b64 	%rd34, %rd138, 2;
	add.s64 	%rd139, %rd83, %rd124;
	add.s64 	%rd140, %rd139, %rd94;
	sub.s64 	%rd141, %rd140, %rd127;
	shl.b64 	%rd35, %rd141, 2;
	mul.wide.s32 	%rd142, %r104, 4;
	add.s64 	%rd143, %rd123, %rd142;
	mul.wide.u32 	%rd144, %r148, 4;
	add.s64 	%rd145, %rd143, %rd144;
	sub.s64 	%rd36, %rd145, %rd128;
	add.s64 	%rd146, %rd129, %rd142;
	add.s64 	%rd147, %rd146, %rd144;
	sub.s64 	%rd37, %rd147, %rd128;
	add.s64 	%rd148, %rd131, %rd142;
	add.s64 	%rd149, %rd148, %rd144;
	sub.s64 	%rd38, %rd149, %rd128;
	add.s64 	%rd150, %rd84, -1;
	mul.lo.s64 	%rd151, %rd150, %rd81;
	shl.b64 	%rd152, %rd151, 2;
	add.s64 	%rd153, %rd152, %rd142;
	add.s64 	%rd154, %rd153, %rd144;
	sub.s64 	%rd39, %rd154, %rd128;
	add.s64 	%rd155, %rd152, %rd125;
	add.s64 	%rd156, %rd155, %rd144;
	add.s64 	%rd157, %rd156, -4;
	sub.s64 	%rd40, %rd157, %rd128;
	sub.s64 	%rd41, %rd143, %rd128;
	sub.s64 	%rd42, %rd146, %rd128;
	sub.s64 	%rd43, %rd148, %rd128;
	sub.s64 	%rd44, %rd153, %rd128;
	sub.s64 	%rd45, %rd155, %rd128;
	mov.u32 	%r178, 2;
	mov.u64 	%rd210, -4;
LBB11_5:                                // %"for cost_pyramid_pull[5].s0.z"
                                        // =>This Inner Loop Header: Depth=1
	ld.global.nc.f32 	%f9, [%rd213];
	add.s64 	%rd158, %rd212, %rd24;
	ld.global.nc.f32 	%f10, [%rd158];
	add.s64 	%rd159, %rd45, %rd210;
	ld.shared.f32 	%f11, [%rd159];
	add.s64 	%rd160, %rd32, %rd210;
	ld.shared.f32 	%f12, [%rd160];
	fma.rn.ftz.f32 	%f13, %f12, 0f40400000, %f11;
	fma.rn.ftz.f32 	%f14, %f10, 0f40800000, %f13;
	add.s64 	%rd161, %rd212, %rd23;
	ld.global.nc.f32 	%f15, [%rd161];
	add.s64 	%rd162, %rd44, %rd210;
	ld.shared.f32 	%f16, [%rd162+4];
	add.s64 	%rd163, %rd43, %rd210;
	ld.shared.f32 	%f17, [%rd163+4];
	fma.rn.ftz.f32 	%f18, %f17, 0f40400000, %f16;
	fma.rn.ftz.f32 	%f19, %f15, 0f40800000, %f18;
	mul.ftz.f32 	%f20, %f19, 0f3EC00000;
	fma.rn.ftz.f32 	%f21, %f14, 0f3E000000, %f20;
	add.s64 	%rd164, %rd212, %rd22;
	ld.global.nc.f32 	%f22, [%rd164];
	add.s64 	%rd165, %rd31, %rd210;
	ld.shared.f32 	%f23, [%rd165];
	add.s64 	%rd166, %rd29, %rd210;
	ld.shared.f32 	%f24, [%rd166];
	fma.rn.ftz.f32 	%f25, %f24, 0f40400000, %f23;
	fma.rn.ftz.f32 	%f26, %f22, 0f40800000, %f25;
	add.s64 	%rd167, %rd212, %rd21;
	ld.global.nc.f32 	%f27, [%rd167];
	add.s64 	%rd168, %rd42, %rd210;
	ld.shared.f32 	%f28, [%rd168+4];
	add.s64 	%rd169, %rd41, %rd210;
	ld.shared.f32 	%f29, [%rd169+4];
	fma.rn.ftz.f32 	%f30, %f29, 0f40400000, %f28;
	fma.rn.ftz.f32 	%f31, %f27, 0f40800000, %f30;
	mul.ftz.f32 	%f32, %f31, 0f3EC00000;
	fma.rn.ftz.f32 	%f33, %f26, 0f3E000000, %f32;
	fma.rn.ftz.f32 	%f34, %f21, 0f40400000, %f33;
	fma.rn.ftz.f32 	%f35, %f9, 0f41800000, %f34;
	mul.ftz.f32 	%f36, %f35, 0f3D000000;
	st.shared.f32 	[%rd211+-384], %f36;
	add.s64 	%rd170, %rd213, %rd13;
	ld.global.nc.f32 	%f37, [%rd170];
	add.s64 	%rd171, %rd212, %rd20;
	ld.global.nc.f32 	%f38, [%rd171];
	add.s64 	%rd172, %rd40, %rd210;
	ld.shared.f32 	%f39, [%rd172+4];
	add.s64 	%rd173, %rd35, %rd210;
	ld.shared.f32 	%f40, [%rd173];
	fma.rn.ftz.f32 	%f41, %f40, 0f40400000, %f39;
	fma.rn.ftz.f32 	%f42, %f38, 0f40800000, %f41;
	add.s64 	%rd174, %rd212, %rd19;
	ld.global.nc.f32 	%f43, [%rd174];
	add.s64 	%rd175, %rd39, %rd210;
	ld.shared.f32 	%f44, [%rd175+4];
	add.s64 	%rd176, %rd38, %rd210;
	ld.shared.f32 	%f45, [%rd176+4];
	fma.rn.ftz.f32 	%f46, %f45, 0f40400000, %f44;
	fma.rn.ftz.f32 	%f47, %f43, 0f40800000, %f46;
	mul.ftz.f32 	%f48, %f47, 0f3EC00000;
	fma.rn.ftz.f32 	%f49, %f42, 0f3E000000, %f48;
	add.s64 	%rd177, %rd212, %rd18;
	ld.global.nc.f32 	%f50, [%rd177];
	add.s64 	%rd178, %rd34, %rd210;
	ld.shared.f32 	%f51, [%rd178];
	add.s64 	%rd179, %rd33, %rd210;
	ld.shared.f32 	%f52, [%rd179];
	fma.rn.ftz.f32 	%f53, %f52, 0f40400000, %f51;
	fma.rn.ftz.f32 	%f54, %f50, 0f40800000, %f53;
	add.s64 	%rd180, %rd212, %rd16;
	ld.global.nc.f32 	%f55, [%rd180];
	add.s64 	%rd181, %rd37, %rd210;
	ld.shared.f32 	%f56, [%rd181+4];
	add.s64 	%rd182, %rd36, %rd210;
	ld.shared.f32 	%f57, [%rd182+4];
	fma.rn.ftz.f32 	%f58, %f57, 0f40400000, %f56;
	fma.rn.ftz.f32 	%f59, %f55, 0f40800000, %f58;
	mul.ftz.f32 	%f60, %f59, 0f3EC00000;
	fma.rn.ftz.f32 	%f61, %f54, 0f3E000000, %f60;
	fma.rn.ftz.f32 	%f62, %f49, 0f40400000, %f61;
	fma.rn.ftz.f32 	%f63, %f37, 0f41800000, %f62;
	mul.ftz.f32 	%f64, %f63, 0f3D000000;
	add.s64 	%rd183, %rd26, %rd211;
	st.shared.f32 	[%rd183], %f64;
	add.s64 	%rd213, %rd213, %rd15;
	add.s64 	%rd212, %rd212, %rd17;
	add.s32 	%r178, %r178, -1;
	add.s64 	%rd211, %rd211, %rd28;
	add.s64 	%rd210, %rd210, %rd30;
	setp.eq.s32 	%p7, %r178, 0;
	@%p7 bra 	LBB11_3;
	bra.uni 	LBB11_5;
LBB11_2:                                // %after_bb.after_bb6_crit_edge
	shr.s32 	%r177, %r7, 1;
	shl.b32 	%r95, %r10, 4;
	mul.lo.s32 	%r96, %r11, %r2;
	cvt.u64.u32 	%rd209, %r96;
	shl.b32 	%r97, %r10, 3;
	or.b32  	%r176, %r97, 48;
	cvt.s64.s32 	%rd208, %r37;
	cvt.u64.u32 	%rd207, %r95;
LBB11_3:                                // %after_bb6
	bar.sync 	0;
	mov.u32 	%r161, 1;
	sub.s32 	%r162, %r161, %r177;
	add.s32 	%r163, %r1, %r5;
	add.s32 	%r164, %r163, %r47;
	mul.wide.s32 	%rd184, %r164, %r36;
	sub.s32 	%r165, %r2, %r20;
	add.s32 	%r166, %r165, %r6;
	mul.wide.s32 	%rd185, %r166, %r30;
	add.s64 	%rd186, %rd185, %rd184;
	sub.s32 	%r167, %r3, %r31;
	add.s32 	%r168, %r167, %r7;
	cvt.s64.s32 	%rd187, %r168;
	add.s64 	%rd188, %rd186, %rd187;
	add.s32 	%r169, %r7, %r3;
	mul.lo.s32 	%r170, %r176, %r1;
	cvt.u64.u32 	%rd189, %r170;
	add.s64 	%rd190, %rd209, %rd208;
	add.s64 	%rd191, %rd190, %rd189;
	shr.s32 	%r171, %r169, 1;
	shl.b32 	%r172, %r169, 1;
	and.b32  	%r173, %r172, 2;
	add.s32 	%r174, %r171, %r162;
	add.s32 	%r175, %r174, %r173;
	cvt.s64.s32 	%rd192, %r175;
	cvt.s64.s32 	%rd193, %r174;
	add.s64 	%rd194, %rd191, %rd192;
	shl.b64 	%rd195, %rd194, 2;
	ld.shared.f32 	%f65, [%rd195+-4];
	add.s64 	%rd196, %rd191, %rd193;
	shl.b64 	%rd197, %rd196, 2;
	ld.shared.f32 	%f66, [%rd197];
	fma.rn.ftz.f32 	%f67, %f66, 0f40400000, %f65;
	mul.ftz.f32 	%f68, %f67, 0f3E800000;
	shl.b64 	%rd198, %rd188, 2;
	add.s64 	%rd199, %rd1, %rd198;
	st.global.f32 	[%rd199], %f68;
	add.s64 	%rd200, %rd191, %rd207;
	add.s64 	%rd201, %rd200, %rd192;
	shl.b64 	%rd202, %rd201, 2;
	ld.shared.f32 	%f69, [%rd202+380];
	add.s64 	%rd203, %rd200, %rd193;
	shl.b64 	%rd204, %rd203, 2;
	ld.shared.f32 	%f70, [%rd204+384];
	fma.rn.ftz.f32 	%f71, %f70, 0f40400000, %f69;
	mul.ftz.f32 	%f72, %f71, 0f3E800000;
	mul.wide.s32 	%rd205, %r32, 4;
	add.s64 	%rd206, %rd199, %rd205;
	st.global.f32 	[%rd206], %f72;
	ret;
}
                                        // -- End function
	// .globl	kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z // -- Begin function kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z
.visible .entry kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z(
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_0,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_1,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_2,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_3,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_4,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_5,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_6,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_7,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_8,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_9,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_10,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_11,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_12,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_13,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_14,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_15,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_16,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_17,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_18,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_19,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_20,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_21,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_22,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_23,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_24,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_25,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_26,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_27,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_28,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_29,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_30,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_31,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_32,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_33,
	.param .u32 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_34,
	.param .u64 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_35,
	.param .u64 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_36,
	.param .u64 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_37,
	.param .u64 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_38,
	.param .u64 kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_39
)                                       // @kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z
{
	.reg .pred 	%p<15>;
	.reg .f32 	%f<69>;
	.reg .b32 	%r<183>;
	.reg .b64 	%rd<172>;

// %bb.0:                               // %entry
	ld.param.u32 	%r49, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_27];
	ld.param.u32 	%r38, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_16];
	mov.u32 	%r51, %ctaid.z;
	mov.u32 	%r52, %ctaid.y;
	mov.u32 	%r53, %ctaid.x;
	mov.u32 	%r1, %tid.z;
	mov.u32 	%r2, %tid.y;
	mov.u32 	%r3, %tid.x;
	shl.b32 	%r54, %r51, 1;
	ld.param.u32 	%r55, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_29];
	min.s32 	%r4, %r54, %r55;
	shl.b32 	%r56, %r52, 4;
	ld.param.u32 	%r57, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_31];
	add.s32 	%r58, %r56, %r57;
	ld.param.u32 	%r59, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_30];
	min.s32 	%r5, %r58, %r59;
	shl.b32 	%r60, %r53, 4;
	ld.param.u32 	%r61, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_33];
	add.s32 	%r62, %r60, %r61;
	ld.param.u32 	%r63, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_32];
	min.s32 	%r6, %r62, %r63;
	add.s32 	%r64, %r6, 2;
	and.b32  	%r65, %r64, 3;
	add.s32 	%r66, %r65, 31;
	shr.u32 	%r7, %r66, 2;
	add.s32 	%r67, %r5, 2;
	and.b32  	%r68, %r67, 3;
	add.s32 	%r69, %r68, 31;
	shr.u32 	%r8, %r69, 2;
	mul.lo.s32 	%r9, %r7, %r8;
	setp.lt.u32 	%p1, %r2, %r8;
	setp.lt.u32 	%p2, %r3, %r7;
	and.pred  	%p3, %p1, %p2;
	@%p3 bra 	LBB12_8;
	bra.uni 	LBB12_1;
LBB12_8:                                // %true_bb1
	ld.param.u32 	%r50, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_34];
	ld.param.u32 	%r47, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_25];
	ld.param.u32 	%r46, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_24];
	ld.param.u32 	%r45, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_23];
	ld.param.u32 	%r40, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_18];
	ld.param.u32 	%r39, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_17];
	ld.param.u32 	%r26, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_4];
	ld.param.u32 	%r25, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_3];
	ld.param.u32 	%r24, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_2];
	ld.param.u32 	%r23, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_1];
	ld.param.u64 	%rd15, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_39];
	cvta.to.global.u64 	%rd1, %rd15;
	ld.param.u64 	%rd16, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_38];
	cvta.to.global.u64 	%rd2, %rd16;
	add.s32 	%r70, %r6, -6;
	shr.s32 	%r71, %r70, 2;
	add.s32 	%r72, %r71, %r3;
	min.s32 	%r73, %r72, %r40;
	mad.lo.s32 	%r74, %r7, %r2, %r3;
	mad.lo.s32 	%r75, %r9, %r1, %r74;
	mul.lo.s32 	%r76, %r39, %r38;
	mul.lo.s32 	%r77, %r45, %r38;
	shl.b32 	%r78, %r9, 1;
	max.s32 	%r79, %r73, 0;
	sub.s32 	%r80, %r79, %r46;
	add.s32 	%r81, %r5, -6;
	shr.s32 	%r82, %r81, 2;
	add.s32 	%r83, %r82, %r2;
	add.s32 	%r84, %r1, %r4;
	add.s32 	%r85, %r84, %r49;
	sub.s32 	%r86, %r3, %r50;
	add.s32 	%r87, %r86, %r71;
	mul.wide.s32 	%rd20, %r85, %r39;
	cvt.s64.s32 	%rd21, %r76;
	mul.wide.s32 	%rd22, %r85, %r45;
	min.s32 	%r88, %r83, %r25;
	max.s32 	%r89, %r88, 0;
	sub.s32 	%r90, %r89, %r47;
	mul.wide.s32 	%rd23, %r90, %r26;
	add.s64 	%rd24, %rd23, %rd22;
	cvt.s64.s32 	%rd25, %r80;
	add.s64 	%rd26, %rd24, %rd25;
	shl.b32 	%r91, %r83, 1;
	and.b32  	%r92, %r91, 2;
	shr.s32 	%r93, %r83, 1;
	sub.s32 	%r94, %r93, %r23;
	add.s32 	%r95, %r92, %r94;
	cvt.s64.s32 	%rd27, %r24;
	mul.wide.s32 	%rd28, %r95, %r24;
	cvt.s64.s32 	%rd29, %r87;
	mul.wide.s32 	%rd30, %r94, %r24;
	shl.b64 	%rd31, %rd26, 2;
	add.s64 	%rd32, %rd2, %rd31;
	ld.global.nc.f32 	%f1, [%rd32];
	sub.s64 	%rd33, %rd29, %rd27;
	add.s64 	%rd34, %rd33, %rd20;
	add.s64 	%rd35, %rd34, %rd28;
	shl.b64 	%rd36, %rd35, 2;
	add.s64 	%rd37, %rd1, %rd36;
	ld.global.nc.f32 	%f2, [%rd37];
	add.s64 	%rd38, %rd20, %rd29;
	add.s64 	%rd39, %rd38, %rd30;
	shl.b64 	%rd40, %rd39, 2;
	add.s64 	%rd41, %rd1, %rd40;
	ld.global.nc.f32 	%f3, [%rd41];
	fma.rn.ftz.f32 	%f4, %f3, 0f40400000, %f2;
	fma.rn.ftz.f32 	%f5, %f1, 0f40800000, %f4;
	mul.ftz.f32 	%f6, %f5, 0f3E000000;
	mul.wide.u32 	%rd42, %r75, 4;
	st.shared.f32 	[%rd42], %f6;
	mul.wide.s32 	%rd43, %r77, 4;
	add.s64 	%rd44, %rd32, %rd43;
	ld.global.nc.f32 	%f7, [%rd44];
	add.s64 	%rd45, %rd21, %rd29;
	sub.s64 	%rd46, %rd45, %rd27;
	add.s64 	%rd47, %rd46, %rd20;
	add.s64 	%rd48, %rd47, %rd28;
	shl.b64 	%rd49, %rd48, 2;
	add.s64 	%rd50, %rd1, %rd49;
	ld.global.nc.f32 	%f8, [%rd50];
	add.s64 	%rd51, %rd45, %rd20;
	add.s64 	%rd52, %rd51, %rd30;
	shl.b64 	%rd53, %rd52, 2;
	add.s64 	%rd54, %rd1, %rd53;
	ld.global.nc.f32 	%f9, [%rd54];
	fma.rn.ftz.f32 	%f10, %f9, 0f40400000, %f8;
	fma.rn.ftz.f32 	%f11, %f7, 0f40800000, %f10;
	mul.ftz.f32 	%f12, %f11, 0f3E000000;
	mul.wide.u32 	%rd55, %r78, 4;
	add.s64 	%rd56, %rd42, %rd55;
	st.shared.f32 	[%rd56], %f12;
LBB12_1:                                // %after_bb
	ld.param.u32 	%r48, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_26];
	bar.sync 	0;
	and.b32  	%r10, %r6, 1;
	or.b32  	%r11, %r10, 10;
	mul.lo.s32 	%r12, %r8, %r11;
	setp.eq.s32 	%p5, %r1, 0;
	and.pred  	%p6, %p1, %p5;
	setp.lt.u32 	%p7, %r3, %r11;
	and.pred  	%p8, %p7, %p6;
	@%p8 bra 	LBB12_9;
	bra.uni 	LBB12_2;
LBB12_9:                                // %true_bb10
	mul.lo.s32 	%r96, %r7, %r2;
	cvt.u64.u32 	%rd57, %r96;
	shr.s32 	%r97, %r6, 1;
	add.s32 	%r98, %r97, %r3;
	add.s32 	%r99, %r98, -1;
	shr.s32 	%r100, %r99, 1;
	add.s32 	%r101, %r6, -6;
	shr.s32 	%r102, %r101, 2;
	sub.s32 	%r103, %r100, %r102;
	mul.lo.s32 	%r104, %r11, %r2;
	cvt.u64.u32 	%rd58, %r104;
	cvt.s64.s32 	%rd59, %r48;
	cvt.u64.u32 	%rd60, %r3;
	shl.b32 	%r105, %r98, 1;
	not.b32 	%r106, %r105;
	and.b32  	%r107, %r106, 2;
	add.s32 	%r108, %r107, %r103;
	cvt.s64.s32 	%rd61, %r108;
	cvt.s64.s32 	%rd62, %r103;
	shl.b32 	%r109, %r12, 1;
	shl.b32 	%r110, %r9, 1;
	add.s64 	%rd63, %rd60, %rd59;
	add.s64 	%rd64, %rd63, %rd58;
	add.s64 	%rd65, %rd57, %rd62;
	add.s64 	%rd66, %rd57, %rd61;
	shl.b64 	%rd67, %rd66, 2;
	ld.shared.f32 	%f13, [%rd67+-4];
	shl.b64 	%rd68, %rd65, 2;
	ld.shared.f32 	%f14, [%rd68];
	fma.rn.ftz.f32 	%f15, %f14, 0f40400000, %f13;
	mul.ftz.f32 	%f16, %f15, 0f3E800000;
	shl.b64 	%rd69, %rd64, 2;
	st.shared.f32 	[%rd69], %f16;
	mul.wide.u32 	%rd70, %r110, 4;
	add.s64 	%rd71, %rd67, %rd70;
	ld.shared.f32 	%f17, [%rd71+-4];
	add.s64 	%rd72, %rd68, %rd70;
	ld.shared.f32 	%f18, [%rd72];
	fma.rn.ftz.f32 	%f19, %f18, 0f40400000, %f17;
	mul.ftz.f32 	%f20, %f19, 0f3E800000;
	mul.wide.u32 	%rd73, %r109, 4;
	add.s64 	%rd74, %rd69, %rd73;
	st.shared.f32 	[%rd74], %f20;
	add.s32 	%r111, %r9, %r96;
	cvt.u64.u32 	%rd75, %r111;
	add.s64 	%rd76, %rd75, %rd62;
	add.s64 	%rd77, %rd75, %rd61;
	shl.b64 	%rd78, %rd77, 2;
	ld.shared.f32 	%f21, [%rd78+-4];
	shl.b64 	%rd79, %rd76, 2;
	ld.shared.f32 	%f22, [%rd79];
	fma.rn.ftz.f32 	%f23, %f22, 0f40400000, %f21;
	mul.ftz.f32 	%f24, %f23, 0f3E800000;
	mul.wide.u32 	%rd80, %r12, 4;
	add.s64 	%rd81, %rd69, %rd80;
	st.shared.f32 	[%rd81], %f24;
	add.s64 	%rd82, %rd78, %rd70;
	ld.shared.f32 	%f25, [%rd82+-4];
	add.s64 	%rd83, %rd79, %rd70;
	ld.shared.f32 	%f26, [%rd83];
	fma.rn.ftz.f32 	%f27, %f26, 0f40400000, %f25;
	mul.ftz.f32 	%f28, %f27, 0f3E800000;
	add.s64 	%rd84, %rd81, %rd73;
	st.shared.f32 	[%rd84], %f28;
LBB12_2:                                // %after_bb6
	ld.param.u64 	%rd18, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_36];
	ld.param.u64 	%rd19, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_35];
	bar.sync 	0;
	and.b32  	%r13, %r5, 1;
	or.b32  	%r14, %r13, 10;
	mul.lo.s32 	%r15, %r11, %r14;
	setp.lt.u32 	%p10, %r2, %r14;
	and.pred  	%p11, %p10, %p7;
	@%p11 bra 	LBB12_4;
	bra.uni 	LBB12_3;
LBB12_4:                                // %true_bb16
	ld.param.u64 	%rd17, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_37];
	ld.param.u32 	%r44, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_22];
	ld.param.u32 	%r30, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_8];
	ld.param.u32 	%r29, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_7];
	ld.param.u32 	%r28, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_6];
	ld.param.u32 	%r27, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_5];
	ld.param.u32 	%r22, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_0];
	cvta.to.global.u64 	%rd3, %rd17;
	shr.s32 	%r112, %r5, 1;
	add.s32 	%r113, %r112, %r2;
	add.s32 	%r114, %r113, -1;
	shr.s32 	%r115, %r114, 1;
	add.s32 	%r116, %r5, -6;
	shr.s32 	%r117, %r116, 2;
	sub.s32 	%r118, %r115, %r117;
	add.s32 	%r119, %r1, %r4;
	add.s32 	%r120, %r119, %r49;
	mul.wide.s32 	%rd85, %r120, %r44;
	min.s32 	%r121, %r113, %r28;
	max.s32 	%r122, %r121, 1;
	add.s32 	%r123, %r122, %r27;
	mul.wide.s32 	%rd86, %r123, %r29;
	add.s64 	%rd87, %rd86, %rd85;
	shr.s32 	%r124, %r6, 1;
	add.s32 	%r125, %r124, %r3;
	min.s32 	%r126, %r125, %r22;
	max.s32 	%r127, %r126, 1;
	add.s32 	%r128, %r127, %r30;
	cvt.s64.s32 	%rd88, %r128;
	add.s64 	%rd89, %rd87, %rd88;
	cvt.u64.u32 	%rd90, %r11;
	mad.lo.s32 	%r129, %r11, %r2, %r3;
	mad.lo.s32 	%r130, %r15, %r1, %r129;
	shl.b32 	%r131, %r12, 1;
	mul.lo.s32 	%r132, %r44, %r38;
	shl.b32 	%r133, %r15, 1;
	cvt.s64.s32 	%rd91, %r48;
	shl.b32 	%r134, %r113, 1;
	not.b32 	%r135, %r134;
	and.b32  	%r136, %r135, 2;
	add.s32 	%r137, %r136, %r118;
	cvt.s64.s32 	%rd92, %r137;
	mul.lo.s64 	%rd93, %rd92, %rd90;
	mad.lo.s32 	%r138, %r12, %r1, %r3;
	cvt.u64.u32 	%rd94, %r138;
	add.s64 	%rd95, %rd94, %rd91;
	cvt.s64.s32 	%rd96, %r118;
	mul.lo.s64 	%rd97, %rd96, %rd90;
	add.s64 	%rd98, %rd95, %rd97;
	shl.b64 	%rd99, %rd89, 2;
	add.s64 	%rd100, %rd3, %rd99;
	ld.global.nc.f32 	%f29, [%rd100];
	cvt.u64.u32 	%rd101, %r10;
	sub.s64 	%rd102, %rd95, %rd101;
	add.s64 	%rd103, %rd102, %rd93;
	shl.b64 	%rd104, %rd103, 2;
	ld.shared.f32 	%f30, [%rd104+-40];
	shl.b64 	%rd105, %rd98, 2;
	ld.shared.f32 	%f31, [%rd105];
	fma.rn.ftz.f32 	%f32, %f31, 0f40400000, %f30;
	fma.rn.ftz.f32 	%f33, %f29, 0f40800000, %f32;
	mul.ftz.f32 	%f34, %f33, 0f3E000000;
	mul.wide.u32 	%rd106, %r130, 4;
	st.shared.f32 	[%rd106], %f34;
	mul.wide.s32 	%rd107, %r132, 4;
	add.s64 	%rd108, %rd100, %rd107;
	ld.global.nc.f32 	%f35, [%rd108];
	mul.wide.u32 	%rd109, %r131, 4;
	add.s64 	%rd110, %rd104, %rd109;
	ld.shared.f32 	%f36, [%rd110+-40];
	add.s64 	%rd111, %rd105, %rd109;
	ld.shared.f32 	%f37, [%rd111];
	fma.rn.ftz.f32 	%f38, %f37, 0f40400000, %f36;
	fma.rn.ftz.f32 	%f39, %f35, 0f40800000, %f38;
	mul.ftz.f32 	%f40, %f39, 0f3E000000;
	mul.wide.s32 	%rd112, %r133, 4;
	add.s64 	%rd113, %rd106, %rd112;
	st.shared.f32 	[%rd113], %f40;
LBB12_3:                                // %after_bb15
	ld.param.u32 	%r43, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_21];
	ld.param.u32 	%r42, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_20];
	ld.param.u32 	%r41, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_19];
	ld.param.u32 	%r37, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_15];
	ld.param.u32 	%r36, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_14];
	ld.param.u32 	%r35, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_13];
	ld.param.u32 	%r34, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_12];
	ld.param.u32 	%r33, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_11];
	ld.param.u32 	%r32, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_10];
	ld.param.u32 	%r31, [kernel_cost_pyramid_pull_2__s0_z_z_o___block_id_z_param_9];
	cvta.to.global.u64 	%rd4, %rd18;
	cvta.to.global.u64 	%rd5, %rd19;
	setp.ge.u32 	%p12, %r2, %r14;
	setp.ne.s32 	%p13, %r1, 0;
	bar.sync 	0;
	or.pred  	%p14, %p13, %p12;
	@!%p14 bra 	LBB12_7;
	bra.uni 	LBB12_5;
LBB12_5:                                // %after_bb15.after_bb21_crit_edge
	add.s32 	%r182, %r6, %r3;
	shl.b32 	%r155, %r13, 5;
	or.b32  	%r156, %r155, 320;
	cvt.u64.u32 	%rd171, %r156;
	shl.b32 	%r157, %r13, 4;
	or.b32  	%r181, %r157, 160;
	cvt.s64.s32 	%rd170, %r48;
	cvt.u64.u32 	%rd169, %r3;
	bra.uni 	LBB12_6;
LBB12_7:                                // %true_bb22
	shr.s32 	%r139, %r6, 1;
	mov.u32 	%r140, 1;
	sub.s32 	%r141, %r140, %r139;
	shl.b32 	%r142, %r2, 4;
	cvt.u64.u32 	%rd114, %r142;
	cvt.s64.s32 	%rd170, %r48;
	add.s64 	%rd115, %rd114, %rd170;
	cvt.u64.u32 	%rd169, %r3;
	add.s64 	%rd116, %rd115, %rd169;
	add.s32 	%r182, %r6, %r3;
	mul.lo.s32 	%r143, %r11, %r2;
	cvt.u64.u32 	%rd117, %r143;
	add.s32 	%r144, %r10, %r3;
	shr.u32 	%r145, %r144, 1;
	shr.s32 	%r146, %r182, 1;
	shl.b32 	%r147, %r182, 1;
	and.b32  	%r148, %r147, 2;
	add.s32 	%r149, %r141, %r146;
	add.s32 	%r150, %r149, %r148;
	shl.b32 	%r151, %r13, 5;
	or.b32  	%r152, %r151, 320;
	shl.b32 	%r153, %r13, 4;
	or.b32  	%r181, %r153, 160;
	shl.b32 	%r154, %r15, 1;
	cvt.s64.s32 	%rd118, %r150;
	cvt.u64.u32 	%rd171, %r152;
	add.s64 	%rd119, %rd117, %rd118;
	shl.b64 	%rd120, %rd119, 2;
	ld.shared.f32 	%f41, [%rd120+-4];
	cvt.u64.u32 	%rd121, %r145;
	add.s64 	%rd122, %rd121, %rd117;
	shl.b64 	%rd123, %rd122, 2;
	ld.shared.f32 	%f42, [%rd123+4];
	fma.rn.ftz.f32 	%f43, %f42, 0f40400000, %f41;
	mul.ftz.f32 	%f44, %f43, 0f3E800000;
	shl.b64 	%rd124, %rd116, 2;
	st.shared.f32 	[%rd124], %f44;
	mul.wide.u32 	%rd125, %r154, 4;
	add.s64 	%rd126, %rd120, %rd125;
	ld.shared.f32 	%f45, [%rd126+-4];
	add.s64 	%rd127, %rd123, %rd125;
	ld.shared.f32 	%f46, [%rd127+4];
	fma.rn.ftz.f32 	%f47, %f46, 0f40400000, %f45;
	mul.ftz.f32 	%f48, %f47, 0f3E800000;
	mul.wide.u32 	%rd128, %r151, 4;
	add.s64 	%rd129, %rd124, %rd128;
	st.shared.f32 	[%rd129+1280], %f48;
	mul.wide.u32 	%rd130, %r15, 4;
	add.s64 	%rd131, %rd120, %rd130;
	ld.shared.f32 	%f49, [%rd131+-4];
	add.s64 	%rd132, %rd123, %rd130;
	ld.shared.f32 	%f50, [%rd132+4];
	fma.rn.ftz.f32 	%f51, %f50, 0f40400000, %f49;
	mul.ftz.f32 	%f52, %f51, 0f3E800000;
	mul.wide.u32 	%rd133, %r153, 4;
	add.s64 	%rd134, %rd124, %rd133;
	st.shared.f32 	[%rd134+640], %f52;
	add.s64 	%rd135, %rd126, %rd130;
	ld.shared.f32 	%f53, [%rd135+-4];
	add.s64 	%rd136, %rd127, %rd130;
	ld.shared.f32 	%f54, [%rd136+4];
	fma.rn.ftz.f32 	%f55, %f54, 0f40400000, %f53;
	mul.ftz.f32 	%f56, %f55, 0f3E800000;
	mul.wide.u32 	%rd137, %r152, 4;
	add.s64 	%rd138, %rd134, %rd137;
	st.shared.f32 	[%rd138+640], %f56;
LBB12_6:                                // %after_bb21
	bar.sync 	0;
	add.s32 	%r158, %r1, %r4;
	add.s32 	%r159, %r158, %r49;
	mul.wide.s32 	%rd139, %r159, %r31;
	min.s32 	%r160, %r182, %r32;
	shr.s32 	%r161, %r5, 1;
	mov.u32 	%r162, 1;
	sub.s32 	%r163, %r162, %r161;
	mul.wide.s32 	%rd140, %r159, %r41;
	sub.s32 	%r164, %r2, %r33;
	add.s32 	%r165, %r164, %r5;
	mul.wide.s32 	%rd141, %r165, %r34;
	add.s64 	%rd142, %rd141, %rd140;
	sub.s32 	%r166, %r182, %r35;
	cvt.s64.s32 	%rd143, %r166;
	add.s64 	%rd144, %rd142, %rd143;
	mul.lo.s32 	%r167, %r38, %r31;
	mul.lo.s32 	%r168, %r41, %r38;
	max.s32 	%r169, %r160, 0;
	sub.s32 	%r170, %r169, %r42;
	add.s32 	%r171, %r5, %r2;
	mul.lo.s32 	%r172, %r181, %r1;
	cvt.u64.u32 	%rd145, %r172;
	add.s64 	%rd146, %rd170, %rd145;
	min.s32 	%r173, %r171, %r36;
	max.s32 	%r174, %r173, 0;
	sub.s32 	%r175, %r174, %r43;
	mul.wide.s32 	%rd147, %r175, %r37;
	add.s64 	%rd148, %rd147, %rd139;
	cvt.s64.s32 	%rd149, %r170;
	add.s64 	%rd150, %rd148, %rd149;
	shr.s32 	%r176, %r171, 1;
	shl.b32 	%r177, %r171, 1;
	and.b32  	%r178, %r177, 2;
	add.s32 	%r179, %r176, %r163;
	add.s32 	%r180, %r179, %r178;
	mul.wide.s32 	%rd151, %r180, 16;
	add.s64 	%rd152, %rd146, %rd169;
	mul.wide.s32 	%rd153, %r179, 16;
	add.s64 	%rd154, %rd152, %rd153;
	shl.b64 	%rd155, %rd150, 2;
	add.s64 	%rd156, %rd4, %rd155;
	ld.global.nc.f32 	%f57, [%rd156];
	add.s64 	%rd157, %rd152, %rd151;
	shl.b64 	%rd158, %rd157, 2;
	ld.shared.f32 	%f58, [%rd158+-64];
	shl.b64 	%rd159, %rd154, 2;
	ld.shared.f32 	%f59, [%rd159];
	fma.rn.ftz.f32 	%f60, %f59, 0f40400000, %f58;
	fma.rn.ftz.f32 	%f61, %f57, 0f40800000, %f60;
	mul.ftz.f32 	%f62, %f61, 0f3E000000;
	shl.b64 	%rd160, %rd144, 2;
	add.s64 	%rd161, %rd5, %rd160;
	st.global.f32 	[%rd161], %f62;
	mul.wide.s32 	%rd162, %r167, 4;
	add.s64 	%rd163, %rd156, %rd162;
	ld.global.nc.f32 	%f63, [%rd163];
	shl.b64 	%rd164, %rd171, 2;
	add.s64 	%rd165, %rd158, %rd164;
	ld.shared.f32 	%f64, [%rd165+-64];
	add.s64 	%rd166, %rd159, %rd164;
	ld.shared.f32 	%f65, [%rd166];
	fma.rn.ftz.f32 	%f66, %f65, 0f40400000, %f64;
	fma.rn.ftz.f32 	%f67, %f63, 0f40800000, %f66;
	mul.ftz.f32 	%f68, %f67, 0f3E000000;
	mul.wide.s32 	%rd167, %r168, 4;
	add.s64 	%rd168, %rd161, %rd167;
	st.global.f32 	[%rd168], %f68;
	ret;
}
                                        // -- End function
	// .globl	kernel_filtered_cost_s0_z_z_o___block_id_z // -- Begin function kernel_filtered_cost_s0_z_z_o___block_id_z
.visible .entry kernel_filtered_cost_s0_z_z_o___block_id_z(
	.param .u64 kernel_filtered_cost_s0_z_z_o___block_id_z_param_0,
	.param .u64 kernel_filtered_cost_s0_z_z_o___block_id_z_param_1,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_2,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_3,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_4,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_5,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_6,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_7,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_8,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_9,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_10,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_11,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_12,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_13,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_14,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_15,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_16,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_17,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_18,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_19,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_20,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_21,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_22,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_23,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_24,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_25,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_26,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_27,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_28,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_29,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_30,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_31,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_32,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_33,
	.param .u32 kernel_filtered_cost_s0_z_z_o___block_id_z_param_34,
	.param .u64 kernel_filtered_cost_s0_z_z_o___block_id_z_param_35,
	.param .u64 kernel_filtered_cost_s0_z_z_o___block_id_z_param_36,
	.param .u64 kernel_filtered_cost_s0_z_z_o___block_id_z_param_37,
	.param .u64 kernel_filtered_cost_s0_z_z_o___block_id_z_param_38,
	.param .u64 kernel_filtered_cost_s0_z_z_o___block_id_z_param_39
)                                       // @kernel_filtered_cost_s0_z_z_o___block_id_z
{
	.reg .pred 	%p<12>;
	.reg .b16 	%rs<7>;
	.reg .f32 	%f<64>;
	.reg .b32 	%r<158>;
	.reg .b64 	%rd<151>;

// %bb.0:                               // %entry
	ld.param.u32 	%r44, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_30];
	mov.u32 	%r46, %ctaid.z;
	mov.u32 	%r47, %ctaid.y;
	mov.u32 	%r48, %ctaid.x;
	mov.u32 	%r1, %tid.z;
	mov.u32 	%r2, %tid.y;
	mov.u32 	%r3, %tid.x;
	ld.param.u32 	%r49, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_11];
	shl.b32 	%r50, %r46, 1;
	ld.param.u32 	%r51, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_32];
	min.s32 	%r4, %r50, %r51;
	shl.b32 	%r52, %r47, 4;
	add.s32 	%r53, %r52, %r49;
	ld.param.u32 	%r54, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_33];
	min.s32 	%r5, %r53, %r54;
	ld.param.u32 	%r55, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_18];
	shl.b32 	%r56, %r48, 4;
	ld.param.u32 	%r57, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_19];
	add.s32 	%r58, %r56, %r57;
	min.s32 	%r6, %r58, %r55;
	add.s32 	%r59, %r5, 2;
	and.b32  	%r60, %r59, 3;
	add.s32 	%r61, %r60, 31;
	shr.u32 	%r62, %r61, 2;
	and.b32  	%r7, %r6, 1;
	or.b32  	%r8, %r7, 10;
	mul.lo.s32 	%r9, %r62, %r8;
	setp.eq.s32 	%p1, %r1, 0;
	setp.lt.u32 	%p2, %r2, %r62;
	and.pred  	%p3, %p1, %p2;
	setp.lt.u32 	%p4, %r3, %r8;
	and.pred  	%p5, %p4, %p3;
	@%p5 bra 	LBB13_6;
	bra.uni 	LBB13_1;
LBB13_6:                                // %true_bb4
	ld.param.u32 	%r45, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_34];
	ld.param.u32 	%r36, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_22];
	ld.param.u32 	%r22, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_5];
	ld.param.u32 	%r21, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_4];
	ld.param.u32 	%r20, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_3];
	ld.param.u64 	%rd11, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_36];
	cvta.to.global.u64 	%rd4, %rd11;
	add.s32 	%r63, %r5, -6;
	shr.s32 	%r64, %r63, 2;
	sub.s32 	%r65, %r2, %r45;
	add.s32 	%r66, %r65, %r64;
	mul.wide.s32 	%rd13, %r66, %r20;
	shr.s32 	%r67, %r6, 1;
	add.s32 	%r68, %r67, %r3;
	add.s32 	%r69, %r68, -1;
	shr.s32 	%r70, %r69, 1;
	sub.s32 	%r71, %r70, %r21;
	mad.lo.s32 	%r72, %r8, %r2, %r3;
	shl.b32 	%r73, %r68, 1;
	not.b32 	%r74, %r73;
	and.b32  	%r75, %r74, 2;
	add.s32 	%r76, %r75, %r71;
	cvt.s64.s32 	%rd14, %r76;
	cvt.s64.s32 	%rd15, %r71;
	shl.b32 	%r77, %r9, 1;
	add.s32 	%r78, %r4, %r44;
	mul.wide.s32 	%rd16, %r78, %r36;
	add.s64 	%rd17, %rd16, %rd13;
	add.s64 	%rd18, %rd17, %rd15;
	add.s64 	%rd19, %rd17, %rd14;
	shl.b64 	%rd20, %rd19, 2;
	add.s64 	%rd21, %rd4, %rd20;
	ld.global.nc.f32 	%f1, [%rd21+-4];
	shl.b64 	%rd22, %rd18, 2;
	add.s64 	%rd23, %rd4, %rd22;
	ld.global.nc.f32 	%f2, [%rd23];
	fma.rn.ftz.f32 	%f3, %f2, 0f40400000, %f1;
	mul.ftz.f32 	%f4, %f3, 0f3E800000;
	mul.wide.u32 	%rd24, %r72, 4;
	st.shared.f32 	[%rd24], %f4;
	mul.wide.s32 	%rd25, %r22, 4;
	add.s64 	%rd26, %rd21, %rd25;
	ld.global.nc.f32 	%f5, [%rd26+-4];
	add.s64 	%rd27, %rd23, %rd25;
	ld.global.nc.f32 	%f6, [%rd27];
	fma.rn.ftz.f32 	%f7, %f6, 0f40400000, %f5;
	mul.ftz.f32 	%f8, %f7, 0f3E800000;
	mul.wide.u32 	%rd28, %r77, 4;
	add.s64 	%rd29, %rd24, %rd28;
	st.shared.f32 	[%rd29], %f8;
	add.s32 	%r79, %r78, 1;
	mul.wide.s32 	%rd30, %r79, %r36;
	add.s64 	%rd31, %rd30, %rd13;
	add.s64 	%rd32, %rd31, %rd15;
	add.s64 	%rd33, %rd31, %rd14;
	shl.b64 	%rd34, %rd33, 2;
	add.s64 	%rd35, %rd4, %rd34;
	ld.global.nc.f32 	%f9, [%rd35+-4];
	shl.b64 	%rd36, %rd32, 2;
	add.s64 	%rd37, %rd4, %rd36;
	ld.global.nc.f32 	%f10, [%rd37];
	fma.rn.ftz.f32 	%f11, %f10, 0f40400000, %f9;
	mul.ftz.f32 	%f12, %f11, 0f3E800000;
	mul.wide.u32 	%rd38, %r9, 4;
	add.s64 	%rd39, %rd24, %rd38;
	st.shared.f32 	[%rd39], %f12;
	add.s64 	%rd40, %rd35, %rd25;
	ld.global.nc.f32 	%f13, [%rd40+-4];
	add.s64 	%rd41, %rd37, %rd25;
	ld.global.nc.f32 	%f14, [%rd41];
	fma.rn.ftz.f32 	%f15, %f14, 0f40400000, %f13;
	mul.ftz.f32 	%f16, %f15, 0f3E800000;
	add.s64 	%rd42, %rd39, %rd28;
	st.shared.f32 	[%rd42], %f16;
LBB13_1:                                // %after_bb
	ld.param.u64 	%rd8, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_39];
	ld.param.u64 	%rd9, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_38];
	ld.param.u64 	%rd12, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_35];
	ld.param.u32 	%r43, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_29];
	bar.sync 	0;
	and.b32  	%r10, %r5, 1;
	or.b32  	%r11, %r10, 10;
	mul.lo.s32 	%r12, %r8, %r11;
	setp.lt.u32 	%p7, %r2, %r11;
	and.pred  	%p8, %p7, %p4;
	@%p8 bra 	LBB13_7;
	bra.uni 	LBB13_2;
LBB13_7:                                // %true_bb10
	ld.param.u64 	%rd10, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_37];
	ld.param.u32 	%r40, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_26];
	ld.param.u32 	%r27, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_10];
	ld.param.u32 	%r26, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_9];
	ld.param.u32 	%r25, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_8];
	ld.param.u32 	%r24, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_7];
	ld.param.u32 	%r23, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_6];
	ld.param.u32 	%r19, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_2];
	cvta.to.global.u64 	%rd3, %rd10;
	mul.lo.s32 	%r80, %r9, %r1;
	cvt.u64.u32 	%rd43, %r80;
	shr.s32 	%r81, %r5, 1;
	add.s32 	%r82, %r81, %r2;
	add.s32 	%r83, %r82, -1;
	shr.s32 	%r84, %r83, 1;
	add.s32 	%r85, %r5, -6;
	shr.s32 	%r86, %r85, 2;
	sub.s32 	%r87, %r84, %r86;
	add.s32 	%r88, %r1, %r4;
	add.s32 	%r89, %r88, %r44;
	mul.wide.s32 	%rd44, %r89, %r40;
	min.s32 	%r90, %r82, %r24;
	max.s32 	%r91, %r90, 1;
	add.s32 	%r92, %r91, %r23;
	mul.wide.s32 	%rd45, %r92, %r25;
	add.s64 	%rd46, %rd45, %rd44;
	shr.s32 	%r93, %r6, 1;
	add.s32 	%r94, %r93, %r3;
	min.s32 	%r95, %r94, %r27;
	max.s32 	%r96, %r95, 1;
	add.s32 	%r97, %r96, %r26;
	cvt.s64.s32 	%rd47, %r97;
	add.s64 	%rd48, %rd46, %rd47;
	cvt.u64.u32 	%rd49, %r8;
	mul.lo.s32 	%r98, %r8, %r2;
	cvt.u64.u32 	%rd50, %r98;
	mul.lo.s32 	%r99, %r12, %r1;
	cvt.u64.u32 	%rd51, %r99;
	cvt.s64.s32 	%rd52, %r43;
	cvt.u64.u32 	%rd53, %r3;
	shl.b32 	%r100, %r9, 1;
	shl.b32 	%r101, %r12, 1;
	shl.b32 	%r102, %r82, 1;
	not.b32 	%r103, %r102;
	and.b32  	%r104, %r103, 2;
	add.s32 	%r105, %r104, %r87;
	cvt.s64.s32 	%rd54, %r105;
	mul.lo.s64 	%rd55, %rd54, %rd49;
	cvt.s64.s32 	%rd56, %r87;
	mul.lo.s64 	%rd57, %rd56, %rd49;
	add.s64 	%rd58, %rd53, %rd52;
	add.s64 	%rd59, %rd58, %rd50;
	add.s64 	%rd60, %rd59, %rd51;
	shl.b64 	%rd61, %rd48, 2;
	add.s64 	%rd62, %rd3, %rd61;
	ld.global.nc.f32 	%f17, [%rd62];
	cvt.u64.u32 	%rd63, %r7;
	sub.s64 	%rd64, %rd53, %rd63;
	add.s64 	%rd65, %rd64, %rd43;
	add.s64 	%rd66, %rd65, %rd55;
	shl.b64 	%rd67, %rd66, 2;
	ld.shared.f32 	%f18, [%rd67+-40];
	add.s64 	%rd68, %rd53, %rd43;
	add.s64 	%rd69, %rd68, %rd57;
	shl.b64 	%rd70, %rd69, 2;
	ld.shared.f32 	%f19, [%rd70];
	fma.rn.ftz.f32 	%f20, %f19, 0f40400000, %f18;
	fma.rn.ftz.f32 	%f21, %f17, 0f40800000, %f20;
	mul.ftz.f32 	%f22, %f21, 0f3E000000;
	shl.b64 	%rd71, %rd60, 2;
	st.shared.f32 	[%rd71], %f22;
	mul.wide.s32 	%rd72, %r19, 4;
	add.s64 	%rd73, %rd62, %rd72;
	ld.global.nc.f32 	%f23, [%rd73];
	add.s32 	%r106, %r100, %r3;
	cvt.u64.u32 	%rd74, %r106;
	sub.s64 	%rd75, %rd74, %rd63;
	add.s64 	%rd76, %rd75, %rd43;
	add.s64 	%rd77, %rd76, %rd55;
	shl.b64 	%rd78, %rd77, 2;
	ld.shared.f32 	%f24, [%rd78+-40];
	add.s64 	%rd79, %rd74, %rd43;
	add.s64 	%rd80, %rd79, %rd57;
	shl.b64 	%rd81, %rd80, 2;
	ld.shared.f32 	%f25, [%rd81];
	fma.rn.ftz.f32 	%f26, %f25, 0f40400000, %f24;
	fma.rn.ftz.f32 	%f27, %f23, 0f40800000, %f26;
	mul.ftz.f32 	%f28, %f27, 0f3E000000;
	mul.wide.u32 	%rd82, %r101, 4;
	add.s64 	%rd83, %rd71, %rd82;
	st.shared.f32 	[%rd83], %f28;
LBB13_2:                                // %after_bb9
	ld.param.u32 	%r42, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_28];
	ld.param.u32 	%r41, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_27];
	ld.param.u32 	%r39, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_25];
	ld.param.u32 	%r38, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_24];
	ld.param.u32 	%r37, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_23];
	ld.param.u32 	%r35, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_21];
	ld.param.u32 	%r34, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_20];
	ld.param.u32 	%r33, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_17];
	ld.param.u32 	%r32, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_16];
	ld.param.u32 	%r31, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_15];
	ld.param.u32 	%r30, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_14];
	ld.param.u32 	%r29, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_13];
	ld.param.u32 	%r28, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_12];
	ld.param.u64 	%rd6, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_0];
	cvta.to.global.u64 	%rd1, %rd8;
	cvta.to.global.u64 	%rd2, %rd9;
	cvta.to.global.u64 	%rd5, %rd12;
	bar.sync 	0;
	and.pred  	%p11, %p1, %p7;
	@%p11 bra 	LBB13_5;
	bra.uni 	LBB13_3;
LBB13_5:                                // %true_bb16
	ld.param.u64 	%rd7, [kernel_filtered_cost_s0_z_z_o___block_id_z_param_1];
	shr.s32 	%r109, %r6, 1;
	mov.u32 	%r110, 1;
	sub.s32 	%r111, %r110, %r109;
	shl.b32 	%r112, %r2, 4;
	add.s32 	%r113, %r112, %r3;
	add.s32 	%r114, %r6, %r3;
	mul.lo.s32 	%r115, %r8, %r2;
	cvt.u64.u32 	%rd84, %r115;
	add.s32 	%r116, %r7, %r3;
	shr.u32 	%r117, %r116, 1;
	shr.s32 	%r118, %r114, 1;
	shl.b32 	%r119, %r114, 1;
	and.b32  	%r120, %r119, 2;
	add.s32 	%r121, %r111, %r118;
	add.s32 	%r122, %r121, %r120;
	shl.b32 	%r123, %r10, 5;
	or.b32  	%r156, %r123, 320;
	shl.b32 	%r124, %r10, 4;
	or.b32  	%r157, %r124, 160;
	shl.b32 	%r125, %r12, 1;
	cvt.s64.s32 	%rd85, %r43;
	cvt.s64.s32 	%rd86, %r122;
	add.s64 	%rd87, %rd84, %rd7;
	add.s64 	%rd88, %rd87, %rd86;
	add.s64 	%rd89, %rd84, %rd85;
	shl.b64 	%rd90, %rd88, 2;
	ld.shared.f32 	%f29, [%rd90];
	cvt.u64.u32 	%rd91, %r117;
	add.s64 	%rd92, %rd89, %rd91;
	shl.b64 	%rd93, %rd92, 2;
	ld.shared.f32 	%f30, [%rd93+4];
	fma.rn.ftz.f32 	%f31, %f30, 0f40400000, %f29;
	mul.ftz.f32 	%f32, %f31, 0f3E800000;
	mul.wide.u32 	%rd94, %r113, 4;
	st.shared.f32 	[%rd94], %f32;
	mul.wide.u32 	%rd95, %r125, 4;
	add.s64 	%rd96, %rd90, %rd95;
	ld.shared.f32 	%f33, [%rd96];
	add.s64 	%rd97, %rd93, %rd95;
	ld.shared.f32 	%f34, [%rd97+4];
	fma.rn.ftz.f32 	%f35, %f34, 0f40400000, %f33;
	mul.ftz.f32 	%f36, %f35, 0f3E800000;
	mul.wide.u32 	%rd98, %r123, 4;
	add.s64 	%rd99, %rd94, %rd98;
	st.shared.f32 	[%rd99+1280], %f36;
	add.s32 	%r126, %r12, %r115;
	cvt.u64.u32 	%rd100, %r126;
	add.s64 	%rd101, %rd100, %rd7;
	add.s64 	%rd102, %rd101, %rd86;
	add.s64 	%rd103, %rd100, %rd85;
	shl.b64 	%rd104, %rd102, 2;
	ld.shared.f32 	%f37, [%rd104];
	add.s64 	%rd105, %rd103, %rd91;
	shl.b64 	%rd106, %rd105, 2;
	ld.shared.f32 	%f38, [%rd106+4];
	fma.rn.ftz.f32 	%f39, %f38, 0f40400000, %f37;
	mul.ftz.f32 	%f40, %f39, 0f3E800000;
	mul.wide.u32 	%rd107, %r124, 4;
	add.s64 	%rd108, %rd94, %rd107;
	st.shared.f32 	[%rd108+640], %f40;
	add.s64 	%rd109, %rd104, %rd95;
	ld.shared.f32 	%f41, [%rd109];
	add.s64 	%rd110, %rd106, %rd95;
	ld.shared.f32 	%f42, [%rd110+4];
	fma.rn.ftz.f32 	%f43, %f42, 0f40400000, %f41;
	mul.ftz.f32 	%f44, %f43, 0f3E800000;
	mul.wide.u32 	%rd111, %r156, 4;
	add.s64 	%rd112, %rd108, %rd111;
	st.shared.f32 	[%rd112+640], %f44;
	bra.uni 	LBB13_4;
LBB13_3:                                // %after_bb9.after_bb15_crit_edge
	shl.b32 	%r107, %r10, 4;
	or.b32  	%r157, %r107, 160;
	shl.b32 	%r108, %r10, 5;
	or.b32  	%r156, %r108, 320;
LBB13_4:                                // %after_bb15
	bar.sync 	0;
	sub.s32 	%r127, %r2, %r35;
	add.s32 	%r128, %r127, %r5;
	mul.wide.s32 	%rd113, %r128, %r28;
	sub.s32 	%r129, %r3, %r34;
	add.s32 	%r130, %r129, %r6;
	cvt.s64.s32 	%rd114, %r130;
	add.s64 	%rd115, %rd113, %rd114;
	shl.b64 	%rd116, %rd115, 2;
	add.s64 	%rd117, %rd5, %rd116;
	ld.global.nc.f32 	%f45, [%rd117];
	add.s32 	%r131, %r1, %r4;
	add.s32 	%r132, %r131, %r30;
	add.s32 	%r133, %r29, -128;
	mul.lo.s32 	%r134, %r133, %r31;
	mul.wide.s32 	%rd118, %r132, %r134;
	sub.s32 	%r135, %r2, %r39;
	add.s32 	%r136, %r135, %r5;
	mul.wide.s32 	%rd119, %r136, %r133;
	mul.lo.s32 	%r137, %r157, %r1;
	cvt.u64.u32 	%rd120, %r137;
	add.s32 	%r138, %r5, %r2;
	shr.s32 	%r139, %r138, 1;
	shr.s32 	%r140, %r5, 1;
	sub.s32 	%r141, %r139, %r140;
	sub.s32 	%r142, %r3, %r38;
	add.s32 	%r143, %r142, %r6;
	cvt.s64.s32 	%rd121, %r143;
	add.s64 	%rd122, %rd119, %rd121;
	add.s64 	%rd123, %rd122, %rd6;
	add.s64 	%rd124, %rd123, %rd118;
	add.s64 	%rd125, %rd1, %rd124;
	ld.global.nc.u8 	%rs1, [%rd125];
	cvt.u16.u8 	%rs2, %rs1;
	add.s64 	%rd126, %rd122, %rd118;
	add.s64 	%rd127, %rd1, %rd126;
	ld.global.nc.u8 	%rs3, [%rd127];
	cvt.u16.u8 	%rs4, %rs3;
	cvt.s64.s32 	%rd128, %r37;
	add.s64 	%rd129, %rd127, %rd128;
	ld.global.nc.u8 	%rs5, [%rd129];
	cvt.u16.u8 	%rs6, %rs5;
	cvt.rn.f32.u16 	%f46, %rs2;
	cvt.rn.f32.u16 	%f47, %rs4;
	cvt.rn.f32.u16 	%f48, %rs6;
	mul.ftz.f32 	%f49, %f48, %f48;
	fma.rn.ftz.f32 	%f50, %f47, %f47, %f49;
	fma.rn.ftz.f32 	%f51, %f46, %f46, %f50;
	mul.ftz.f32 	%f52, %f45, %f51;
	shl.b32 	%r144, %r138, 1;
	and.b32  	%r145, %r144, 2;
	add.s32 	%r146, %r141, 1;
	add.s32 	%r147, %r146, %r145;
	mul.wide.s32 	%rd130, %r147, 16;
	cvt.u64.u32 	%rd131, %r3;
	add.s64 	%rd132, %rd131, %rd120;
	add.s64 	%rd133, %rd132, %rd130;
	shl.b64 	%rd134, %rd133, 2;
	ld.shared.f32 	%f53, [%rd134+-64];
	mul.wide.s32 	%rd135, %r146, 16;
	add.s64 	%rd136, %rd132, %rd135;
	shl.b64 	%rd137, %rd136, 2;
	ld.shared.f32 	%f54, [%rd137];
	fma.rn.ftz.f32 	%f55, %f54, 0f40400000, %f53;
	fma.rn.ftz.f32 	%f56, %f52, 0f40800000, %f55;
	mul.ftz.f32 	%f57, %f56, 0f3E000000;
	add.s32 	%r148, %r137, %r156;
	cvt.u64.u32 	%rd138, %r148;
	add.s64 	%rd139, %rd131, %rd138;
	add.s64 	%rd140, %rd139, %rd130;
	shl.b64 	%rd141, %rd140, 2;
	ld.shared.f32 	%f58, [%rd141+-64];
	add.s64 	%rd142, %rd139, %rd135;
	shl.b64 	%rd143, %rd142, 2;
	ld.shared.f32 	%f59, [%rd143];
	fma.rn.ftz.f32 	%f60, %f59, 0f40400000, %f58;
	fma.rn.ftz.f32 	%f61, %f45, 0f40800000, %f60;
	mul.ftz.f32 	%f62, %f61, 0f3E000000;
	div.approx.ftz.f32 	%f63, %f57, %f62;
	add.s32 	%r149, %r131, %r44;
	add.s32 	%r150, %r32, 16;
	mul.lo.s32 	%r151, %r150, %r33;
	mul.wide.s32 	%rd144, %r149, %r151;
	sub.s32 	%r152, %r2, %r42;
	add.s32 	%r153, %r152, %r5;
	mul.wide.s32 	%rd145, %r153, %r150;
	add.s64 	%rd146, %rd145, %rd144;
	sub.s32 	%r154, %r3, %r41;
	add.s32 	%r155, %r154, %r6;
	cvt.s64.s32 	%rd147, %r155;
	add.s64 	%rd148, %rd146, %rd147;
	shl.b64 	%rd149, %rd148, 2;
	add.s64 	%rd150, %rd2, %rd149;
	st.global.f32 	[%rd150], %f63;
	ret;
}
                                        // -- End function
	// .globl	kernel_argmin_s0_y_y_o___block_id_y // -- Begin function kernel_argmin_s0_y_y_o___block_id_y
.visible .entry kernel_argmin_s0_y_y_o___block_id_y(
	.param .u32 kernel_argmin_s0_y_y_o___block_id_y_param_0,
	.param .u32 kernel_argmin_s0_y_y_o___block_id_y_param_1,
	.param .u32 kernel_argmin_s0_y_y_o___block_id_y_param_2,
	.param .u32 kernel_argmin_s0_y_y_o___block_id_y_param_3,
	.param .u32 kernel_argmin_s0_y_y_o___block_id_y_param_4,
	.param .u32 kernel_argmin_s0_y_y_o___block_id_y_param_5,
	.param .u32 kernel_argmin_s0_y_y_o___block_id_y_param_6,
	.param .u64 kernel_argmin_s0_y_y_o___block_id_y_param_7,
	.param .u64 kernel_argmin_s0_y_y_o___block_id_y_param_8
)                                       // @kernel_argmin_s0_y_y_o___block_id_y
{
	.reg .pred 	%p<2>;
	.reg .b32 	%r<25>;
	.reg .b64 	%rd<11>;

// %bb.0:                               // %entry
	ld.param.u32 	%r8, [kernel_argmin_s0_y_y_o___block_id_y_param_0];
	ld.param.u64 	%rd4, [kernel_argmin_s0_y_y_o___block_id_y_param_8];
	cvta.to.global.u64 	%rd1, %rd4;
	ld.param.u32 	%r9, [kernel_argmin_s0_y_y_o___block_id_y_param_1];
	ld.param.u64 	%rd5, [kernel_argmin_s0_y_y_o___block_id_y_param_7];
	cvta.to.global.u64 	%rd2, %rd5;
	ld.param.u32 	%r10, [kernel_argmin_s0_y_y_o___block_id_y_param_2];
	ld.param.u32 	%r11, [kernel_argmin_s0_y_y_o___block_id_y_param_3];
	mov.u32 	%r12, %ctaid.y;
	mov.u32 	%r1, %ctaid.x;
	ld.param.u32 	%r13, [kernel_argmin_s0_y_y_o___block_id_y_param_4];
	mov.u32 	%r14, %tid.y;
	mov.u32 	%r2, %tid.x;
	shl.b32 	%r15, %r12, 3;
	add.s32 	%r16, %r15, %r8;
	min.s32 	%r17, %r16, %r11;
	setp.ge.s32 	%p1, %r1, %r13;
	sub.s32 	%r18, %r14, %r10;
	add.s32 	%r19, %r18, %r17;
	mul.wide.s32 	%rd3, %r19, %r9;
	@%p1 bra 	LBB14_2;
// %bb.1:                               // %true_bb
	ld.param.u32 	%r6, [kernel_argmin_s0_y_y_o___block_id_y_param_5];
	shl.b32 	%r20, %r1, 3;
	add.s32 	%r21, %r20, %r6;
	add.s32 	%r24, %r21, %r2;
	bra.uni 	LBB14_3;
LBB14_2:                                // %false_bb
	ld.param.u32 	%r7, [kernel_argmin_s0_y_y_o___block_id_y_param_6];
	add.s32 	%r24, %r2, %r7;
LBB14_3:                                // %after_bb
	cvt.s64.s32 	%rd6, %r24;
	add.s64 	%rd7, %rd3, %rd6;
	shl.b64 	%rd8, %rd7, 2;
	add.s64 	%rd9, %rd2, %rd8;
	mov.u32 	%r22, 0;
	st.global.u32 	[%rd9], %r22;
	add.s64 	%rd10, %rd1, %rd8;
	mov.u32 	%r23, 2139095040;
	st.global.u32 	[%rd10], %r23;
	ret;
}
                                        // -- End function
	// .globl	kernel_argmin_s1_y_y_o___block_id_y // -- Begin function kernel_argmin_s1_y_y_o___block_id_y
.visible .entry kernel_argmin_s1_y_y_o___block_id_y(
	.param .u32 kernel_argmin_s1_y_y_o___block_id_y_param_0,
	.param .u32 kernel_argmin_s1_y_y_o___block_id_y_param_1,
	.param .u32 kernel_argmin_s1_y_y_o___block_id_y_param_2,
	.param .u32 kernel_argmin_s1_y_y_o___block_id_y_param_3,
	.param .u32 kernel_argmin_s1_y_y_o___block_id_y_param_4,
	.param .u32 kernel_argmin_s1_y_y_o___block_id_y_param_5,
	.param .u32 kernel_argmin_s1_y_y_o___block_id_y_param_6,
	.param .u32 kernel_argmin_s1_y_y_o___block_id_y_param_7,
	.param .u32 kernel_argmin_s1_y_y_o___block_id_y_param_8,
	.param .u64 kernel_argmin_s1_y_y_o___block_id_y_param_9,
	.param .u64 kernel_argmin_s1_y_y_o___block_id_y_param_10,
	.param .u64 kernel_argmin_s1_y_y_o___block_id_y_param_11
)                                       // @kernel_argmin_s1_y_y_o___block_id_y
{
	.reg .pred 	%p<11>;
	.reg .f32 	%f<23>;
	.reg .b32 	%r<59>;
	.reg .b64 	%rd<56>;

// %bb.0:                               // %entry
	ld.param.u32 	%r19, [kernel_argmin_s1_y_y_o___block_id_y_param_1];
	setp.lt.s32 	%p1, %r19, 1;
	@%p1 bra 	LBB15_9;
// %bb.1:                               // %"for argmin.s1.r$1$x.preheader"
	ld.param.u32 	%r21, [kernel_argmin_s1_y_y_o___block_id_y_param_3];
	ld.param.u32 	%r20, [kernel_argmin_s1_y_y_o___block_id_y_param_2];
	ld.param.u32 	%r22, [kernel_argmin_s1_y_y_o___block_id_y_param_0];
	ld.param.u64 	%rd21, [kernel_argmin_s1_y_y_o___block_id_y_param_11];
	cvta.to.global.u64 	%rd1, %rd21;
	ld.param.u64 	%rd22, [kernel_argmin_s1_y_y_o___block_id_y_param_10];
	cvta.to.global.u64 	%rd2, %rd22;
	ld.param.u64 	%rd23, [kernel_argmin_s1_y_y_o___block_id_y_param_9];
	cvta.to.global.u64 	%rd3, %rd23;
	ld.param.u32 	%r23, [kernel_argmin_s1_y_y_o___block_id_y_param_4];
	mov.u32 	%r24, %ctaid.y;
	ld.param.u32 	%r25, [kernel_argmin_s1_y_y_o___block_id_y_param_5];
	mov.u32 	%r26, %ctaid.x;
	ld.param.u32 	%r27, [kernel_argmin_s1_y_y_o___block_id_y_param_6];
	mov.u32 	%r28, %tid.y;
	ld.param.u32 	%r29, [kernel_argmin_s1_y_y_o___block_id_y_param_7];
	mov.u32 	%r30, %tid.x;
	shl.b32 	%r31, %r24, 3;
	ld.param.u32 	%r32, [kernel_argmin_s1_y_y_o___block_id_y_param_8];
	add.s32 	%r33, %r28, %r31;
	add.s32 	%r34, %r33, %r23;
	mul.wide.s32 	%rd4, %r34, %r32;
	shl.b32 	%r35, %r26, 4;
	add.s32 	%r36, %r30, %r35;
	add.s32 	%r37, %r36, %r25;
	cvt.s64.s32 	%rd5, %r37;
	add.s32 	%r38, %r33, %r27;
	mul.wide.s32 	%rd24, %r38, %r22;
	add.s32 	%r39, %r36, %r29;
	cvt.s64.s32 	%rd25, %r39;
	add.s64 	%rd6, %rd24, %rd25;
	cvt.s64.s32 	%rd7, %r21;
	shl.b64 	%rd26, %rd6, 2;
	add.s64 	%rd8, %rd2, %rd26;
	add.s64 	%rd9, %rd3, %rd26;
	ld.global.f32 	%f22, [%rd8];
	ld.global.u32 	%r58, [%rd9];
	add.s32 	%r42, %r19, -1;
	and.b32  	%r2, %r19, 3;
	setp.lt.u32 	%p2, %r42, 3;
	@%p2 bra 	LBB15_2;
	bra.uni 	LBB15_3;
LBB15_2:
	mov.u32 	%r57, 0;
	setp.eq.s32 	%p8, %r2, 0;
	@%p8 bra 	LBB15_8;
	bra.uni 	LBB15_6;
LBB15_3:                                // %"for argmin.s1.r$1$x.preheader.new"
	sub.s32 	%r57, %r19, %r2;
	cvt.s64.s32 	%rd27, %r20;
	add.s64 	%rd28, %rd27, 3;
	mul.lo.s64 	%rd29, %rd28, %rd7;
	add.s64 	%rd30, %rd29, %rd4;
	add.s64 	%rd31, %rd30, %rd5;
	shl.b64 	%rd10, %rd31, 2;
	shl.b64 	%rd11, %rd7, 4;
	add.s64 	%rd32, %rd27, 2;
	mul.lo.s64 	%rd33, %rd32, %rd7;
	add.s64 	%rd34, %rd33, %rd4;
	add.s64 	%rd35, %rd34, %rd5;
	shl.b64 	%rd12, %rd35, 2;
	add.s64 	%rd36, %rd27, 1;
	mul.lo.s64 	%rd37, %rd36, %rd7;
	add.s64 	%rd38, %rd37, %rd4;
	add.s64 	%rd39, %rd38, %rd5;
	shl.b64 	%rd13, %rd39, 2;
	mul.lo.s64 	%rd40, %rd7, %rd27;
	add.s64 	%rd41, %rd40, %rd4;
	add.s64 	%rd42, %rd41, %rd5;
	shl.b64 	%rd14, %rd42, 2;
	mov.u32 	%r51, 0;
	mov.u64 	%rd54, %rd1;
LBB15_4:                                // %"for argmin.s1.r$1$x"
                                        // =>This Inner Loop Header: Depth=1
	add.s64 	%rd43, %rd54, %rd14;
	ld.global.nc.f32 	%f10, [%rd43];
	setp.lt.ftz.f32 	%p3, %f10, %f22;
	selp.b32 	%r44, %r51, %r58, %p3;
	min.ftz.f32 	%f11, %f10, %f22;
	add.s64 	%rd44, %rd54, %rd13;
	ld.global.nc.f32 	%f12, [%rd44];
	setp.lt.ftz.f32 	%p4, %f12, %f11;
	add.s32 	%r45, %r51, 1;
	selp.b32 	%r46, %r45, %r44, %p4;
	min.ftz.f32 	%f13, %f12, %f11;
	add.s64 	%rd45, %rd54, %rd12;
	ld.global.nc.f32 	%f14, [%rd45];
	setp.lt.ftz.f32 	%p5, %f14, %f13;
	add.s32 	%r47, %r51, 2;
	selp.b32 	%r48, %r47, %r46, %p5;
	min.ftz.f32 	%f15, %f14, %f13;
	add.s64 	%rd46, %rd54, %rd10;
	ld.global.nc.f32 	%f16, [%rd46];
	setp.lt.ftz.f32 	%p6, %f16, %f15;
	add.s32 	%r49, %r51, 3;
	selp.b32 	%r58, %r49, %r48, %p6;
	min.ftz.f32 	%f22, %f16, %f15;
	add.s32 	%r51, %r51, 4;
	add.s64 	%rd54, %rd54, %rd11;
	setp.ne.s32 	%p7, %r57, %r51;
	@%p7 bra 	LBB15_4;
// %bb.5:                               // %"end for argmin.s1.r$1$x.loopexit.unr-lcssa"
	setp.eq.s32 	%p8, %r2, 0;
	@%p8 bra 	LBB15_8;
LBB15_6:                                // %"for argmin.s1.r$1$x.epil.preheader"
	cvt.s64.s32 	%rd47, %r57;
	cvt.s64.s32 	%rd48, %r20;
	add.s64 	%rd49, %rd47, %rd48;
	mul.lo.s64 	%rd50, %rd49, %rd7;
	add.s64 	%rd51, %rd50, %rd4;
	add.s64 	%rd52, %rd51, %rd5;
	shl.b64 	%rd53, %rd52, 2;
	add.s64 	%rd55, %rd1, %rd53;
	shl.b64 	%rd18, %rd7, 2;
	neg.s32 	%r55, %r2;
LBB15_7:                                // %"for argmin.s1.r$1$x.epil"
                                        // =>This Inner Loop Header: Depth=1
	.pragma "nounroll";
	ld.global.nc.f32 	%f17, [%rd55];
	setp.lt.ftz.f32 	%p9, %f17, %f22;
	selp.b32 	%r58, %r57, %r58, %p9;
	min.ftz.f32 	%f22, %f17, %f22;
	add.s32 	%r57, %r57, 1;
	add.s64 	%rd55, %rd55, %rd18;
	add.s32 	%r55, %r55, 1;
	setp.ne.s32 	%p10, %r55, 0;
	@%p10 bra 	LBB15_7;
LBB15_8:                                // %"end for argmin.s1.r$1$x.loopexit"
	st.global.f32 	[%rd8], %f22;
	st.global.u32 	[%rd9], %r58;
LBB15_9:                                // %"end for argmin.s1.r$1$x"
	ret;
}
                                        // -- End function
	// .globl	kernel_final_s0_y_y_o___block_id_y // -- Begin function kernel_final_s0_y_y_o___block_id_y
.visible .entry kernel_final_s0_y_y_o___block_id_y(
	.param .u64 kernel_final_s0_y_y_o___block_id_y_param_0,
	.param .u64 kernel_final_s0_y_y_o___block_id_y_param_1,
	.param .u64 kernel_final_s0_y_y_o___block_id_y_param_2,
	.param .u64 kernel_final_s0_y_y_o___block_id_y_param_3,
	.param .u64 kernel_final_s0_y_y_o___block_id_y_param_4,
	.param .u64 kernel_final_s0_y_y_o___block_id_y_param_5,
	.param .u64 kernel_final_s0_y_y_o___block_id_y_param_6,
	.param .u32 kernel_final_s0_y_y_o___block_id_y_param_7,
	.param .u32 kernel_final_s0_y_y_o___block_id_y_param_8,
	.param .u32 kernel_final_s0_y_y_o___block_id_y_param_9,
	.param .u32 kernel_final_s0_y_y_o___block_id_y_param_10,
	.param .u32 kernel_final_s0_y_y_o___block_id_y_param_11,
	.param .u32 kernel_final_s0_y_y_o___block_id_y_param_12,
	.param .u32 kernel_final_s0_y_y_o___block_id_y_param_13,
	.param .f32 kernel_final_s0_y_y_o___block_id_y_param_14,
	.param .u32 kernel_final_s0_y_y_o___block_id_y_param_15,
	.param .u32 kernel_final_s0_y_y_o___block_id_y_param_16,
	.param .u32 kernel_final_s0_y_y_o___block_id_y_param_17,
	.param .u32 kernel_final_s0_y_y_o___block_id_y_param_18,
	.param .u32 kernel_final_s0_y_y_o___block_id_y_param_19,
	.param .u32 kernel_final_s0_y_y_o___block_id_y_param_20,
	.param .u32 kernel_final_s0_y_y_o___block_id_y_param_21,
	.param .u32 kernel_final_s0_y_y_o___block_id_y_param_22,
	.param .u32 kernel_final_s0_y_y_o___block_id_y_param_23,
	.param .u32 kernel_final_s0_y_y_o___block_id_y_param_24,
	.param .u32 kernel_final_s0_y_y_o___block_id_y_param_25,
	.param .u32 kernel_final_s0_y_y_o___block_id_y_param_26,
	.param .u32 kernel_final_s0_y_y_o___block_id_y_param_27,
	.param .u32 kernel_final_s0_y_y_o___block_id_y_param_28,
	.param .u32 kernel_final_s0_y_y_o___block_id_y_param_29,
	.param .u32 kernel_final_s0_y_y_o___block_id_y_param_30,
	.param .u64 kernel_final_s0_y_y_o___block_id_y_param_31,
	.param .u64 kernel_final_s0_y_y_o___block_id_y_param_32,
	.param .u64 kernel_final_s0_y_y_o___block_id_y_param_33
)                                       // @kernel_final_s0_y_y_o___block_id_y
{
	.reg .pred 	%p<40>;
	.reg .b16 	%rs<13>;
	.reg .f32 	%f<124>;
	.reg .b32 	%r<271>;
	.reg .b64 	%rd<144>;

// %bb.0:                               // %entry
	ld.param.u64 	%rd42, [kernel_final_s0_y_y_o___block_id_y_param_31];
	mov.u32 	%r97, %ctaid.y;
	mov.u32 	%r98, %ctaid.x;
	mov.u32 	%r99, %tid.y;
	mov.u32 	%r100, %tid.x;
	mul.lo.s32 	%r101, %r98, 10;
	ld.param.u32 	%r102, [kernel_final_s0_y_y_o___block_id_y_param_28];
	ld.param.u32 	%r103, [kernel_final_s0_y_y_o___block_id_y_param_29];
	setp.ge.s32 	%p6, %r100, %r103;
	cvt.u64.u32 	%rd4, %r99;
	cvt.s64.s32 	%rd43, %r103;
	mul.lo.s64 	%rd5, %rd4, %rd43;
	cvt.u64.u32 	%rd6, %r100;
	add.s64 	%rd7, %rd5, %rd6;
	shl.b64 	%rd141, %rd7, 2;
	@%p6 bra 	LBB16_1;
// %bb.2:                               // %true_bb
	mov.u32 	%r104, -8388608;
	st.shared.u32 	[%rd141], %r104;
	mov.pred 	%p36, -1;
	bra.uni 	LBB16_3;
LBB16_1:
	mov.pred 	%p36, 0;
LBB16_3:                                // %after_bb
	ld.param.u32 	%r95, [kernel_final_s0_y_y_o___block_id_y_param_27];
	shl.b32 	%r1, %r97, 3;
	ld.param.u32 	%r92, [kernel_final_s0_y_y_o___block_id_y_param_23];
	ld.param.u32 	%r91, [kernel_final_s0_y_y_o___block_id_y_param_22];
	ld.param.u32 	%r86, [kernel_final_s0_y_y_o___block_id_y_param_17];
	ld.param.u32 	%r84, [kernel_final_s0_y_y_o___block_id_y_param_15];
	ld.param.f32 	%f25, [kernel_final_s0_y_y_o___block_id_y_param_14];
	ld.param.u32 	%r78, [kernel_final_s0_y_y_o___block_id_y_param_8];
	ld.param.u32 	%r77, [kernel_final_s0_y_y_o___block_id_y_param_7];
	cvta.to.global.u64 	%rd3, %rd42;
	min.s32 	%r3, %r101, %r102;
	bar.sync 	0;
	@!%p36 bra 	LBB16_12;
	bra.uni 	LBB16_4;
LBB16_4:                                // %true_bb1
	neg.s32 	%r253, %r92;
	sub.s32 	%r255, %r86, %r92;
	setp.le.s32 	%p8, %r255, %r253;
	@%p8 bra 	LBB16_12;
// %bb.5:                               // %"for maximum.s1.r$2$x.preheader"
	ld.param.u32 	%r96, [kernel_final_s0_y_y_o___block_id_y_param_30];
	cvt.u32.u64 	%r105, %rd6;
	add.s32 	%r106, %r3, %r105;
	add.s32 	%r107, %r106, %r96;
	cvt.s64.s32 	%rd9, %r78;
	cvt.s64.s32 	%rd10, %r107;
	ld.shared.f32 	%f117, [%rd141];
	add.s32 	%r6, %r86, -1;
	and.b32  	%r7, %r86, 3;
	setp.eq.s32 	%p9, %r7, 0;
	@%p9 bra 	LBB16_8;
// %bb.6:                               // %"for maximum.s1.r$2$x.prol.preheader"
	cvt.u32.u64 	%r108, %rd4;
	add.s32 	%r109, %r108, %r77;
	not.b32 	%r110, %r1;
	not.b32 	%r111, %r95;
	max.s32 	%r112, %r110, %r111;
	sub.s32 	%r8, %r109, %r112;
	neg.s32 	%r251, %r7;
LBB16_7:                                // %"for maximum.s1.r$2$x.prol"
                                        // =>This Inner Loop Header: Depth=1
	.pragma "nounroll";
	add.s32 	%r113, %r8, %r253;
	add.s32 	%r114, %r113, -1;
	cvt.s64.s32 	%rd44, %r114;
	mul.lo.s64 	%rd45, %rd44, %rd9;
	add.s64 	%rd46, %rd45, %rd10;
	shl.b64 	%rd47, %rd46, 2;
	add.s64 	%rd48, %rd3, %rd47;
	ld.global.nc.u32 	%r115, [%rd48];
	sub.s32 	%r116, %r115, %r91;
	abs.s32 	%r117, %r116;
	cvt.rn.f32.u32 	%f27, %r117;
	mul.ftz.f32 	%f28, %f27, %f25;
	max.ftz.f32 	%f117, %f117, %f28;
	add.s32 	%r253, %r253, 1;
	add.s32 	%r251, %r251, 1;
	setp.ne.s32 	%p10, %r251, 0;
	@%p10 bra 	LBB16_7;
LBB16_8:                                // %"for maximum.s1.r$2$x.prol.loopexit"
	setp.lt.u32 	%p11, %r6, 3;
	@%p11 bra 	LBB16_11;
// %bb.9:                               // %"for maximum.s1.r$2$x.preheader.new"
	cvt.u32.u64 	%r118, %rd4;
	add.s32 	%r119, %r118, %r77;
	not.b32 	%r120, %r1;
	not.b32 	%r121, %r95;
	max.s32 	%r122, %r120, %r121;
	sub.s32 	%r254, %r119, %r122;
LBB16_10:                               // %"for maximum.s1.r$2$x"
                                        // =>This Inner Loop Header: Depth=1
	add.s32 	%r123, %r253, %r254;
	add.s32 	%r124, %r123, -1;
	cvt.s64.s32 	%rd49, %r124;
	mul.lo.s64 	%rd50, %rd49, %rd9;
	add.s64 	%rd51, %rd50, %rd10;
	shl.b64 	%rd52, %rd51, 2;
	add.s64 	%rd53, %rd3, %rd52;
	ld.global.nc.u32 	%r125, [%rd53];
	sub.s32 	%r126, %r125, %r91;
	abs.s32 	%r127, %r126;
	cvt.rn.f32.u32 	%f29, %r127;
	mul.ftz.f32 	%f30, %f29, %f25;
	max.ftz.f32 	%f31, %f117, %f30;
	cvt.s64.s32 	%rd54, %r123;
	mul.lo.s64 	%rd55, %rd54, %rd9;
	add.s64 	%rd56, %rd55, %rd10;
	shl.b64 	%rd57, %rd56, 2;
	add.s64 	%rd58, %rd3, %rd57;
	ld.global.nc.u32 	%r128, [%rd58];
	sub.s32 	%r129, %r128, %r91;
	abs.s32 	%r130, %r129;
	cvt.rn.f32.u32 	%f32, %r130;
	mul.ftz.f32 	%f33, %f32, %f25;
	max.ftz.f32 	%f34, %f31, %f33;
	add.s32 	%r131, %r123, 1;
	cvt.s64.s32 	%rd59, %r131;
	mul.lo.s64 	%rd60, %rd59, %rd9;
	add.s64 	%rd61, %rd60, %rd10;
	shl.b64 	%rd62, %rd61, 2;
	add.s64 	%rd63, %rd3, %rd62;
	ld.global.nc.u32 	%r132, [%rd63];
	sub.s32 	%r133, %r132, %r91;
	abs.s32 	%r134, %r133;
	cvt.rn.f32.u32 	%f35, %r134;
	mul.ftz.f32 	%f36, %f35, %f25;
	max.ftz.f32 	%f37, %f34, %f36;
	add.s32 	%r135, %r123, 2;
	cvt.s64.s32 	%rd64, %r135;
	mul.lo.s64 	%rd65, %rd64, %rd9;
	add.s64 	%rd66, %rd65, %rd10;
	shl.b64 	%rd67, %rd66, 2;
	add.s64 	%rd68, %rd3, %rd67;
	ld.global.nc.u32 	%r136, [%rd68];
	sub.s32 	%r137, %r136, %r91;
	abs.s32 	%r138, %r137;
	cvt.rn.f32.u32 	%f38, %r138;
	mul.ftz.f32 	%f39, %f38, %f25;
	max.ftz.f32 	%f117, %f37, %f39;
	add.s32 	%r255, %r255, -4;
	add.s32 	%r254, %r254, 4;
	setp.eq.s32 	%p12, %r253, %r255;
	@%p12 bra 	LBB16_11;
	bra.uni 	LBB16_10;
LBB16_11:                               // %after_bb3.loopexit
	st.shared.f32 	[%rd141], %f117;
LBB16_12:                               // %after_bb3
	cvt.u32.u64 	%r139, %rd6;
	cvt.u32.u64 	%r140, %rd4;
	bar.sync 	0;
	setp.lt.u32 	%p14, %r139, 10;
	mul.lo.s32 	%r141, %r140, 10;
	cvt.u64.u32 	%rd11, %r141;
	cvt.s64.s32 	%rd12, %r84;
	@%p14 bra 	LBB16_14;
	bra.uni 	LBB16_13;
LBB16_14:                               // %true_bb4
	add.s64 	%rd69, %rd11, %rd12;
	add.s64 	%rd70, %rd69, %rd6;
	shl.b64 	%rd13, %rd70, 2;
	mov.u32 	%r142, -8388608;
	st.shared.u32 	[%rd13], %r142;
	mov.pred 	%p37, -1;
	bra.uni 	LBB16_15;
LBB16_13:
	mov.pred 	%p37, 0;
LBB16_15:                               // %after_bb6
	bar.sync 	0;
	@!%p37 bra 	LBB16_24;
	bra.uni 	LBB16_16;
LBB16_16:                               // %true_bb7
	neg.s32 	%r258, %r92;
	sub.s32 	%r143, %r86, %r92;
	setp.le.s32 	%p16, %r143, %r258;
	@%p16 bra 	LBB16_24;
// %bb.17:                              // %"for maximum$1.s1.r$2$x.preheader"
	mul.lo.s64 	%rd71, %rd4, 10;
	add.s64 	%rd72, %rd71, %rd12;
	add.s64 	%rd73, %rd72, %rd6;
	shl.b64 	%rd14, %rd73, 2;
	ld.shared.f32 	%f118, [%rd14];
	add.s32 	%r21, %r86, -1;
	and.b32  	%r22, %r86, 7;
	setp.eq.s32 	%p17, %r22, 0;
	@%p17 bra 	LBB16_21;
// %bb.18:                              // %"for maximum$1.s1.r$2$x.prol.preheader"
	neg.s32 	%r256, %r22;
	mov.u32 	%r257, %r92;
LBB16_19:                               // %"for maximum$1.s1.r$2$x.prol"
                                        // =>This Inner Loop Header: Depth=1
	.pragma "nounroll";
	ld.shared.f32 	%f40, [%rd141];
	max.ftz.f32 	%f118, %f40, %f118;
	st.shared.f32 	[%rd14], %f118;
	add.s32 	%r257, %r257, -1;
	add.s64 	%rd141, %rd141, 4;
	add.s32 	%r256, %r256, 1;
	setp.ne.s32 	%p18, %r256, 0;
	@%p18 bra 	LBB16_19;
// %bb.20:                              // %"for maximum$1.s1.r$2$x.prol.loopexit.loopexit"
	neg.s32 	%r258, %r257;
LBB16_21:                               // %"for maximum$1.s1.r$2$x.prol.loopexit"
	setp.lt.u32 	%p19, %r21, 7;
	@%p19 bra 	LBB16_24;
// %bb.22:                              // %"for maximum$1.s1.r$2$x.preheader.new"
	sub.s32 	%r145, %r86, %r258;
	sub.s32 	%r260, %r145, %r92;
	add.s32 	%r146, %r139, %r258;
	add.s32 	%r259, %r146, %r92;
LBB16_23:                               // %"for maximum$1.s1.r$2$x"
                                        // =>This Inner Loop Header: Depth=1
	cvt.s64.s32 	%rd74, %r259;
	add.s64 	%rd75, %rd5, %rd74;
	shl.b64 	%rd76, %rd75, 2;
	ld.shared.f32 	%f41, [%rd76];
	max.ftz.f32 	%f42, %f41, %f118;
	st.shared.f32 	[%rd14], %f42;
	ld.shared.f32 	%f43, [%rd76+4];
	max.ftz.f32 	%f44, %f43, %f42;
	st.shared.f32 	[%rd14], %f44;
	ld.shared.f32 	%f45, [%rd76+8];
	max.ftz.f32 	%f46, %f45, %f44;
	st.shared.f32 	[%rd14], %f46;
	ld.shared.f32 	%f47, [%rd76+12];
	max.ftz.f32 	%f48, %f47, %f46;
	st.shared.f32 	[%rd14], %f48;
	ld.shared.f32 	%f49, [%rd76+16];
	max.ftz.f32 	%f50, %f49, %f48;
	st.shared.f32 	[%rd14], %f50;
	ld.shared.f32 	%f51, [%rd76+20];
	max.ftz.f32 	%f52, %f51, %f50;
	st.shared.f32 	[%rd14], %f52;
	ld.shared.f32 	%f53, [%rd76+24];
	max.ftz.f32 	%f54, %f53, %f52;
	st.shared.f32 	[%rd14], %f54;
	ld.shared.f32 	%f55, [%rd76+28];
	max.ftz.f32 	%f118, %f55, %f54;
	st.shared.f32 	[%rd14], %f118;
	add.s32 	%r260, %r260, -8;
	add.s32 	%r259, %r259, 8;
	setp.eq.s32 	%p20, %r260, 0;
	@%p20 bra 	LBB16_24;
	bra.uni 	LBB16_23;
LBB16_24:                               // %after_bb9
	ld.param.u64 	%rd40, [kernel_final_s0_y_y_o___block_id_y_param_33];
	ld.param.u32 	%r89, [kernel_final_s0_y_y_o___block_id_y_param_20];
	ld.param.u32 	%r88, [kernel_final_s0_y_y_o___block_id_y_param_19];
	ld.param.u32 	%r87, [kernel_final_s0_y_y_o___block_id_y_param_18];
	min.s32 	%r2, %r1, %r95;
	bar.sync 	0;
	@%p14 bra 	LBB16_28;
	bra.uni 	LBB16_25;
LBB16_28:                               // %true_bb10
	setp.lt.s32 	%p24, %r87, 1;
	mov.pred 	%p38, -1;
	@%p24 bra 	LBB16_26;
// %bb.29:                              // %"for sample_weight.s0.z.preheader"
	ld.param.u32 	%r80, [kernel_final_s0_y_y_o___block_id_y_param_10];
	ld.param.u32 	%r79, [kernel_final_s0_y_y_o___block_id_y_param_9];
	cvt.u32.u64 	%r150, %rd11;
	add.s32 	%r151, %r150, %r139;
	cvt.u64.u32 	%rd18, %r151;
	add.s32 	%r152, %r2, %r140;
	add.s32 	%r36, %r152, %r89;
	add.s32 	%r153, %r3, %r139;
	add.s32 	%r37, %r153, %r88;
	mul.lo.s32 	%r38, %r37, 1040796640;
	add.s32 	%r39, %r152, %r77;
	add.s32 	%r40, %r153, %r80;
	add.s32 	%r154, %r38, 1527534985;
	add.s32 	%r155, %r37, -902964096;
	add.s32 	%r156, %r38, -1541314231;
	add.s32 	%r157, %r37, 475272354;
	add.s64 	%rd77, %rd18, %rd12;
	mad.lo.s32 	%r158, %r154, %r155, %r36;
	mad.lo.s32 	%r159, %r158, 1040796640, 1337891305;
	add.s32 	%r160, %r158, 576942909;
	mul.lo.s32 	%r161, %r159, %r160;
	shl.b64 	%rd19, %rd77, 2;
	neg.s32 	%r41, %r79;
	mad.lo.s32 	%r162, %r156, %r157, %r36;
	mad.lo.s32 	%r163, %r162, 1040796640, 1337891305;
	add.s32 	%r164, %r162, 576942909;
	mul.lo.s32 	%r165, %r163, %r164;
	cvt.s64.s32 	%rd20, %r78;
	mul.wide.s32 	%rd78, %r39, %r78;
	cvt.s64.s32 	%rd79, %r40;
	add.s64 	%rd80, %rd78, %rd79;
	shl.b64 	%rd81, %rd80, 2;
	add.s64 	%rd82, %rd3, %rd81;
	ld.global.nc.u32 	%r42, [%rd82];
	sub.s32 	%r166, %r42, %r91;
	abs.s32 	%r167, %r166;
	cvt.rn.f32.u32 	%f56, %r167;
	mul.ftz.f32 	%f57, %f56, %f25;
	mul.ftz.f32 	%f15, %f57, %f57;
	add.s32 	%r265, %r165, 576942909;
	mad.lo.s32 	%r264, %r165, 1040796640, 1337891305;
	add.s32 	%r263, %r161, 576942909;
	mad.lo.s32 	%r262, %r161, 1040796640, 1337891305;
	shl.b64 	%rd142, %rd18, 2;
	mov.u32 	%r261, %r87;
LBB16_30:                               // %"for sample_weight.s0.z"
                                        // =>This Inner Loop Header: Depth=1
	ld.shared.f32 	%f58, [%rd19];
	mad.lo.s32 	%r168, %r262, %r263, 576942909;
	shr.u32 	%r169, %r168, 9;
	or.b32  	%r170, %r169, 1065353216;
	mov.b32 	%f59, %r170;
	min.ftz.f32 	%f60, %f59, 0f40000000;
	max.ftz.f32 	%f61, %f60, 0f3F800000;
	fma.rn.ftz.f32 	%f62, %f61, 0f40000000, 0fC0400000;
	mul.ftz.f32 	%f63, %f58, %f62;
	cvt.rzi.ftz.s32.f32 	%r171, %f63;
	min.s32 	%r172, %r171, %r79;
	max.s32 	%r173, %r172, %r41;
	mad.lo.s32 	%r174, %r264, %r265, 576942909;
	shr.u32 	%r175, %r174, 9;
	or.b32  	%r176, %r175, 1065353216;
	mov.b32 	%f64, %r176;
	min.ftz.f32 	%f65, %f64, 0f40000000;
	max.ftz.f32 	%f66, %f65, 0f3F800000;
	fma.rn.ftz.f32 	%f67, %f66, 0f40000000, 0fC0400000;
	mul.ftz.f32 	%f68, %f58, %f67;
	cvt.rzi.ftz.s32.f32 	%r177, %f68;
	min.s32 	%r178, %r177, %r79;
	max.s32 	%r179, %r178, %r41;
	mul.lo.s32 	%r180, %r179, %r179;
	mad.lo.s32 	%r181, %r173, %r173, %r180;
	cvt.rn.f32.s32 	%f69, %r181;
	add.s32 	%r182, %r179, %r39;
	cvt.s64.s32 	%rd83, %r182;
	mul.lo.s64 	%rd84, %rd83, %rd20;
	add.s32 	%r183, %r173, %r40;
	cvt.s64.s32 	%rd85, %r183;
	add.s64 	%rd86, %rd84, %rd85;
	shl.b64 	%rd87, %rd86, 2;
	add.s64 	%rd88, %rd3, %rd87;
	ld.global.nc.u32 	%r184, [%rd88];
	sub.s32 	%r185, %r184, %r91;
	abs.s32 	%r186, %r185;
	cvt.rn.f32.u32 	%f70, %r186;
	mul.ftz.f32 	%f71, %f70, %f25;
	setp.gt.ftz.f32 	%p26, %f15, %f69;
	setp.lt.s32 	%p27, %r184, %r42;
	mul.ftz.f32 	%f72, %f71, %f71;
	setp.gt.ftz.f32 	%p28, %f72, %f69;
	selp.f32 	%f73, 0f3F800000, 0f00000000, %p26;
	selp.f32 	%f74, 0f3F800000, %f73, %p27;
	selp.f32 	%f75, %f74, 0f00000000, %p28;
	st.shared.f32 	[%rd142], %f75;
	add.s32 	%r265, %r265, 1;
	add.s32 	%r264, %r264, 1040796640;
	add.s32 	%r263, %r263, 1;
	add.s32 	%r262, %r262, 1040796640;
	add.s64 	%rd142, %rd142, 320;
	add.s32 	%r261, %r261, -1;
	setp.eq.s32 	%p29, %r261, 0;
	@%p29 bra 	LBB16_26;
	bra.uni 	LBB16_30;
LBB16_25:
	mov.pred 	%p38, 0;
LBB16_26:                               // %after_bb12
	ld.param.u32 	%r93, [kernel_final_s0_y_y_o___block_id_y_param_24];
	ld.param.u32 	%r85, [kernel_final_s0_y_y_o___block_id_y_param_16];
	ld.param.u32 	%r83, [kernel_final_s0_y_y_o___block_id_y_param_13];
	ld.param.u32 	%r82, [kernel_final_s0_y_y_o___block_id_y_param_12];
	ld.param.u32 	%r81, [kernel_final_s0_y_y_o___block_id_y_param_11];
	ld.param.u64 	%rd36, [kernel_final_s0_y_y_o___block_id_y_param_3];
	cvta.to.global.u64 	%rd1, %rd40;
	bar.sync 	0;
	@%p38 bra 	LBB16_27;
	bra.uni 	LBB16_31;
LBB16_27:                               // %true_bb13
	ld.param.u64 	%rd37, [kernel_final_s0_y_y_o___block_id_y_param_4];
	ld.param.u64 	%rd35, [kernel_final_s0_y_y_o___block_id_y_param_2];
	ld.param.u64 	%rd34, [kernel_final_s0_y_y_o___block_id_y_param_1];
	cvt.u32.u64 	%r189, %rd11;
	add.s32 	%r190, %r2, %r140;
	add.s32 	%r191, %r190, %r81;
	mul.wide.s32 	%rd89, %r191, %r82;
	add.s32 	%r192, %r3, %r139;
	add.s32 	%r193, %r192, %r83;
	cvt.s64.s32 	%rd90, %r193;
	add.s64 	%rd91, %rd89, %rd90;
	add.s64 	%rd92, %rd1, %rd91;
	ld.global.nc.u8 	%rs1, [%rd92];
	cvt.u16.u8 	%rs2, %rs1;
	cvt.rn.f32.u16 	%f76, %rs2;
	cvt.s64.s32 	%rd93, %r85;
	add.s32 	%r194, %r139, %r189;
	cvt.u64.u32 	%rd94, %r194;
	add.s64 	%rd95, %rd94, %rd93;
	shl.b64 	%rd96, %rd95, 2;
	st.shared.f32 	[%rd96], %f76;
	cvt.s64.s32 	%rd97, %r93;
	add.s64 	%rd98, %rd92, %rd97;
	ld.global.nc.u8 	%rs3, [%rd98];
	cvt.u16.u8 	%rs4, %rs3;
	cvt.rn.f32.u16 	%f77, %rs4;
	add.s64 	%rd99, %rd94, %rd37;
	shl.b64 	%rd100, %rd99, 2;
	st.shared.f32 	[%rd100], %f77;
	add.s64 	%rd101, %rd92, %rd36;
	ld.global.nc.u8 	%rs5, [%rd101];
	cvt.u16.u8 	%rs6, %rs5;
	cvt.rn.f32.u16 	%f78, %rs6;
	add.s64 	%rd102, %rd94, %rd35;
	shl.b64 	%rd103, %rd102, 2;
	st.shared.f32 	[%rd103], %f78;
	add.s64 	%rd104, %rd94, %rd34;
	shl.b64 	%rd105, %rd104, 2;
	mov.u32 	%r195, 1132396544;
	st.shared.u32 	[%rd105], %r195;
LBB16_31:                               // %after_bb15
	setp.gt.u32 	%p31, %r139, 9;
	bar.sync 	0;
	@%p31 bra 	LBB16_32;
// %bb.36:                              // %true_bb17
	setp.lt.s32 	%p33, %r87, 1;
	mov.pred 	%p39, -1;
	@%p33 bra 	LBB16_33;
// %bb.37:                              // %"for output.s1.s$x.preheader"
	ld.param.u32 	%r94, [kernel_final_s0_y_y_o___block_id_y_param_25];
	cvt.u32.u64 	%r199, %rd11;
	add.s32 	%r200, %r199, %r139;
	cvt.u64.u32 	%rd24, %r200;
	cvt.s64.s32 	%rd106, %r85;
	add.s64 	%rd25, %rd24, %rd106;
	add.s32 	%r201, %r2, %r140;
	add.s32 	%r57, %r201, %r89;
	add.s32 	%r202, %r3, %r139;
	add.s32 	%r58, %r202, %r88;
	mul.lo.s32 	%r59, %r58, 1040796640;
	add.s32 	%r60, %r201, %r81;
	add.s32 	%r61, %r202, %r83;
	add.s32 	%r203, %r59, 1527534985;
	add.s32 	%r204, %r58, -902964096;
	add.s32 	%r205, %r59, -1541314231;
	add.s32 	%r206, %r58, 475272354;
	add.s64 	%rd107, %rd24, %rd12;
	mad.lo.s32 	%r207, %r203, %r204, %r57;
	mad.lo.s32 	%r208, %r207, 1040796640, 1337891305;
	add.s32 	%r209, %r207, 576942909;
	mul.lo.s32 	%r210, %r208, %r209;
	shl.b64 	%rd26, %rd107, 2;
	mad.lo.s32 	%r211, %r205, %r206, %r57;
	mad.lo.s32 	%r212, %r211, 1040796640, 1337891305;
	add.s32 	%r213, %r211, 576942909;
	mul.lo.s32 	%r214, %r212, %r213;
	shl.b64 	%rd27, %rd25, 2;
	neg.s32 	%r62, %r94;
	cvt.s64.s32 	%rd28, %r82;
	cvt.s64.s32 	%rd29, %r93;
	ld.shared.f32 	%f123, [%rd27];
	ld.shared.f32 	%f122, [%rd27+320];
	ld.shared.f32 	%f121, [%rd27+640];
	add.s32 	%r270, %r214, 576942909;
	mad.lo.s32 	%r269, %r214, 1040796640, 1337891305;
	add.s32 	%r268, %r210, 576942909;
	mad.lo.s32 	%r267, %r210, 1040796640, 1337891305;
	shl.b64 	%rd143, %rd24, 2;
LBB16_38:                               // %"for output.s1.s$x"
                                        // =>This Inner Loop Header: Depth=1
	ld.shared.f32 	%f79, [%rd26];
	ld.shared.f32 	%f80, [%rd143];
	mad.lo.s32 	%r215, %r269, %r270, 576942909;
	shr.u32 	%r216, %r215, 9;
	or.b32  	%r217, %r216, 1065353216;
	mov.b32 	%f81, %r217;
	min.ftz.f32 	%f82, %f81, 0f40000000;
	max.ftz.f32 	%f83, %f82, 0f3F800000;
	fma.rn.ftz.f32 	%f84, %f83, 0f40000000, 0fC0400000;
	mul.ftz.f32 	%f85, %f79, %f84;
	cvt.rzi.ftz.s32.f32 	%r218, %f85;
	min.s32 	%r219, %r218, %r94;
	max.s32 	%r220, %r219, %r62;
	add.s32 	%r221, %r220, %r60;
	cvt.s64.s32 	%rd108, %r221;
	mul.lo.s64 	%rd109, %rd108, %rd28;
	mad.lo.s32 	%r222, %r267, %r268, 576942909;
	shr.u32 	%r223, %r222, 9;
	or.b32  	%r224, %r223, 1065353216;
	mov.b32 	%f86, %r224;
	min.ftz.f32 	%f87, %f86, 0f40000000;
	max.ftz.f32 	%f88, %f87, 0f3F800000;
	fma.rn.ftz.f32 	%f89, %f88, 0f40000000, 0fC0400000;
	mul.ftz.f32 	%f90, %f79, %f89;
	cvt.rzi.ftz.s32.f32 	%r225, %f90;
	min.s32 	%r226, %r225, %r94;
	max.s32 	%r227, %r226, %r62;
	add.s32 	%r228, %r227, %r61;
	cvt.s64.s32 	%rd110, %r228;
	add.s64 	%rd111, %rd109, %rd110;
	add.s64 	%rd112, %rd1, %rd111;
	ld.global.nc.u8 	%rs7, [%rd112];
	cvt.u16.u8 	%rs8, %rs7;
	cvt.rn.f32.u16 	%f91, %rs8;
	fma.rn.ftz.f32 	%f123, %f80, %f91, %f123;
	st.shared.f32 	[%rd27], %f123;
	ld.shared.f32 	%f92, [%rd26];
	ld.shared.f32 	%f93, [%rd143];
	mul.ftz.f32 	%f94, %f92, %f84;
	cvt.rzi.ftz.s32.f32 	%r229, %f94;
	min.s32 	%r230, %r229, %r94;
	max.s32 	%r231, %r230, %r62;
	add.s32 	%r232, %r231, %r60;
	cvt.s64.s32 	%rd113, %r232;
	mul.lo.s64 	%rd114, %rd113, %rd28;
	mul.ftz.f32 	%f95, %f92, %f89;
	cvt.rzi.ftz.s32.f32 	%r233, %f95;
	min.s32 	%r234, %r233, %r94;
	max.s32 	%r235, %r234, %r62;
	add.s32 	%r236, %r235, %r61;
	cvt.s64.s32 	%rd115, %r236;
	add.s64 	%rd116, %rd115, %rd29;
	add.s64 	%rd117, %rd116, %rd114;
	add.s64 	%rd118, %rd1, %rd117;
	ld.global.nc.u8 	%rs9, [%rd118];
	cvt.u16.u8 	%rs10, %rs9;
	cvt.rn.f32.u16 	%f96, %rs10;
	fma.rn.ftz.f32 	%f122, %f93, %f96, %f122;
	st.shared.f32 	[%rd27+320], %f122;
	ld.shared.f32 	%f97, [%rd26];
	ld.shared.f32 	%f98, [%rd143];
	mul.ftz.f32 	%f99, %f97, %f84;
	cvt.rzi.ftz.s32.f32 	%r237, %f99;
	min.s32 	%r238, %r237, %r94;
	max.s32 	%r239, %r238, %r62;
	add.s32 	%r240, %r239, %r60;
	cvt.s64.s32 	%rd119, %r240;
	mul.lo.s64 	%rd120, %rd119, %rd28;
	mul.ftz.f32 	%f100, %f97, %f89;
	cvt.rzi.ftz.s32.f32 	%r241, %f100;
	min.s32 	%r242, %r241, %r94;
	max.s32 	%r243, %r242, %r62;
	add.s32 	%r244, %r243, %r61;
	cvt.s64.s32 	%rd121, %r244;
	add.s64 	%rd122, %rd121, %rd36;
	add.s64 	%rd123, %rd122, %rd120;
	add.s64 	%rd124, %rd1, %rd123;
	ld.global.nc.u8 	%rs11, [%rd124];
	cvt.u16.u8 	%rs12, %rs11;
	cvt.rn.f32.u16 	%f101, %rs12;
	fma.rn.ftz.f32 	%f121, %f98, %f101, %f121;
	st.shared.f32 	[%rd27+640], %f121;
	ld.shared.f32 	%f102, [%rd27+960];
	ld.shared.f32 	%f103, [%rd143];
	fma.rn.ftz.f32 	%f104, %f103, 0f437F0000, %f102;
	st.shared.f32 	[%rd27+960], %f104;
	add.s32 	%r270, %r270, 1;
	add.s32 	%r269, %r269, 1040796640;
	add.s32 	%r268, %r268, 1;
	add.s32 	%r267, %r267, 1040796640;
	add.s64 	%rd143, %rd143, 320;
	add.s32 	%r87, %r87, -1;
	setp.eq.s32 	%p35, %r87, 0;
	@%p35 bra 	LBB16_33;
	bra.uni 	LBB16_38;
LBB16_32:
	mov.pred 	%p39, 0;
LBB16_33:                               // %after_bb19
	bar.sync 	0;
	@%p39 bra 	LBB16_34;
	bra.uni 	LBB16_35;
LBB16_34:                               // %true_bb20
	ld.param.u64 	%rd41, [kernel_final_s0_y_y_o___block_id_y_param_32];
	ld.param.u32 	%r90, [kernel_final_s0_y_y_o___block_id_y_param_21];
	ld.param.u64 	%rd39, [kernel_final_s0_y_y_o___block_id_y_param_6];
	ld.param.u64 	%rd38, [kernel_final_s0_y_y_o___block_id_y_param_5];
	ld.param.u64 	%rd33, [kernel_final_s0_y_y_o___block_id_y_param_0];
	cvta.to.global.u64 	%rd2, %rd41;
	cvt.s64.s32 	%rd125, %r85;
	add.s64 	%rd126, %rd11, %rd125;
	add.s64 	%rd127, %rd126, %rd6;
	shl.b64 	%rd128, %rd127, 2;
	ld.shared.f32 	%f105, [%rd128];
	ld.shared.f32 	%f106, [%rd128+960];
	rcp.approx.ftz.f32 	%f107, %f106;
	mul.ftz.f32 	%f108, %f105, %f107;
	add.s32 	%r247, %r2, %r140;
	add.s32 	%r248, %r247, %r89;
	mul.wide.s32 	%rd129, %r248, %r90;
	add.s32 	%r249, %r3, %r139;
	add.s32 	%r250, %r249, %r88;
	cvt.s64.s32 	%rd130, %r250;
	add.s64 	%rd131, %rd129, %rd130;
	sub.s64 	%rd132, %rd131, %rd33;
	shl.b64 	%rd133, %rd132, 2;
	add.s64 	%rd134, %rd2, %rd133;
	st.global.f32 	[%rd134], %f108;
	ld.shared.f32 	%f109, [%rd128+320];
	mul.ftz.f32 	%f110, %f109, %f107;
	add.s64 	%rd135, %rd131, %rd38;
	shl.b64 	%rd136, %rd135, 2;
	add.s64 	%rd137, %rd2, %rd136;
	st.global.f32 	[%rd137], %f110;
	ld.shared.f32 	%f111, [%rd128+640];
	mul.ftz.f32 	%f112, %f111, %f107;
	add.s64 	%rd138, %rd131, %rd39;
	shl.b64 	%rd139, %rd138, 2;
	add.s64 	%rd140, %rd2, %rd139;
	st.global.f32 	[%rd140], %f112;
LBB16_35:                               // %after_bb22
	ret;
}
                                        // -- End function


add_temp_object_file: /tmp/wkriml/lens_blur_auto_schedule.a.o
Module.compile(): temporary object_name /tmp/wkriml/lens_blur_auto_schedule.a.o
emit_file.Compiling to native code...
Module.compile(): static_library_name ./bin/lens_blur_auto_schedule.a
file_unlink: /tmp/wkriml/lens_blur_auto_schedule.a.o
dir_rmdir: /tmp/wkriml
Module.compile(): assembly_name ./bin/lens_blur_auto_schedule.s
emit_file.Compiling to native code...
Module.compile(): c_header_name ./bin/lens_blur_auto_schedule.h
Module.compile(): schedule_name ./bin/lens_blur_auto_schedule.schedule
